// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sensors_grpc/sensors.proto
// Original file comments:
// Copyright (c) 2021 Patroness, LLC. All Rights Reserved.
#ifndef GRPC_sensors_5fgrpc_2fsensors_2eproto__INCLUDED
#define GRPC_sensors_5fgrpc_2fsensors_2eproto__INCLUDED

#include "sensors_grpc/sensors.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace sensors {

class Sensors final {
 public:
  static constexpr char const* service_full_name() {
    return "sensors.Sensors";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncTurnOnLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncTurnOnLedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncTurnOnLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncTurnOnLedRaw(context, request, cq));
    }
    virtual ::grpc::Status TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncTurnOffLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncTurnOffLedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncTurnOffLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncTurnOffLedRaw(context, request, cq));
    }
    virtual ::grpc::Status ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncActivateHmiStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncActivateHmiStateRaw(context, request, cq));
    }
    virtual ::grpc::Status DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncDeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncDeactivateHmiStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncDeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncDeactivateHmiStateRaw(context, request, cq));
    }
    virtual ::grpc::Status SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncSetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncSetNavigationScalingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncSetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncSetNavigationScalingRaw(context, request, cq));
    }
    virtual ::grpc::Status TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncTurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncTurnOnUltrasonicRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncTurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncTurnOnUltrasonicRaw(context, request, cq));
    }
    virtual ::grpc::Status TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncTurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncTurnOffUltrasonicRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncTurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncTurnOffUltrasonicRaw(context, request, cq));
    }
    virtual ::grpc::Status TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncTurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncTurnOnRadarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncTurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncTurnOnRadarRaw(context, request, cq));
    }
    virtual ::grpc::Status TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncTurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncTurnOffRadarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncTurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncTurnOffRadarRaw(context, request, cq));
    }
    virtual ::grpc::Status CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncCollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncCollectImuCalibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncCollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncCollectImuCalibrationRaw(context, request, cq));
    }
    virtual ::grpc::Status DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncDFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncDFGetCurrentParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncDFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncDFGetCurrentParametersRaw(context, request, cq));
    }
    virtual ::grpc::Status DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncDFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncDFGetBufferedEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncDFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncDFGetBufferedEventsRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncDisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncDisableLuciRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncDisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncDisableLuciRaw(context, request, cq));
    }
    virtual ::grpc::Status JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncJsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncJsOverrideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncJsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncJsOverrideRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncSetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncSetDriveModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncSetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncSetDriveModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncSetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncSetRampModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncSetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncSetRampModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncSetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncSetLuciOverrideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncSetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncSetLuciOverrideRaw(context, request, cq));
    }
    virtual ::grpc::Status ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncExtPressCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncExtPressCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::HmiStreamData>> HmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::HmiStreamData>>(HmiStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::HmiStreamData>> AsyncHmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::HmiStreamData>>(AsyncHmiStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::HmiStreamData>> PrepareAsyncHmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::HmiStreamData>>(PrepareAsyncHmiStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::PressCountStreamData>> PressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::PressCountStreamData>>(PressCountStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::PressCountStreamData>> AsyncPressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::PressCountStreamData>>(AsyncPressCountStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::PressCountStreamData>> PrepareAsyncPressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::PressCountStreamData>>(PrepareAsyncPressCountStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::UltrasonicDistances>> UltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::UltrasonicDistances>>(UltrasonicStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicDistances>> AsyncUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicDistances>>(AsyncUltrasonicStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicDistances>> PrepareAsyncUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicDistances>>(PrepareAsyncUltrasonicStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::UltrasonicCurve>> RawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::UltrasonicCurve>>(RawUltrasonicStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicCurve>> AsyncRawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicCurve>>(AsyncRawUltrasonicStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicCurve>> PrepareAsyncRawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicCurve>>(PrepareAsyncRawUltrasonicStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RadarPoints>> RadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RadarPoints>>(RadarStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>> AsyncRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>>(AsyncRadarStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>> PrepareAsyncRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>>(PrepareAsyncRadarStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RadarPoints>> RawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RadarPoints>>(RawRadarStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>> AsyncRawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>>(AsyncRawRadarStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>> PrepareAsyncRawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>>(PrepareAsyncRawRadarStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ChairSpeed>> ChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ChairSpeed>>(ChairSpeedStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairSpeed>> AsyncChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairSpeed>>(AsyncChairSpeedStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairSpeed>> PrepareAsyncChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairSpeed>>(PrepareAsyncChairSpeedStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ImuData>> ImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ImuData>>(ImuStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ImuData>> AsyncImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ImuData>>(AsyncImuStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ImuData>> PrepareAsyncImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ImuData>>(PrepareAsyncImuStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ChairMode>> ChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ChairMode>>(ChairModeStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairMode>> AsyncChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairMode>>(AsyncChairModeStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairMode>> PrepareAsyncChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairMode>>(PrepareAsyncChairModeStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ChairProfile>> ChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ChairProfile>>(ChairProfileStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairProfile>> AsyncChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairProfile>>(AsyncChairProfileStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairProfile>> PrepareAsyncChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ChairProfile>>(PrepareAsyncChairProfileStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::SpeedSetting>> SpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::SpeedSetting>>(SpeedSettingStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SpeedSetting>> AsyncSpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SpeedSetting>>(AsyncSpeedSettingStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SpeedSetting>> PrepareAsyncSpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SpeedSetting>>(PrepareAsyncSpeedSettingStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::Joystick>> JoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::Joystick>>(JoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::Joystick>> AsyncJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::Joystick>>(AsyncJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::Joystick>> PrepareAsyncJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::Joystick>>(PrepareAsyncJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>> VirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>>(VirtualJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> AsyncVirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(AsyncVirtualJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> PrepareAsyncVirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(PrepareAsyncVirtualJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>> PhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>>(PhysicalJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> AsyncPhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(AsyncPhysicalJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> PrepareAsyncPhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(PrepareAsyncPhysicalJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>> ScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>>(ScaledJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> AsyncScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(AsyncScaledJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> PrepareAsyncScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(PrepareAsyncScaledJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>> LuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::JoystickData>>(LuciJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> AsyncLuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(AsyncLuciJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>> PrepareAsyncLuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>>(PrepareAsyncLuciJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::AhrsData>> AhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::AhrsData>>(AhrsStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AhrsData>> AsyncAhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AhrsData>>(AsyncAhrsStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AhrsData>> PrepareAsyncAhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AhrsData>>(PrepareAsyncAhrsStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>> RadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>>(RadarClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> AsyncRadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(AsyncRadarClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> PrepareAsyncRadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(PrepareAsyncRadarClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>> UltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>>(UltrasonicClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> AsyncUltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(AsyncUltrasonicClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> PrepareAsyncUltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(PrepareAsyncUltrasonicClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>> CameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>>(CameraCollisionClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> AsyncCameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(AsyncCameraCollisionClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> PrepareAsyncCameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(PrepareAsyncCameraCollisionClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>> StepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>>(StepClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> AsyncStepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(AsyncStepClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> PrepareAsyncStepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(PrepareAsyncStepClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>> DropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>>(DropoffClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> AsyncDropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(AsyncDropoffClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>> PrepareAsyncDropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>>(PrepareAsyncDropoffClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::NavigationScaling>> ScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::NavigationScaling>>(ScalingStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::NavigationScaling>> AsyncScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::NavigationScaling>>(AsyncScalingStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::NavigationScaling>> PrepareAsyncScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::NavigationScaling>>(PrepareAsyncScalingStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::BatteryVoltage>> BatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::BatteryVoltage>>(BatteryVoltageStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryVoltage>> AsyncBatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryVoltage>>(AsyncBatteryVoltageStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryVoltage>> PrepareAsyncBatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryVoltage>>(PrepareAsyncBatteryVoltageStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::BatteryPercent>> BatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::BatteryPercent>>(BatteryPercentStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryPercent>> AsyncBatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryPercent>>(AsyncBatteryPercentStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryPercent>> PrepareAsyncBatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryPercent>>(PrepareAsyncBatteryPercentStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints>> CameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints>>(CameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>> AsyncCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>>(AsyncCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>> PrepareAsyncCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>>(PrepareAsyncCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints2D>> FlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints2D>>(FlatCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints2D>> AsyncFlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints2D>>(AsyncFlatCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints2D>> PrepareAsyncFlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints2D>>(PrepareAsyncFlatCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints>> DropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints>>(DropoffCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>> AsyncDropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>>(AsyncDropoffCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>> PrepareAsyncDropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>>(PrepareAsyncDropoffCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ObjectDetection2D>> CaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ObjectDetection2D>>(CaneCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ObjectDetection2D>> AsyncCaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ObjectDetection2D>>(AsyncCaneCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ObjectDetection2D>> PrepareAsyncCaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ObjectDetection2D>>(PrepareAsyncCaneCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::GPSData>> GPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::GPSData>>(GPSStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::GPSData>> AsyncGPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::GPSData>>(AsyncGPSStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::GPSData>> PrepareAsyncGPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::GPSData>>(PrepareAsyncGPSStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::SeatPressure>> SeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::SeatPressure>>(SeatPressureStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SeatPressure>> AsyncSeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SeatPressure>>(AsyncSeatPressureStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SeatPressure>> PrepareAsyncSeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::SeatPressure>>(PrepareAsyncSeatPressureStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::DFParameters>> DFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::DFParameters>>(DFParametersChangedStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFParameters>> AsyncDFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFParameters>>(AsyncDFParametersChangedStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFParameters>> PrepareAsyncDFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFParameters>>(PrepareAsyncDFParametersChangedStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::DFSeatEvent>> DFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::DFSeatEvent>>(DFEventStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFSeatEvent>> AsyncDFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFSeatEvent>>(AsyncDFEventStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFSeatEvent>> PrepareAsyncDFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DFSeatEvent>>(PrepareAsyncDFEventStreamRaw(context, request, cq));
    }
    virtual ::grpc::Status SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncSendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncSendLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncSendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncSendLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::LoggingData>> LoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::LoggingData>>(LoggingStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LoggingData>> AsyncLoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LoggingData>>(AsyncLoggingStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LoggingData>> PrepareAsyncLoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LoggingData>>(PrepareAsyncLoggingStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints>> StepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::CameraPoints>>(StepCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>> AsyncStepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>>(AsyncStepCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>> PrepareAsyncStepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>>(PrepareAsyncStepCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::IrFrame>> IrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::IrFrame>>(IrStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::IrFrame>> AsyncIrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::IrFrame>>(AsyncIrStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::IrFrame>> PrepareAsyncIrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::IrFrame>>(PrepareAsyncIrStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RampAssistStates>> RampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RampAssistStates>>(RampAssistStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampAssistStates>> AsyncRampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampAssistStates>>(AsyncRampAssistStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampAssistStates>> PrepareAsyncRampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampAssistStates>>(PrepareAsyncRampAssistStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::DistanceData>> DistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::DistanceData>>(DistStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DistanceData>> AsyncDistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DistanceData>>(AsyncDistStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DistanceData>> PrepareAsyncDistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::DistanceData>>(PrepareAsyncDistStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::StartModeData>> StartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::StartModeData>>(StartModeStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::StartModeData>> AsyncStartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::StartModeData>>(AsyncStartModeStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::StartModeData>> PrepareAsyncStartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::StartModeData>>(PrepareAsyncStartModeStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::AudioPlaybackRequest>> AudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::AudioPlaybackRequest>>(AudioPlaybackRequestStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AudioPlaybackRequest>> AsyncAudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AudioPlaybackRequest>>(AsyncAudioPlaybackRequestStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AudioPlaybackRequest>> PrepareAsyncAudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::AudioPlaybackRequest>>(PrepareAsyncAudioPlaybackRequestStreamRaw(context, request, cq));
    }
    virtual ::grpc::Status GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::ZoneBoundaries* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ZoneBoundaries>> AsyncGetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ZoneBoundaries>>(AsyncGetZoneBoundariesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ZoneBoundaries>> PrepareAsyncGetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ZoneBoundaries>>(PrepareAsyncGetZoneBoundariesRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::BlockedZones* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::BlockedZones>> AsyncGetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::BlockedZones>>(AsyncGetBlockedZonesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::BlockedZones>> PrepareAsyncGetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::BlockedZones>>(PrepareAsyncGetBlockedZonesRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::JoystickRanges* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::JoystickRanges>> AsyncGetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::JoystickRanges>>(AsyncGetJoystickRangesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::JoystickRanges>> PrepareAsyncGetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::JoystickRanges>>(PrepareAsyncGetJoystickRangesRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncEnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncEnableRadarFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncEnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncEnableRadarFilterRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::sensors::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> AsyncDisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(AsyncDisableRadarFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>> PrepareAsyncDisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>>(PrepareAsyncDisableRadarFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::EncoderData>> EncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::EncoderData>>(EncoderStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::EncoderData>> AsyncEncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::EncoderData>>(AsyncEncoderStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::EncoderData>> PrepareAsyncEncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::EncoderData>>(PrepareAsyncEncoderStreamRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::CalMatrix* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::CalMatrix>> AsyncGetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::CalMatrix>>(AsyncGetCalMatrixRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::CalMatrix>> PrepareAsyncGetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::CalMatrix>>(PrepareAsyncGetCalMatrixRaw(context, request, cq));
    }
    virtual ::grpc::Status TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::ReactionTestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ReactionTestResult>> AsyncTestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ReactionTestResult>>(AsyncTestReactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ReactionTestResult>> PrepareAsyncTestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ReactionTestResult>>(PrepareAsyncTestReactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::LuciOverride>> LuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::LuciOverride>>(LuciOverrideStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciOverride>> AsyncLuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciOverride>>(AsyncLuciOverrideStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciOverride>> PrepareAsyncLuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciOverride>>(PrepareAsyncLuciOverrideStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::sensors::LuciLandmark>> LuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::sensors::LuciLandmark>>(LuciLandmarkStreamPassThroughRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::LuciLandmark>> AsyncLuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::LuciLandmark>>(AsyncLuciLandmarkStreamPassThroughRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::LuciLandmark>> PrepareAsyncLuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::LuciLandmark>>(PrepareAsyncLuciLandmarkStreamPassThroughRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::sensors::RampInfo>> RampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::sensors::RampInfo>>(RampInfoStreamPassThroughRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::RampInfo>> AsyncRampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::RampInfo>>(AsyncRampInfoStreamPassThroughRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::RampInfo>> PrepareAsyncRampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::sensors::RampInfo>>(PrepareAsyncRampInfoStreamPassThroughRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::LuciLandmark>> LuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::LuciLandmark>>(LuciLandmarkStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciLandmark>> AsyncLuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciLandmark>>(AsyncLuciLandmarkStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciLandmark>> PrepareAsyncLuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::LuciLandmark>>(PrepareAsyncLuciLandmarkStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RampInfo>> RampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::RampInfo>>(RampInfoStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampInfo>> AsyncRampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampInfo>>(AsyncRampInfoStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampInfo>> PrepareAsyncRampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::RampInfo>>(PrepareAsyncRampInfoStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ModeCtrl>> DriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sensors::ModeCtrl>>(DriveModeStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ModeCtrl>> AsyncDriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ModeCtrl>>(AsyncDriveModeStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ModeCtrl>> PrepareAsyncDriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sensors::ModeCtrl>>(PrepareAsyncDriveModeStreamRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::HmiStreamData>* reactor) = 0;
      #else
      virtual void HmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::HmiStreamData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest* request, ::grpc::ClientReadReactor< ::sensors::PressCountStreamData>* reactor) = 0;
      #else
      virtual void PressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest* request, ::grpc::experimental::ClientReadReactor< ::sensors::PressCountStreamData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::UltrasonicDistances>* reactor) = 0;
      #else
      virtual void UltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::UltrasonicDistances>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::UltrasonicCurve>* reactor) = 0;
      #else
      virtual void RawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::UltrasonicCurve>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RadarPoints>* reactor) = 0;
      #else
      virtual void RadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RadarPoints>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RadarPoints>* reactor) = 0;
      #else
      virtual void RawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RadarPoints>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ChairSpeed>* reactor) = 0;
      #else
      virtual void ChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ChairSpeed>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl* request, ::grpc::ClientReadReactor< ::sensors::ImuData>* reactor) = 0;
      #else
      virtual void ImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl* request, ::grpc::experimental::ClientReadReactor< ::sensors::ImuData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ChairMode>* reactor) = 0;
      #else
      virtual void ChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ChairMode>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ChairProfile>* reactor) = 0;
      #else
      virtual void ChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ChairProfile>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::SpeedSetting>* reactor) = 0;
      #else
      virtual void SpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::SpeedSetting>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::Joystick>* reactor) = 0;
      #else
      virtual void JoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::Joystick>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #else
      virtual void VirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #else
      virtual void PhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #else
      virtual void ScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #else
      virtual void LuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::AhrsData>* reactor) = 0;
      #else
      virtual void AhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::AhrsData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #else
      virtual void RadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #else
      virtual void UltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #else
      virtual void CameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #else
      virtual void StepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #else
      virtual void DropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::NavigationScaling>* reactor) = 0;
      #else
      virtual void ScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::NavigationScaling>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::BatteryVoltage>* reactor) = 0;
      #else
      virtual void BatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::BatteryVoltage>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::BatteryPercent>* reactor) = 0;
      #else
      virtual void BatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::BatteryPercent>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints>* reactor) = 0;
      #else
      virtual void CameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints2D>* reactor) = 0;
      #else
      virtual void FlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints2D>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints>* reactor) = 0;
      #else
      virtual void DropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ObjectDetection2D>* reactor) = 0;
      #else
      virtual void CaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ObjectDetection2D>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::GPSData>* reactor) = 0;
      #else
      virtual void GPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::GPSData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::SeatPressure>* reactor) = 0;
      #else
      virtual void SeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::SeatPressure>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::DFParameters>* reactor) = 0;
      #else
      virtual void DFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::DFParameters>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::DFSeatEvent>* reactor) = 0;
      #else
      virtual void DFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::DFSeatEvent>* reactor) = 0;
      #endif
      virtual void SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::LoggingData>* reactor) = 0;
      #else
      virtual void LoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::LoggingData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints>* reactor) = 0;
      #else
      virtual void StepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::IrFrame>* reactor) = 0;
      #else
      virtual void IrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::IrFrame>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RampAssistStates>* reactor) = 0;
      #else
      virtual void RampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RampAssistStates>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::DistanceData>* reactor) = 0;
      #else
      virtual void DistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::DistanceData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::StartModeData>* reactor) = 0;
      #else
      virtual void StartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::StartModeData>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::AudioPlaybackRequest>* reactor) = 0;
      #else
      virtual void AudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::AudioPlaybackRequest>* reactor) = 0;
      #endif
      virtual void GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::EncoderData>* reactor) = 0;
      #else
      virtual void EncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::EncoderData>* reactor) = 0;
      #endif
      virtual void GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::LuciOverride>* reactor) = 0;
      #else
      virtual void LuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::LuciOverride>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::ClientWriteReactor< ::sensors::LuciLandmark>* reactor) = 0;
      #else
      virtual void LuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::experimental::ClientWriteReactor< ::sensors::LuciLandmark>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::ClientWriteReactor< ::sensors::RampInfo>* reactor) = 0;
      #else
      virtual void RampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::experimental::ClientWriteReactor< ::sensors::RampInfo>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::LuciLandmark>* reactor) = 0;
      #else
      virtual void LuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::LuciLandmark>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RampInfo>* reactor) = 0;
      #else
      virtual void RampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RampInfo>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ModeCtrl>* reactor) = 0;
      #else
      virtual void DriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ModeCtrl>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncTurnOnLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncTurnOnLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncTurnOffLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncTurnOffLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncActivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncActivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncDeactivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncDeactivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncSetNavigationScalingRaw(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncSetNavigationScalingRaw(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncTurnOnUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncTurnOnUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncTurnOffUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncTurnOffUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncTurnOnRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncTurnOnRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncTurnOffRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncTurnOffRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncCollectImuCalibrationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncCollectImuCalibrationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncDFGetCurrentParametersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncDFGetCurrentParametersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncDFGetBufferedEventsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncDFGetBufferedEventsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncDisableLuciRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncDisableLuciRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncJsOverrideRaw(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncJsOverrideRaw(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncSetDriveModeRaw(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncSetDriveModeRaw(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncSetRampModeRaw(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncSetRampModeRaw(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncSetLuciOverrideRaw(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncSetLuciOverrideRaw(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncExtPressCountRaw(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncExtPressCountRaw(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::HmiStreamData>* HmiStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::HmiStreamData>* AsyncHmiStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::HmiStreamData>* PrepareAsyncHmiStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::PressCountStreamData>* PressCountStreamRaw(::grpc::ClientContext* context, const ::sensors::PressRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::PressCountStreamData>* AsyncPressCountStreamRaw(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::PressCountStreamData>* PrepareAsyncPressCountStreamRaw(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::UltrasonicDistances>* UltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicDistances>* AsyncUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicDistances>* PrepareAsyncUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::UltrasonicCurve>* RawUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicCurve>* AsyncRawUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::UltrasonicCurve>* PrepareAsyncRawUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::RadarPoints>* RadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>* AsyncRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>* PrepareAsyncRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::RadarPoints>* RawRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>* AsyncRawRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RadarPoints>* PrepareAsyncRawRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ChairSpeed>* ChairSpeedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ChairSpeed>* AsyncChairSpeedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ChairSpeed>* PrepareAsyncChairSpeedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ImuData>* ImuStreamRaw(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ImuData>* AsyncImuStreamRaw(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ImuData>* PrepareAsyncImuStreamRaw(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ChairMode>* ChairModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ChairMode>* AsyncChairModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ChairMode>* PrepareAsyncChairModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ChairProfile>* ChairProfileStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ChairProfile>* AsyncChairProfileStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ChairProfile>* PrepareAsyncChairProfileStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::SpeedSetting>* SpeedSettingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::SpeedSetting>* AsyncSpeedSettingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::SpeedSetting>* PrepareAsyncSpeedSettingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::Joystick>* JoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::Joystick>* AsyncJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::Joystick>* PrepareAsyncJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::JoystickData>* VirtualJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* AsyncVirtualJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* PrepareAsyncVirtualJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::JoystickData>* PhysicalJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* AsyncPhysicalJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* PrepareAsyncPhysicalJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::JoystickData>* ScaledJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* AsyncScaledJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* PrepareAsyncScaledJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::JoystickData>* LuciJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* AsyncLuciJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::JoystickData>* PrepareAsyncLuciJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::AhrsData>* AhrsStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::AhrsData>* AsyncAhrsStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::AhrsData>* PrepareAsyncAhrsStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>* RadarClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* AsyncRadarClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* PrepareAsyncRadarClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>* UltrasonicClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* AsyncUltrasonicClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* PrepareAsyncUltrasonicClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>* CameraCollisionClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* AsyncCameraCollisionClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* PrepareAsyncCameraCollisionClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>* StepClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* AsyncStepClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* PrepareAsyncStepClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ClosestObstacles>* DropoffClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* AsyncDropoffClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ClosestObstacles>* PrepareAsyncDropoffClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::NavigationScaling>* ScalingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::NavigationScaling>* AsyncScalingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::NavigationScaling>* PrepareAsyncScalingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::BatteryVoltage>* BatteryVoltageStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryVoltage>* AsyncBatteryVoltageStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryVoltage>* PrepareAsyncBatteryVoltageStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::BatteryPercent>* BatteryPercentStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryPercent>* AsyncBatteryPercentStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::BatteryPercent>* PrepareAsyncBatteryPercentStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::CameraPoints>* CameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>* AsyncCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>* PrepareAsyncCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::CameraPoints2D>* FlatCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints2D>* AsyncFlatCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints2D>* PrepareAsyncFlatCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::CameraPoints>* DropoffCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>* AsyncDropoffCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>* PrepareAsyncDropoffCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ObjectDetection2D>* CaneCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ObjectDetection2D>* AsyncCaneCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ObjectDetection2D>* PrepareAsyncCaneCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::GPSData>* GPSStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::GPSData>* AsyncGPSStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::GPSData>* PrepareAsyncGPSStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::SeatPressure>* SeatPressureStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::SeatPressure>* AsyncSeatPressureStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::SeatPressure>* PrepareAsyncSeatPressureStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::DFParameters>* DFParametersChangedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::DFParameters>* AsyncDFParametersChangedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::DFParameters>* PrepareAsyncDFParametersChangedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::DFSeatEvent>* DFEventStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::DFSeatEvent>* AsyncDFEventStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::DFSeatEvent>* PrepareAsyncDFEventStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncSendLoggingRaw(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncSendLoggingRaw(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::LoggingData>* LoggingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::LoggingData>* AsyncLoggingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::LoggingData>* PrepareAsyncLoggingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::CameraPoints>* StepCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>* AsyncStepCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::CameraPoints>* PrepareAsyncStepCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::IrFrame>* IrStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::IrFrame>* AsyncIrStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::IrFrame>* PrepareAsyncIrStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::RampAssistStates>* RampAssistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RampAssistStates>* AsyncRampAssistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RampAssistStates>* PrepareAsyncRampAssistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::DistanceData>* DistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::DistanceData>* AsyncDistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::DistanceData>* PrepareAsyncDistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::StartModeData>* StartModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::StartModeData>* AsyncStartModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::StartModeData>* PrepareAsyncStartModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::AudioPlaybackRequest>* AudioPlaybackRequestStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::AudioPlaybackRequest>* AsyncAudioPlaybackRequestStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::AudioPlaybackRequest>* PrepareAsyncAudioPlaybackRequestStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ZoneBoundaries>* AsyncGetZoneBoundariesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ZoneBoundaries>* PrepareAsyncGetZoneBoundariesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::BlockedZones>* AsyncGetBlockedZonesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::BlockedZones>* PrepareAsyncGetBlockedZonesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::JoystickRanges>* AsyncGetJoystickRangesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::JoystickRanges>* PrepareAsyncGetJoystickRangesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncEnableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncEnableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* AsyncDisableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::Response>* PrepareAsyncDisableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::EncoderData>* EncoderStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::EncoderData>* AsyncEncoderStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::EncoderData>* PrepareAsyncEncoderStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::CalMatrix>* AsyncGetCalMatrixRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::CalMatrix>* PrepareAsyncGetCalMatrixRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ReactionTestResult>* AsyncTestReactionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sensors::ReactionTestResult>* PrepareAsyncTestReactionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::LuciOverride>* LuciOverrideStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::LuciOverride>* AsyncLuciOverrideStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::LuciOverride>* PrepareAsyncLuciOverrideStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::sensors::LuciLandmark>* LuciLandmarkStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::sensors::LuciLandmark>* AsyncLuciLandmarkStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::sensors::LuciLandmark>* PrepareAsyncLuciLandmarkStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::sensors::RampInfo>* RampInfoStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::sensors::RampInfo>* AsyncRampInfoStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::sensors::RampInfo>* PrepareAsyncRampInfoStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::LuciLandmark>* LuciLandmarkStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::LuciLandmark>* AsyncLuciLandmarkStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::LuciLandmark>* PrepareAsyncLuciLandmarkStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::RampInfo>* RampInfoStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RampInfo>* AsyncRampInfoStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::RampInfo>* PrepareAsyncRampInfoStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sensors::ModeCtrl>* DriveModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ModeCtrl>* AsyncDriveModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sensors::ModeCtrl>* PrepareAsyncDriveModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncTurnOnLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncTurnOnLedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncTurnOnLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncTurnOnLedRaw(context, request, cq));
    }
    ::grpc::Status TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncTurnOffLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncTurnOffLedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncTurnOffLed(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncTurnOffLedRaw(context, request, cq));
    }
    ::grpc::Status ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncActivateHmiStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncActivateHmiStateRaw(context, request, cq));
    }
    ::grpc::Status DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncDeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncDeactivateHmiStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncDeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncDeactivateHmiStateRaw(context, request, cq));
    }
    ::grpc::Status SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncSetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncSetNavigationScalingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncSetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncSetNavigationScalingRaw(context, request, cq));
    }
    ::grpc::Status TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncTurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncTurnOnUltrasonicRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncTurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncTurnOnUltrasonicRaw(context, request, cq));
    }
    ::grpc::Status TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncTurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncTurnOffUltrasonicRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncTurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncTurnOffUltrasonicRaw(context, request, cq));
    }
    ::grpc::Status TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncTurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncTurnOnRadarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncTurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncTurnOnRadarRaw(context, request, cq));
    }
    ::grpc::Status TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncTurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncTurnOffRadarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncTurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncTurnOffRadarRaw(context, request, cq));
    }
    ::grpc::Status CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncCollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncCollectImuCalibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncCollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncCollectImuCalibrationRaw(context, request, cq));
    }
    ::grpc::Status DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncDFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncDFGetCurrentParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncDFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncDFGetCurrentParametersRaw(context, request, cq));
    }
    ::grpc::Status DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncDFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncDFGetBufferedEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncDFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncDFGetBufferedEventsRaw(context, request, cq));
    }
    ::grpc::Status DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncDisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncDisableLuciRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncDisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncDisableLuciRaw(context, request, cq));
    }
    ::grpc::Status JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncJsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncJsOverrideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncJsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncJsOverrideRaw(context, request, cq));
    }
    ::grpc::Status SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncSetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncSetDriveModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncSetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncSetDriveModeRaw(context, request, cq));
    }
    ::grpc::Status SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncSetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncSetRampModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncSetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncSetRampModeRaw(context, request, cq));
    }
    ::grpc::Status SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncSetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncSetLuciOverrideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncSetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncSetLuciOverrideRaw(context, request, cq));
    }
    ::grpc::Status ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncExtPressCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncExtPressCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::HmiStreamData>> HmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::HmiStreamData>>(HmiStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::HmiStreamData>> AsyncHmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::HmiStreamData>>(AsyncHmiStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::HmiStreamData>> PrepareAsyncHmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::HmiStreamData>>(PrepareAsyncHmiStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::PressCountStreamData>> PressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::PressCountStreamData>>(PressCountStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::PressCountStreamData>> AsyncPressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::PressCountStreamData>>(AsyncPressCountStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::PressCountStreamData>> PrepareAsyncPressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::PressCountStreamData>>(PrepareAsyncPressCountStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::UltrasonicDistances>> UltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::UltrasonicDistances>>(UltrasonicStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicDistances>> AsyncUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicDistances>>(AsyncUltrasonicStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicDistances>> PrepareAsyncUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicDistances>>(PrepareAsyncUltrasonicStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::UltrasonicCurve>> RawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::UltrasonicCurve>>(RawUltrasonicStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicCurve>> AsyncRawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicCurve>>(AsyncRawUltrasonicStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicCurve>> PrepareAsyncRawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::UltrasonicCurve>>(PrepareAsyncRawUltrasonicStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::RadarPoints>> RadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::RadarPoints>>(RadarStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>> AsyncRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>>(AsyncRadarStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>> PrepareAsyncRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>>(PrepareAsyncRadarStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::RadarPoints>> RawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::RadarPoints>>(RawRadarStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>> AsyncRawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>>(AsyncRawRadarStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>> PrepareAsyncRawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RadarPoints>>(PrepareAsyncRawRadarStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ChairSpeed>> ChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ChairSpeed>>(ChairSpeedStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairSpeed>> AsyncChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairSpeed>>(AsyncChairSpeedStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairSpeed>> PrepareAsyncChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairSpeed>>(PrepareAsyncChairSpeedStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ImuData>> ImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ImuData>>(ImuStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ImuData>> AsyncImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ImuData>>(AsyncImuStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ImuData>> PrepareAsyncImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ImuData>>(PrepareAsyncImuStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ChairMode>> ChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ChairMode>>(ChairModeStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairMode>> AsyncChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairMode>>(AsyncChairModeStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairMode>> PrepareAsyncChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairMode>>(PrepareAsyncChairModeStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ChairProfile>> ChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ChairProfile>>(ChairProfileStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairProfile>> AsyncChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairProfile>>(AsyncChairProfileStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairProfile>> PrepareAsyncChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ChairProfile>>(PrepareAsyncChairProfileStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::SpeedSetting>> SpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::SpeedSetting>>(SpeedSettingStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SpeedSetting>> AsyncSpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SpeedSetting>>(AsyncSpeedSettingStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SpeedSetting>> PrepareAsyncSpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SpeedSetting>>(PrepareAsyncSpeedSettingStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::Joystick>> JoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::Joystick>>(JoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::Joystick>> AsyncJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::Joystick>>(AsyncJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::Joystick>> PrepareAsyncJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::Joystick>>(PrepareAsyncJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>> VirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>>(VirtualJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> AsyncVirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(AsyncVirtualJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> PrepareAsyncVirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(PrepareAsyncVirtualJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>> PhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>>(PhysicalJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> AsyncPhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(AsyncPhysicalJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> PrepareAsyncPhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(PrepareAsyncPhysicalJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>> ScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>>(ScaledJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> AsyncScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(AsyncScaledJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> PrepareAsyncScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(PrepareAsyncScaledJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>> LuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::JoystickData>>(LuciJoystickStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> AsyncLuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(AsyncLuciJoystickStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>> PrepareAsyncLuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::JoystickData>>(PrepareAsyncLuciJoystickStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::AhrsData>> AhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::AhrsData>>(AhrsStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AhrsData>> AsyncAhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AhrsData>>(AsyncAhrsStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AhrsData>> PrepareAsyncAhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AhrsData>>(PrepareAsyncAhrsStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>> RadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>>(RadarClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> AsyncRadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(AsyncRadarClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> PrepareAsyncRadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(PrepareAsyncRadarClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>> UltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>>(UltrasonicClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> AsyncUltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(AsyncUltrasonicClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> PrepareAsyncUltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(PrepareAsyncUltrasonicClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>> CameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>>(CameraCollisionClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> AsyncCameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(AsyncCameraCollisionClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> PrepareAsyncCameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(PrepareAsyncCameraCollisionClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>> StepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>>(StepClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> AsyncStepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(AsyncStepClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> PrepareAsyncStepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(PrepareAsyncStepClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>> DropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ClosestObstacles>>(DropoffClosestObstaclesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> AsyncDropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(AsyncDropoffClosestObstaclesStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>> PrepareAsyncDropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>>(PrepareAsyncDropoffClosestObstaclesStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::NavigationScaling>> ScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::NavigationScaling>>(ScalingStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::NavigationScaling>> AsyncScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::NavigationScaling>>(AsyncScalingStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::NavigationScaling>> PrepareAsyncScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::NavigationScaling>>(PrepareAsyncScalingStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::BatteryVoltage>> BatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::BatteryVoltage>>(BatteryVoltageStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryVoltage>> AsyncBatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryVoltage>>(AsyncBatteryVoltageStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryVoltage>> PrepareAsyncBatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryVoltage>>(PrepareAsyncBatteryVoltageStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::BatteryPercent>> BatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::BatteryPercent>>(BatteryPercentStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryPercent>> AsyncBatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryPercent>>(AsyncBatteryPercentStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryPercent>> PrepareAsyncBatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::BatteryPercent>>(PrepareAsyncBatteryPercentStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints>> CameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints>>(CameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>> AsyncCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>>(AsyncCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>> PrepareAsyncCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>>(PrepareAsyncCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints2D>> FlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints2D>>(FlatCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints2D>> AsyncFlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints2D>>(AsyncFlatCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints2D>> PrepareAsyncFlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints2D>>(PrepareAsyncFlatCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints>> DropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints>>(DropoffCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>> AsyncDropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>>(AsyncDropoffCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>> PrepareAsyncDropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>>(PrepareAsyncDropoffCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ObjectDetection2D>> CaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ObjectDetection2D>>(CaneCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ObjectDetection2D>> AsyncCaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ObjectDetection2D>>(AsyncCaneCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ObjectDetection2D>> PrepareAsyncCaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ObjectDetection2D>>(PrepareAsyncCaneCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::GPSData>> GPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::GPSData>>(GPSStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::GPSData>> AsyncGPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::GPSData>>(AsyncGPSStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::GPSData>> PrepareAsyncGPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::GPSData>>(PrepareAsyncGPSStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::SeatPressure>> SeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::SeatPressure>>(SeatPressureStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SeatPressure>> AsyncSeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SeatPressure>>(AsyncSeatPressureStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SeatPressure>> PrepareAsyncSeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::SeatPressure>>(PrepareAsyncSeatPressureStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::DFParameters>> DFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::DFParameters>>(DFParametersChangedStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFParameters>> AsyncDFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFParameters>>(AsyncDFParametersChangedStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFParameters>> PrepareAsyncDFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFParameters>>(PrepareAsyncDFParametersChangedStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::DFSeatEvent>> DFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::DFSeatEvent>>(DFEventStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFSeatEvent>> AsyncDFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFSeatEvent>>(AsyncDFEventStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFSeatEvent>> PrepareAsyncDFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DFSeatEvent>>(PrepareAsyncDFEventStreamRaw(context, request, cq));
    }
    ::grpc::Status SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncSendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncSendLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncSendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncSendLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::LoggingData>> LoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::LoggingData>>(LoggingStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LoggingData>> AsyncLoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LoggingData>>(AsyncLoggingStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LoggingData>> PrepareAsyncLoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LoggingData>>(PrepareAsyncLoggingStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints>> StepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::CameraPoints>>(StepCameraStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>> AsyncStepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>>(AsyncStepCameraStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>> PrepareAsyncStepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::CameraPoints>>(PrepareAsyncStepCameraStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::IrFrame>> IrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::IrFrame>>(IrStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::IrFrame>> AsyncIrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::IrFrame>>(AsyncIrStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::IrFrame>> PrepareAsyncIrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::IrFrame>>(PrepareAsyncIrStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::RampAssistStates>> RampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::RampAssistStates>>(RampAssistStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampAssistStates>> AsyncRampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampAssistStates>>(AsyncRampAssistStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampAssistStates>> PrepareAsyncRampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampAssistStates>>(PrepareAsyncRampAssistStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::DistanceData>> DistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::DistanceData>>(DistStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DistanceData>> AsyncDistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DistanceData>>(AsyncDistStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DistanceData>> PrepareAsyncDistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::DistanceData>>(PrepareAsyncDistStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::StartModeData>> StartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::StartModeData>>(StartModeStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::StartModeData>> AsyncStartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::StartModeData>>(AsyncStartModeStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::StartModeData>> PrepareAsyncStartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::StartModeData>>(PrepareAsyncStartModeStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::AudioPlaybackRequest>> AudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::AudioPlaybackRequest>>(AudioPlaybackRequestStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AudioPlaybackRequest>> AsyncAudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AudioPlaybackRequest>>(AsyncAudioPlaybackRequestStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AudioPlaybackRequest>> PrepareAsyncAudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::AudioPlaybackRequest>>(PrepareAsyncAudioPlaybackRequestStreamRaw(context, request, cq));
    }
    ::grpc::Status GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::ZoneBoundaries* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ZoneBoundaries>> AsyncGetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ZoneBoundaries>>(AsyncGetZoneBoundariesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ZoneBoundaries>> PrepareAsyncGetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ZoneBoundaries>>(PrepareAsyncGetZoneBoundariesRaw(context, request, cq));
    }
    ::grpc::Status GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::BlockedZones* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::BlockedZones>> AsyncGetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::BlockedZones>>(AsyncGetBlockedZonesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::BlockedZones>> PrepareAsyncGetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::BlockedZones>>(PrepareAsyncGetBlockedZonesRaw(context, request, cq));
    }
    ::grpc::Status GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::JoystickRanges* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::JoystickRanges>> AsyncGetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::JoystickRanges>>(AsyncGetJoystickRangesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::JoystickRanges>> PrepareAsyncGetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::JoystickRanges>>(PrepareAsyncGetJoystickRangesRaw(context, request, cq));
    }
    ::grpc::Status EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncEnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncEnableRadarFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncEnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncEnableRadarFilterRaw(context, request, cq));
    }
    ::grpc::Status DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::sensors::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> AsyncDisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(AsyncDisableRadarFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>> PrepareAsyncDisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::Response>>(PrepareAsyncDisableRadarFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::EncoderData>> EncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::EncoderData>>(EncoderStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::EncoderData>> AsyncEncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::EncoderData>>(AsyncEncoderStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::EncoderData>> PrepareAsyncEncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::EncoderData>>(PrepareAsyncEncoderStreamRaw(context, request, cq));
    }
    ::grpc::Status GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::CalMatrix* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::CalMatrix>> AsyncGetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::CalMatrix>>(AsyncGetCalMatrixRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::CalMatrix>> PrepareAsyncGetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::CalMatrix>>(PrepareAsyncGetCalMatrixRaw(context, request, cq));
    }
    ::grpc::Status TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sensors::ReactionTestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ReactionTestResult>> AsyncTestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ReactionTestResult>>(AsyncTestReactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ReactionTestResult>> PrepareAsyncTestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sensors::ReactionTestResult>>(PrepareAsyncTestReactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::LuciOverride>> LuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::LuciOverride>>(LuciOverrideStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciOverride>> AsyncLuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciOverride>>(AsyncLuciOverrideStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciOverride>> PrepareAsyncLuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciOverride>>(PrepareAsyncLuciOverrideStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::sensors::LuciLandmark>> LuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::sensors::LuciLandmark>>(LuciLandmarkStreamPassThroughRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::LuciLandmark>> AsyncLuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::LuciLandmark>>(AsyncLuciLandmarkStreamPassThroughRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::LuciLandmark>> PrepareAsyncLuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::LuciLandmark>>(PrepareAsyncLuciLandmarkStreamPassThroughRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::sensors::RampInfo>> RampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::sensors::RampInfo>>(RampInfoStreamPassThroughRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::RampInfo>> AsyncRampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::RampInfo>>(AsyncRampInfoStreamPassThroughRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::RampInfo>> PrepareAsyncRampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::sensors::RampInfo>>(PrepareAsyncRampInfoStreamPassThroughRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::LuciLandmark>> LuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::LuciLandmark>>(LuciLandmarkStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciLandmark>> AsyncLuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciLandmark>>(AsyncLuciLandmarkStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciLandmark>> PrepareAsyncLuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::LuciLandmark>>(PrepareAsyncLuciLandmarkStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::RampInfo>> RampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::RampInfo>>(RampInfoStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampInfo>> AsyncRampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampInfo>>(AsyncRampInfoStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampInfo>> PrepareAsyncRampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::RampInfo>>(PrepareAsyncRampInfoStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sensors::ModeCtrl>> DriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sensors::ModeCtrl>>(DriveModeStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ModeCtrl>> AsyncDriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ModeCtrl>>(AsyncDriveModeStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ModeCtrl>> PrepareAsyncDriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sensors::ModeCtrl>>(PrepareAsyncDriveModeStreamRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TurnOnLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TurnOffLed(::grpc::ClientContext* context, const ::sensors::Led* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ActivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeactivateHmiState(::grpc::ClientContext* context, const ::sensors::HmiState* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetNavigationScaling(::grpc::ClientContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TurnOnUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TurnOffUltrasonic(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TurnOnRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TurnOffRadar(::grpc::ClientContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CollectImuCalibration(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DFGetCurrentParameters(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DFGetBufferedEvents(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DisableLuci(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void JsOverride(::grpc::ClientContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetDriveMode(::grpc::ClientContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetRampMode(::grpc::ClientContext* context, const ::sensors::RampMode* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetLuciOverride(::grpc::ClientContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExtPressCount(::grpc::ClientContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::HmiStreamData>* reactor) override;
      #else
      void HmiStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::HmiStreamData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest* request, ::grpc::ClientReadReactor< ::sensors::PressCountStreamData>* reactor) override;
      #else
      void PressCountStream(::grpc::ClientContext* context, const ::sensors::PressRequest* request, ::grpc::experimental::ClientReadReactor< ::sensors::PressCountStreamData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::UltrasonicDistances>* reactor) override;
      #else
      void UltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::UltrasonicDistances>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::UltrasonicCurve>* reactor) override;
      #else
      void RawUltrasonicStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::UltrasonicCurve>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RadarPoints>* reactor) override;
      #else
      void RadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RadarPoints>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RadarPoints>* reactor) override;
      #else
      void RawRadarStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RadarPoints>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ChairSpeed>* reactor) override;
      #else
      void ChairSpeedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ChairSpeed>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl* request, ::grpc::ClientReadReactor< ::sensors::ImuData>* reactor) override;
      #else
      void ImuStream(::grpc::ClientContext* context, const ::sensors::ImuCtrl* request, ::grpc::experimental::ClientReadReactor< ::sensors::ImuData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ChairMode>* reactor) override;
      #else
      void ChairModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ChairMode>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ChairProfile>* reactor) override;
      #else
      void ChairProfileStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ChairProfile>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::SpeedSetting>* reactor) override;
      #else
      void SpeedSettingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::SpeedSetting>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::Joystick>* reactor) override;
      #else
      void JoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::Joystick>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #else
      void VirtualJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #else
      void PhysicalJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #else
      void ScaledJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #else
      void LuciJoystickStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::JoystickData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::AhrsData>* reactor) override;
      #else
      void AhrsStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::AhrsData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #else
      void RadarClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #else
      void UltrasonicClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #else
      void CameraCollisionClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #else
      void StepClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #else
      void DropoffClosestObstaclesStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ClosestObstacles>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::NavigationScaling>* reactor) override;
      #else
      void ScalingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::NavigationScaling>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::BatteryVoltage>* reactor) override;
      #else
      void BatteryVoltageStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::BatteryVoltage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::BatteryPercent>* reactor) override;
      #else
      void BatteryPercentStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::BatteryPercent>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints>* reactor) override;
      #else
      void CameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints2D>* reactor) override;
      #else
      void FlatCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints2D>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints>* reactor) override;
      #else
      void DropoffCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ObjectDetection2D>* reactor) override;
      #else
      void CaneCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ObjectDetection2D>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::GPSData>* reactor) override;
      #else
      void GPSStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::GPSData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::SeatPressure>* reactor) override;
      #else
      void SeatPressureStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::SeatPressure>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::DFParameters>* reactor) override;
      #else
      void DFParametersChangedStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::DFParameters>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::DFSeatEvent>* reactor) override;
      #else
      void DFEventStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::DFSeatEvent>* reactor) override;
      #endif
      void SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendLogging(::grpc::ClientContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::LoggingData>* reactor) override;
      #else
      void LoggingStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::LoggingData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::CameraPoints>* reactor) override;
      #else
      void StepCameraStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::CameraPoints>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::IrFrame>* reactor) override;
      #else
      void IrStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::IrFrame>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RampAssistStates>* reactor) override;
      #else
      void RampAssistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RampAssistStates>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::DistanceData>* reactor) override;
      #else
      void DistStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::DistanceData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::StartModeData>* reactor) override;
      #else
      void StartModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::StartModeData>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::AudioPlaybackRequest>* reactor) override;
      #else
      void AudioPlaybackRequestStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::AudioPlaybackRequest>* reactor) override;
      #endif
      void GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetZoneBoundaries(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockedZones(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetJoystickRanges(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EnableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DisableRadarFilter(::grpc::ClientContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::EncoderData>* reactor) override;
      #else
      void EncoderStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::EncoderData>* reactor) override;
      #endif
      void GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCalMatrix(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TestReaction(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::LuciOverride>* reactor) override;
      #else
      void LuciOverrideStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::LuciOverride>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::ClientWriteReactor< ::sensors::LuciLandmark>* reactor) override;
      #else
      void LuciLandmarkStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::experimental::ClientWriteReactor< ::sensors::LuciLandmark>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::ClientWriteReactor< ::sensors::RampInfo>* reactor) override;
      #else
      void RampInfoStreamPassThrough(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::experimental::ClientWriteReactor< ::sensors::RampInfo>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::LuciLandmark>* reactor) override;
      #else
      void LuciLandmarkStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::LuciLandmark>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::RampInfo>* reactor) override;
      #else
      void RampInfoStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::RampInfo>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::sensors::ModeCtrl>* reactor) override;
      #else
      void DriveModeStream(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::sensors::ModeCtrl>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncTurnOnLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncTurnOnLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncTurnOffLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncTurnOffLedRaw(::grpc::ClientContext* context, const ::sensors::Led& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncActivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncActivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncDeactivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncDeactivateHmiStateRaw(::grpc::ClientContext* context, const ::sensors::HmiState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncSetNavigationScalingRaw(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncSetNavigationScalingRaw(::grpc::ClientContext* context, const ::sensors::NavigationScaling& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncTurnOnUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncTurnOnUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncTurnOffUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncTurnOffUltrasonicRaw(::grpc::ClientContext* context, const ::sensors::UltrasonicCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncTurnOnRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncTurnOnRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncTurnOffRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncTurnOffRadarRaw(::grpc::ClientContext* context, const ::sensors::RadarCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncCollectImuCalibrationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncCollectImuCalibrationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncDFGetCurrentParametersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncDFGetCurrentParametersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncDFGetBufferedEventsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncDFGetBufferedEventsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncDisableLuciRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncDisableLuciRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncJsOverrideRaw(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncJsOverrideRaw(::grpc::ClientContext* context, const ::sensors::RemoteJsValues& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncSetDriveModeRaw(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncSetDriveModeRaw(::grpc::ClientContext* context, const ::sensors::ModeCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncSetRampModeRaw(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncSetRampModeRaw(::grpc::ClientContext* context, const ::sensors::RampMode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncSetLuciOverrideRaw(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncSetLuciOverrideRaw(::grpc::ClientContext* context, const ::sensors::LuciOverride& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncExtPressCountRaw(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncExtPressCountRaw(::grpc::ClientContext* context, const ::sensors::PressCountStreamData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::HmiStreamData>* HmiStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::HmiStreamData>* AsyncHmiStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::HmiStreamData>* PrepareAsyncHmiStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::PressCountStreamData>* PressCountStreamRaw(::grpc::ClientContext* context, const ::sensors::PressRequest& request) override;
    ::grpc::ClientAsyncReader< ::sensors::PressCountStreamData>* AsyncPressCountStreamRaw(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::PressCountStreamData>* PrepareAsyncPressCountStreamRaw(::grpc::ClientContext* context, const ::sensors::PressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::UltrasonicDistances>* UltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::UltrasonicDistances>* AsyncUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::UltrasonicDistances>* PrepareAsyncUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::UltrasonicCurve>* RawUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::UltrasonicCurve>* AsyncRawUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::UltrasonicCurve>* PrepareAsyncRawUltrasonicStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::RadarPoints>* RadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::RadarPoints>* AsyncRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::RadarPoints>* PrepareAsyncRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::RadarPoints>* RawRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::RadarPoints>* AsyncRawRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::RadarPoints>* PrepareAsyncRawRadarStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ChairSpeed>* ChairSpeedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ChairSpeed>* AsyncChairSpeedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ChairSpeed>* PrepareAsyncChairSpeedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ImuData>* ImuStreamRaw(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ImuData>* AsyncImuStreamRaw(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ImuData>* PrepareAsyncImuStreamRaw(::grpc::ClientContext* context, const ::sensors::ImuCtrl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ChairMode>* ChairModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ChairMode>* AsyncChairModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ChairMode>* PrepareAsyncChairModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ChairProfile>* ChairProfileStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ChairProfile>* AsyncChairProfileStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ChairProfile>* PrepareAsyncChairProfileStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::SpeedSetting>* SpeedSettingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::SpeedSetting>* AsyncSpeedSettingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::SpeedSetting>* PrepareAsyncSpeedSettingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::Joystick>* JoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::Joystick>* AsyncJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::Joystick>* PrepareAsyncJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::JoystickData>* VirtualJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* AsyncVirtualJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* PrepareAsyncVirtualJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::JoystickData>* PhysicalJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* AsyncPhysicalJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* PrepareAsyncPhysicalJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::JoystickData>* ScaledJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* AsyncScaledJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* PrepareAsyncScaledJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::JoystickData>* LuciJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* AsyncLuciJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::JoystickData>* PrepareAsyncLuciJoystickStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::AhrsData>* AhrsStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::AhrsData>* AsyncAhrsStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::AhrsData>* PrepareAsyncAhrsStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ClosestObstacles>* RadarClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* AsyncRadarClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* PrepareAsyncRadarClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ClosestObstacles>* UltrasonicClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* AsyncUltrasonicClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* PrepareAsyncUltrasonicClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ClosestObstacles>* CameraCollisionClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* AsyncCameraCollisionClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* PrepareAsyncCameraCollisionClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ClosestObstacles>* StepClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* AsyncStepClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* PrepareAsyncStepClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ClosestObstacles>* DropoffClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* AsyncDropoffClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ClosestObstacles>* PrepareAsyncDropoffClosestObstaclesStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::NavigationScaling>* ScalingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::NavigationScaling>* AsyncScalingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::NavigationScaling>* PrepareAsyncScalingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::BatteryVoltage>* BatteryVoltageStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::BatteryVoltage>* AsyncBatteryVoltageStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::BatteryVoltage>* PrepareAsyncBatteryVoltageStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::BatteryPercent>* BatteryPercentStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::BatteryPercent>* AsyncBatteryPercentStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::BatteryPercent>* PrepareAsyncBatteryPercentStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::CameraPoints>* CameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints>* AsyncCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints>* PrepareAsyncCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::CameraPoints2D>* FlatCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints2D>* AsyncFlatCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints2D>* PrepareAsyncFlatCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::CameraPoints>* DropoffCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints>* AsyncDropoffCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints>* PrepareAsyncDropoffCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ObjectDetection2D>* CaneCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ObjectDetection2D>* AsyncCaneCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ObjectDetection2D>* PrepareAsyncCaneCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::GPSData>* GPSStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::GPSData>* AsyncGPSStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::GPSData>* PrepareAsyncGPSStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::SeatPressure>* SeatPressureStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::SeatPressure>* AsyncSeatPressureStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::SeatPressure>* PrepareAsyncSeatPressureStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::DFParameters>* DFParametersChangedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::DFParameters>* AsyncDFParametersChangedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::DFParameters>* PrepareAsyncDFParametersChangedStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::DFSeatEvent>* DFEventStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::DFSeatEvent>* AsyncDFEventStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::DFSeatEvent>* PrepareAsyncDFEventStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncSendLoggingRaw(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncSendLoggingRaw(::grpc::ClientContext* context, const ::sensors::LoggingData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::LoggingData>* LoggingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::LoggingData>* AsyncLoggingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::LoggingData>* PrepareAsyncLoggingStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::CameraPoints>* StepCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints>* AsyncStepCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::CameraPoints>* PrepareAsyncStepCameraStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::IrFrame>* IrStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::IrFrame>* AsyncIrStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::IrFrame>* PrepareAsyncIrStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::RampAssistStates>* RampAssistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::RampAssistStates>* AsyncRampAssistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::RampAssistStates>* PrepareAsyncRampAssistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::DistanceData>* DistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::DistanceData>* AsyncDistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::DistanceData>* PrepareAsyncDistStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::StartModeData>* StartModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::StartModeData>* AsyncStartModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::StartModeData>* PrepareAsyncStartModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::AudioPlaybackRequest>* AudioPlaybackRequestStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::AudioPlaybackRequest>* AsyncAudioPlaybackRequestStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::AudioPlaybackRequest>* PrepareAsyncAudioPlaybackRequestStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::ZoneBoundaries>* AsyncGetZoneBoundariesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::ZoneBoundaries>* PrepareAsyncGetZoneBoundariesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::BlockedZones>* AsyncGetBlockedZonesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::BlockedZones>* PrepareAsyncGetBlockedZonesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::JoystickRanges>* AsyncGetJoystickRangesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::JoystickRanges>* PrepareAsyncGetJoystickRangesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncEnableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncEnableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* AsyncDisableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::Response>* PrepareAsyncDisableRadarFilterRaw(::grpc::ClientContext* context, const ::sensors::RadarFilter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::EncoderData>* EncoderStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::EncoderData>* AsyncEncoderStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::EncoderData>* PrepareAsyncEncoderStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::CalMatrix>* AsyncGetCalMatrixRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::CalMatrix>* PrepareAsyncGetCalMatrixRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::ReactionTestResult>* AsyncTestReactionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sensors::ReactionTestResult>* PrepareAsyncTestReactionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::LuciOverride>* LuciOverrideStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::LuciOverride>* AsyncLuciOverrideStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::LuciOverride>* PrepareAsyncLuciOverrideStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::sensors::LuciLandmark>* LuciLandmarkStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response) override;
    ::grpc::ClientAsyncWriter< ::sensors::LuciLandmark>* AsyncLuciLandmarkStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::sensors::LuciLandmark>* PrepareAsyncLuciLandmarkStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::sensors::RampInfo>* RampInfoStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response) override;
    ::grpc::ClientAsyncWriter< ::sensors::RampInfo>* AsyncRampInfoStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::sensors::RampInfo>* PrepareAsyncRampInfoStreamPassThroughRaw(::grpc::ClientContext* context, ::sensors::Response* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::LuciLandmark>* LuciLandmarkStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::LuciLandmark>* AsyncLuciLandmarkStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::LuciLandmark>* PrepareAsyncLuciLandmarkStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::RampInfo>* RampInfoStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::RampInfo>* AsyncRampInfoStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::RampInfo>* PrepareAsyncRampInfoStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sensors::ModeCtrl>* DriveModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::sensors::ModeCtrl>* AsyncDriveModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sensors::ModeCtrl>* PrepareAsyncDriveModeStreamRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_TurnOnLed_;
    const ::grpc::internal::RpcMethod rpcmethod_TurnOffLed_;
    const ::grpc::internal::RpcMethod rpcmethod_ActivateHmiState_;
    const ::grpc::internal::RpcMethod rpcmethod_DeactivateHmiState_;
    const ::grpc::internal::RpcMethod rpcmethod_SetNavigationScaling_;
    const ::grpc::internal::RpcMethod rpcmethod_TurnOnUltrasonic_;
    const ::grpc::internal::RpcMethod rpcmethod_TurnOffUltrasonic_;
    const ::grpc::internal::RpcMethod rpcmethod_TurnOnRadar_;
    const ::grpc::internal::RpcMethod rpcmethod_TurnOffRadar_;
    const ::grpc::internal::RpcMethod rpcmethod_CollectImuCalibration_;
    const ::grpc::internal::RpcMethod rpcmethod_DFGetCurrentParameters_;
    const ::grpc::internal::RpcMethod rpcmethod_DFGetBufferedEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableLuci_;
    const ::grpc::internal::RpcMethod rpcmethod_JsOverride_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDriveMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRampMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetLuciOverride_;
    const ::grpc::internal::RpcMethod rpcmethod_ExtPressCount_;
    const ::grpc::internal::RpcMethod rpcmethod_HmiStream_;
    const ::grpc::internal::RpcMethod rpcmethod_PressCountStream_;
    const ::grpc::internal::RpcMethod rpcmethod_UltrasonicStream_;
    const ::grpc::internal::RpcMethod rpcmethod_RawUltrasonicStream_;
    const ::grpc::internal::RpcMethod rpcmethod_RadarStream_;
    const ::grpc::internal::RpcMethod rpcmethod_RawRadarStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ChairSpeedStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ImuStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ChairModeStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ChairProfileStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SpeedSettingStream_;
    const ::grpc::internal::RpcMethod rpcmethod_JoystickStream_;
    const ::grpc::internal::RpcMethod rpcmethod_VirtualJoystickStream_;
    const ::grpc::internal::RpcMethod rpcmethod_PhysicalJoystickStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ScaledJoystickStream_;
    const ::grpc::internal::RpcMethod rpcmethod_LuciJoystickStream_;
    const ::grpc::internal::RpcMethod rpcmethod_AhrsStream_;
    const ::grpc::internal::RpcMethod rpcmethod_RadarClosestObstaclesStream_;
    const ::grpc::internal::RpcMethod rpcmethod_UltrasonicClosestObstaclesStream_;
    const ::grpc::internal::RpcMethod rpcmethod_CameraCollisionClosestObstaclesStream_;
    const ::grpc::internal::RpcMethod rpcmethod_StepClosestObstaclesStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DropoffClosestObstaclesStream_;
    const ::grpc::internal::RpcMethod rpcmethod_ScalingStream_;
    const ::grpc::internal::RpcMethod rpcmethod_BatteryVoltageStream_;
    const ::grpc::internal::RpcMethod rpcmethod_BatteryPercentStream_;
    const ::grpc::internal::RpcMethod rpcmethod_CameraStream_;
    const ::grpc::internal::RpcMethod rpcmethod_FlatCameraStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DropoffCameraStream_;
    const ::grpc::internal::RpcMethod rpcmethod_CaneCameraStream_;
    const ::grpc::internal::RpcMethod rpcmethod_GPSStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SeatPressureStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DFParametersChangedStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DFEventStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SendLogging_;
    const ::grpc::internal::RpcMethod rpcmethod_LoggingStream_;
    const ::grpc::internal::RpcMethod rpcmethod_StepCameraStream_;
    const ::grpc::internal::RpcMethod rpcmethod_IrStream_;
    const ::grpc::internal::RpcMethod rpcmethod_RampAssistStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DistStream_;
    const ::grpc::internal::RpcMethod rpcmethod_StartModeStream_;
    const ::grpc::internal::RpcMethod rpcmethod_AudioPlaybackRequestStream_;
    const ::grpc::internal::RpcMethod rpcmethod_GetZoneBoundaries_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockedZones_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJoystickRanges_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableRadarFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableRadarFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_EncoderStream_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCalMatrix_;
    const ::grpc::internal::RpcMethod rpcmethod_TestReaction_;
    const ::grpc::internal::RpcMethod rpcmethod_LuciOverrideStream_;
    const ::grpc::internal::RpcMethod rpcmethod_LuciLandmarkStreamPassThrough_;
    const ::grpc::internal::RpcMethod rpcmethod_RampInfoStreamPassThrough_;
    const ::grpc::internal::RpcMethod rpcmethod_LuciLandmarkStream_;
    const ::grpc::internal::RpcMethod rpcmethod_RampInfoStream_;
    const ::grpc::internal::RpcMethod rpcmethod_DriveModeStream_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status TurnOnLed(::grpc::ServerContext* context, const ::sensors::Led* request, ::sensors::Response* response);
    virtual ::grpc::Status TurnOffLed(::grpc::ServerContext* context, const ::sensors::Led* request, ::sensors::Response* response);
    virtual ::grpc::Status ActivateHmiState(::grpc::ServerContext* context, const ::sensors::HmiState* request, ::sensors::Response* response);
    virtual ::grpc::Status DeactivateHmiState(::grpc::ServerContext* context, const ::sensors::HmiState* request, ::sensors::Response* response);
    virtual ::grpc::Status SetNavigationScaling(::grpc::ServerContext* context, const ::sensors::NavigationScaling* request, ::sensors::Response* response);
    virtual ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response);
    virtual ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response);
    virtual ::grpc::Status TurnOnRadar(::grpc::ServerContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response);
    virtual ::grpc::Status TurnOffRadar(::grpc::ServerContext* context, const ::sensors::RadarCtrl* request, ::sensors::Response* response);
    virtual ::grpc::Status CollectImuCalibration(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response);
    virtual ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response);
    virtual ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response);
    virtual ::grpc::Status DisableLuci(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::Response* response);
    virtual ::grpc::Status JsOverride(::grpc::ServerContext* context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response);
    virtual ::grpc::Status SetDriveMode(::grpc::ServerContext* context, const ::sensors::ModeCtrl* request, ::sensors::Response* response);
    virtual ::grpc::Status SetRampMode(::grpc::ServerContext* context, const ::sensors::RampMode* request, ::sensors::Response* response);
    virtual ::grpc::Status SetLuciOverride(::grpc::ServerContext* context, const ::sensors::LuciOverride* request, ::sensors::Response* response);
    virtual ::grpc::Status ExtPressCount(::grpc::ServerContext* context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response);
    virtual ::grpc::Status HmiStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::HmiStreamData>* writer);
    virtual ::grpc::Status PressCountStream(::grpc::ServerContext* context, const ::sensors::PressRequest* request, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* writer);
    virtual ::grpc::Status UltrasonicStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* writer);
    virtual ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* writer);
    virtual ::grpc::Status RadarStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::RadarPoints>* writer);
    virtual ::grpc::Status RawRadarStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::RadarPoints>* writer);
    virtual ::grpc::Status ChairSpeedStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ChairSpeed>* writer);
    virtual ::grpc::Status ImuStream(::grpc::ServerContext* context, const ::sensors::ImuCtrl* request, ::grpc::ServerWriter< ::sensors::ImuData>* writer);
    virtual ::grpc::Status ChairModeStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ChairMode>* writer);
    virtual ::grpc::Status ChairProfileStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ChairProfile>* writer);
    virtual ::grpc::Status SpeedSettingStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::SpeedSetting>* writer);
    virtual ::grpc::Status JoystickStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::Joystick>* writer);
    virtual ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::JoystickData>* writer);
    virtual ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::JoystickData>* writer);
    virtual ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::JoystickData>* writer);
    virtual ::grpc::Status LuciJoystickStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::JoystickData>* writer);
    virtual ::grpc::Status AhrsStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::AhrsData>* writer);
    virtual ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* writer);
    virtual ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* writer);
    virtual ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* writer);
    virtual ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* writer);
    virtual ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* writer);
    virtual ::grpc::Status ScalingStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::NavigationScaling>* writer);
    virtual ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* writer);
    virtual ::grpc::Status BatteryPercentStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::BatteryPercent>* writer);
    virtual ::grpc::Status CameraStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::CameraPoints>* writer);
    virtual ::grpc::Status FlatCameraStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* writer);
    virtual ::grpc::Status DropoffCameraStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::CameraPoints>* writer);
    virtual ::grpc::Status CaneCameraStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* writer);
    virtual ::grpc::Status GPSStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::GPSData>* writer);
    virtual ::grpc::Status SeatPressureStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::SeatPressure>* writer);
    virtual ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::DFParameters>* writer);
    virtual ::grpc::Status DFEventStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* writer);
    virtual ::grpc::Status SendLogging(::grpc::ServerContext* context, const ::sensors::LoggingData* request, ::sensors::Response* response);
    virtual ::grpc::Status LoggingStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::LoggingData>* writer);
    virtual ::grpc::Status StepCameraStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::CameraPoints>* writer);
    virtual ::grpc::Status IrStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::IrFrame>* writer);
    virtual ::grpc::Status RampAssistStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::RampAssistStates>* writer);
    virtual ::grpc::Status DistStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::DistanceData>* writer);
    virtual ::grpc::Status StartModeStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::StartModeData>* writer);
    virtual ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* writer);
    virtual ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response);
    virtual ::grpc::Status GetBlockedZones(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response);
    virtual ::grpc::Status GetJoystickRanges(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response);
    virtual ::grpc::Status EnableRadarFilter(::grpc::ServerContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response);
    virtual ::grpc::Status DisableRadarFilter(::grpc::ServerContext* context, const ::sensors::RadarFilter* request, ::sensors::Response* response);
    virtual ::grpc::Status EncoderStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::EncoderData>* writer);
    virtual ::grpc::Status GetCalMatrix(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response);
    virtual ::grpc::Status TestReaction(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response);
    virtual ::grpc::Status LuciOverrideStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::LuciOverride>* writer);
    virtual ::grpc::Status LuciLandmarkStreamPassThrough(::grpc::ServerContext* context, ::grpc::ServerReader< ::sensors::LuciLandmark>* reader, ::sensors::Response* response);
    virtual ::grpc::Status RampInfoStreamPassThrough(::grpc::ServerContext* context, ::grpc::ServerReader< ::sensors::RampInfo>* reader, ::sensors::Response* response);
    virtual ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::LuciLandmark>* writer);
    virtual ::grpc::Status RampInfoStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::RampInfo>* writer);
    virtual ::grpc::Status DriveModeStream(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::sensors::ModeCtrl>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_TurnOnLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TurnOnLed() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_TurnOnLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOnLed(::grpc::ServerContext* context, ::sensors::Led* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TurnOffLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TurnOffLed() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_TurnOffLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOffLed(::grpc::ServerContext* context, ::sensors::Led* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ActivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ActivateHmiState() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ActivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActivateHmiState(::grpc::ServerContext* context, ::sensors::HmiState* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeactivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeactivateHmiState() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeactivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeactivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeactivateHmiState(::grpc::ServerContext* context, ::sensors::HmiState* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetNavigationScaling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetNavigationScaling() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetNavigationScaling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNavigationScaling(::grpc::ServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetNavigationScaling(::grpc::ServerContext* context, ::sensors::NavigationScaling* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TurnOnUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TurnOnUltrasonic() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_TurnOnUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOnUltrasonic(::grpc::ServerContext* context, ::sensors::UltrasonicCtrl* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TurnOffUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TurnOffUltrasonic() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_TurnOffUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOffUltrasonic(::grpc::ServerContext* context, ::sensors::UltrasonicCtrl* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TurnOnRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TurnOnRadar() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_TurnOnRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOnRadar(::grpc::ServerContext* context, ::sensors::RadarCtrl* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TurnOffRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TurnOffRadar() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_TurnOffRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOffRadar(::grpc::ServerContext* context, ::sensors::RadarCtrl* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CollectImuCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CollectImuCalibration() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_CollectImuCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CollectImuCalibration(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCollectImuCalibration(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DFGetCurrentParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DFGetCurrentParameters() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_DFGetCurrentParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFGetCurrentParameters(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DFGetBufferedEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DFGetBufferedEvents() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_DFGetBufferedEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFGetBufferedEvents(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableLuci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableLuci() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_DisableLuci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableLuci(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableLuci(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JsOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JsOverride() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_JsOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JsOverride(::grpc::ServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJsOverride(::grpc::ServerContext* context, ::sensors::RemoteJsValues* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDriveMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDriveMode() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SetDriveMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveMode(::grpc::ServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDriveMode(::grpc::ServerContext* context, ::sensors::ModeCtrl* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRampMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRampMode() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SetRampMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRampMode(::grpc::ServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRampMode(::grpc::ServerContext* context, ::sensors::RampMode* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetLuciOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetLuciOverride() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SetLuciOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLuciOverride(::grpc::ServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLuciOverride(::grpc::ServerContext* context, ::sensors::LuciOverride* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExtPressCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExtPressCount() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ExtPressCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExtPressCount(::grpc::ServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExtPressCount(::grpc::ServerContext* context, ::sensors::PressCountStreamData* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HmiStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HmiStream() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_HmiStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HmiStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::HmiStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHmiStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::HmiStreamData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(18, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PressCountStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PressCountStream() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_PressCountStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PressCountStream(::grpc::ServerContext* /*context*/, const ::sensors::PressRequest* /*request*/, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPressCountStream(::grpc::ServerContext* context, ::sensors::PressRequest* request, ::grpc::ServerAsyncWriter< ::sensors::PressCountStreamData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(19, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UltrasonicStream() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_UltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUltrasonicStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::UltrasonicDistances>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(20, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RawUltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RawUltrasonicStream() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_RawUltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawUltrasonicStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::UltrasonicCurve>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(21, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RadarStream() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_RadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRadarStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::RadarPoints>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RawRadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RawRadarStream() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_RawRadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawRadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawRadarStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::RadarPoints>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(23, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChairSpeedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChairSpeedStream() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ChairSpeedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairSpeedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairSpeed>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChairSpeedStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ChairSpeed>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImuStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImuStream() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_ImuStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImuStream(::grpc::ServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/, ::grpc::ServerWriter< ::sensors::ImuData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImuStream(::grpc::ServerContext* context, ::sensors::ImuCtrl* request, ::grpc::ServerAsyncWriter< ::sensors::ImuData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChairModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChairModeStream() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_ChairModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairMode>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChairModeStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ChairMode>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(26, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChairProfileStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChairProfileStream() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_ChairProfileStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairProfileStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairProfile>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChairProfileStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ChairProfile>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(27, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpeedSettingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpeedSettingStream() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_SpeedSettingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeedSettingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SpeedSetting>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpeedSettingStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::SpeedSetting>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(28, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JoystickStream() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_JoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::Joystick>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoystickStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::Joystick>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(29, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VirtualJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VirtualJoystickStream() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_VirtualJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVirtualJoystickStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::JoystickData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(30, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PhysicalJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PhysicalJoystickStream() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_PhysicalJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPhysicalJoystickStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::JoystickData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(31, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ScaledJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ScaledJoystickStream() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_ScaledJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScaledJoystickStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::JoystickData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(32, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LuciJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LuciJoystickStream() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_LuciJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciJoystickStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::JoystickData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(33, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AhrsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AhrsStream() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_AhrsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AhrsStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AhrsData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAhrsStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::AhrsData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(34, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RadarClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RadarClosestObstaclesStream() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_RadarClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRadarClosestObstaclesStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ClosestObstacles>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(35, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UltrasonicClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UltrasonicClosestObstaclesStream() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_UltrasonicClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUltrasonicClosestObstaclesStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ClosestObstacles>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(36, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CameraCollisionClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CameraCollisionClosestObstaclesStream() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_CameraCollisionClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCameraCollisionClosestObstaclesStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ClosestObstacles>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(37, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StepClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StepClosestObstaclesStream() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_StepClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStepClosestObstaclesStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ClosestObstacles>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(38, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DropoffClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DropoffClosestObstaclesStream() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_DropoffClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDropoffClosestObstaclesStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ClosestObstacles>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(39, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ScalingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ScalingStream() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_ScalingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScalingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::NavigationScaling>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScalingStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::NavigationScaling>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(40, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatteryVoltageStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatteryVoltageStream() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_BatteryVoltageStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatteryVoltageStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::BatteryVoltage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(41, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatteryPercentStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatteryPercentStream() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_BatteryPercentStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryPercentStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryPercent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatteryPercentStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::BatteryPercent>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(42, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CameraStream() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_CameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCameraStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::CameraPoints>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(43, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FlatCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FlatCameraStream() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_FlatCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlatCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFlatCameraStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::CameraPoints2D>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(44, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DropoffCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DropoffCameraStream() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_DropoffCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDropoffCameraStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::CameraPoints>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CaneCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CaneCameraStream() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_CaneCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaneCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCaneCameraStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ObjectDetection2D>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(46, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GPSStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GPSStream() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_GPSStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GPSStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::GPSData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGPSStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::GPSData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(47, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SeatPressureStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SeatPressureStream() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_SeatPressureStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SeatPressureStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SeatPressure>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSeatPressureStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::SeatPressure>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(48, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DFParametersChangedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DFParametersChangedStream() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_DFParametersChangedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFParameters>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFParametersChangedStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::DFParameters>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(49, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DFEventStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DFEventStream() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_DFEventStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFEventStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFEventStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::DFSeatEvent>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(50, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendLogging() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_SendLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendLogging(::grpc::ServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendLogging(::grpc::ServerContext* context, ::sensors::LoggingData* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoggingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoggingStream() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_LoggingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoggingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LoggingData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoggingStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::LoggingData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(52, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StepCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StepCameraStream() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_StepCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStepCameraStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::CameraPoints>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(53, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IrStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IrStream() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_IrStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IrStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::IrFrame>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIrStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::IrFrame>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(54, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RampAssistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RampAssistStream() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_RampAssistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampAssistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampAssistStates>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRampAssistStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::RampAssistStates>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(55, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DistStream() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_DistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DistanceData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDistStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::DistanceData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(56, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartModeStream() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_StartModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::StartModeData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartModeStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::StartModeData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(57, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AudioPlaybackRequestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AudioPlaybackRequestStream() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_AudioPlaybackRequestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAudioPlaybackRequestStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::AudioPlaybackRequest>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(58, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetZoneBoundaries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetZoneBoundaries() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_GetZoneBoundaries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetZoneBoundaries(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::ZoneBoundaries>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockedZones : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockedZones() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_GetBlockedZones() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockedZones(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockedZones(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::BlockedZones>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJoystickRanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJoystickRanges() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_GetJoystickRanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJoystickRanges(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJoystickRanges(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::JoystickRanges>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableRadarFilter() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_EnableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableRadarFilter(::grpc::ServerContext* context, ::sensors::RadarFilter* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableRadarFilter() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_DisableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableRadarFilter(::grpc::ServerContext* context, ::sensors::RadarFilter* request, ::grpc::ServerAsyncResponseWriter< ::sensors::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EncoderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EncoderStream() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_EncoderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EncoderStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::EncoderData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEncoderStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::EncoderData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(64, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCalMatrix : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCalMatrix() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_GetCalMatrix() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCalMatrix(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCalMatrix(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::CalMatrix>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TestReaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TestReaction() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_TestReaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestReaction(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestReaction(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sensors::ReactionTestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LuciOverrideStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LuciOverrideStream() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_LuciOverrideStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciOverrideStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciOverride>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciOverrideStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::LuciOverride>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(67, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LuciLandmarkStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LuciLandmarkStreamPassThrough() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_LuciLandmarkStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::LuciLandmark>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciLandmarkStreamPassThrough(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::sensors::Response, ::sensors::LuciLandmark>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(68, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RampInfoStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RampInfoStreamPassThrough() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_RampInfoStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::RampInfo>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRampInfoStreamPassThrough(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::sensors::Response, ::sensors::RampInfo>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(69, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LuciLandmarkStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LuciLandmarkStream() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_LuciLandmarkStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciLandmark>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciLandmarkStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::LuciLandmark>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(70, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RampInfoStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RampInfoStream() {
      ::grpc::Service::MarkMethodAsync(71);
    }
    ~WithAsyncMethod_RampInfoStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRampInfoStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::RampInfo>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(71, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DriveModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DriveModeStream() {
      ::grpc::Service::MarkMethodAsync(72);
    }
    ~WithAsyncMethod_DriveModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ModeCtrl>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDriveModeStream(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::sensors::ModeCtrl>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(72, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_TurnOnLed<WithAsyncMethod_TurnOffLed<WithAsyncMethod_ActivateHmiState<WithAsyncMethod_DeactivateHmiState<WithAsyncMethod_SetNavigationScaling<WithAsyncMethod_TurnOnUltrasonic<WithAsyncMethod_TurnOffUltrasonic<WithAsyncMethod_TurnOnRadar<WithAsyncMethod_TurnOffRadar<WithAsyncMethod_CollectImuCalibration<WithAsyncMethod_DFGetCurrentParameters<WithAsyncMethod_DFGetBufferedEvents<WithAsyncMethod_DisableLuci<WithAsyncMethod_JsOverride<WithAsyncMethod_SetDriveMode<WithAsyncMethod_SetRampMode<WithAsyncMethod_SetLuciOverride<WithAsyncMethod_ExtPressCount<WithAsyncMethod_HmiStream<WithAsyncMethod_PressCountStream<WithAsyncMethod_UltrasonicStream<WithAsyncMethod_RawUltrasonicStream<WithAsyncMethod_RadarStream<WithAsyncMethod_RawRadarStream<WithAsyncMethod_ChairSpeedStream<WithAsyncMethod_ImuStream<WithAsyncMethod_ChairModeStream<WithAsyncMethod_ChairProfileStream<WithAsyncMethod_SpeedSettingStream<WithAsyncMethod_JoystickStream<WithAsyncMethod_VirtualJoystickStream<WithAsyncMethod_PhysicalJoystickStream<WithAsyncMethod_ScaledJoystickStream<WithAsyncMethod_LuciJoystickStream<WithAsyncMethod_AhrsStream<WithAsyncMethod_RadarClosestObstaclesStream<WithAsyncMethod_UltrasonicClosestObstaclesStream<WithAsyncMethod_CameraCollisionClosestObstaclesStream<WithAsyncMethod_StepClosestObstaclesStream<WithAsyncMethod_DropoffClosestObstaclesStream<WithAsyncMethod_ScalingStream<WithAsyncMethod_BatteryVoltageStream<WithAsyncMethod_BatteryPercentStream<WithAsyncMethod_CameraStream<WithAsyncMethod_FlatCameraStream<WithAsyncMethod_DropoffCameraStream<WithAsyncMethod_CaneCameraStream<WithAsyncMethod_GPSStream<WithAsyncMethod_SeatPressureStream<WithAsyncMethod_DFParametersChangedStream<WithAsyncMethod_DFEventStream<WithAsyncMethod_SendLogging<WithAsyncMethod_LoggingStream<WithAsyncMethod_StepCameraStream<WithAsyncMethod_IrStream<WithAsyncMethod_RampAssistStream<WithAsyncMethod_DistStream<WithAsyncMethod_StartModeStream<WithAsyncMethod_AudioPlaybackRequestStream<WithAsyncMethod_GetZoneBoundaries<WithAsyncMethod_GetBlockedZones<WithAsyncMethod_GetJoystickRanges<WithAsyncMethod_EnableRadarFilter<WithAsyncMethod_DisableRadarFilter<WithAsyncMethod_EncoderStream<WithAsyncMethod_GetCalMatrix<WithAsyncMethod_TestReaction<WithAsyncMethod_LuciOverrideStream<WithAsyncMethod_LuciLandmarkStreamPassThrough<WithAsyncMethod_RampInfoStreamPassThrough<WithAsyncMethod_LuciLandmarkStream<WithAsyncMethod_RampInfoStream<WithAsyncMethod_DriveModeStream<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TurnOnLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TurnOnLed() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::Led, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::Led* request, ::sensors::Response* response) { return this->TurnOnLed(context, request, response); }));}
    void SetMessageAllocatorFor_TurnOnLed(
        ::grpc::experimental::MessageAllocator< ::sensors::Led, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::Led, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TurnOnLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOnLed(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOnLed(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TurnOffLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TurnOffLed() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::Led, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::Led* request, ::sensors::Response* response) { return this->TurnOffLed(context, request, response); }));}
    void SetMessageAllocatorFor_TurnOffLed(
        ::grpc::experimental::MessageAllocator< ::sensors::Led, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::Led, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TurnOffLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOffLed(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOffLed(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ActivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ActivateHmiState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::HmiState, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::HmiState* request, ::sensors::Response* response) { return this->ActivateHmiState(context, request, response); }));}
    void SetMessageAllocatorFor_ActivateHmiState(
        ::grpc::experimental::MessageAllocator< ::sensors::HmiState, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::HmiState, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ActivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ActivateHmiState(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ActivateHmiState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeactivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeactivateHmiState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::HmiState, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::HmiState* request, ::sensors::Response* response) { return this->DeactivateHmiState(context, request, response); }));}
    void SetMessageAllocatorFor_DeactivateHmiState(
        ::grpc::experimental::MessageAllocator< ::sensors::HmiState, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::HmiState, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeactivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeactivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeactivateHmiState(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeactivateHmiState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetNavigationScaling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetNavigationScaling() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::NavigationScaling, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::NavigationScaling* request, ::sensors::Response* response) { return this->SetNavigationScaling(context, request, response); }));}
    void SetMessageAllocatorFor_SetNavigationScaling(
        ::grpc::experimental::MessageAllocator< ::sensors::NavigationScaling, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::NavigationScaling, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetNavigationScaling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNavigationScaling(::grpc::ServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetNavigationScaling(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetNavigationScaling(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TurnOnUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TurnOnUltrasonic() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::UltrasonicCtrl, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response) { return this->TurnOnUltrasonic(context, request, response); }));}
    void SetMessageAllocatorFor_TurnOnUltrasonic(
        ::grpc::experimental::MessageAllocator< ::sensors::UltrasonicCtrl, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::UltrasonicCtrl, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TurnOnUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOnUltrasonic(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOnUltrasonic(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TurnOffUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TurnOffUltrasonic() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::UltrasonicCtrl, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::UltrasonicCtrl* request, ::sensors::Response* response) { return this->TurnOffUltrasonic(context, request, response); }));}
    void SetMessageAllocatorFor_TurnOffUltrasonic(
        ::grpc::experimental::MessageAllocator< ::sensors::UltrasonicCtrl, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::UltrasonicCtrl, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TurnOffUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOffUltrasonic(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOffUltrasonic(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TurnOnRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TurnOnRadar() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::RadarCtrl, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::RadarCtrl* request, ::sensors::Response* response) { return this->TurnOnRadar(context, request, response); }));}
    void SetMessageAllocatorFor_TurnOnRadar(
        ::grpc::experimental::MessageAllocator< ::sensors::RadarCtrl, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::RadarCtrl, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TurnOnRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOnRadar(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOnRadar(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TurnOffRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TurnOffRadar() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::RadarCtrl, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::RadarCtrl* request, ::sensors::Response* response) { return this->TurnOffRadar(context, request, response); }));}
    void SetMessageAllocatorFor_TurnOffRadar(
        ::grpc::experimental::MessageAllocator< ::sensors::RadarCtrl, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::RadarCtrl, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TurnOffRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOffRadar(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOffRadar(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CollectImuCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CollectImuCalibration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::Response* response) { return this->CollectImuCalibration(context, request, response); }));}
    void SetMessageAllocatorFor_CollectImuCalibration(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CollectImuCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CollectImuCalibration(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CollectImuCalibration(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CollectImuCalibration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DFGetCurrentParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DFGetCurrentParameters() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::Response* response) { return this->DFGetCurrentParameters(context, request, response); }));}
    void SetMessageAllocatorFor_DFGetCurrentParameters(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DFGetCurrentParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DFGetCurrentParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DFGetCurrentParameters(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DFGetBufferedEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DFGetBufferedEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::Response* response) { return this->DFGetBufferedEvents(context, request, response); }));}
    void SetMessageAllocatorFor_DFGetBufferedEvents(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DFGetBufferedEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DFGetBufferedEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DFGetBufferedEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DisableLuci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DisableLuci() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::Response* response) { return this->DisableLuci(context, request, response); }));}
    void SetMessageAllocatorFor_DisableLuci(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DisableLuci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableLuci(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DisableLuci(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DisableLuci(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_JsOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_JsOverride() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::RemoteJsValues, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::RemoteJsValues* request, ::sensors::Response* response) { return this->JsOverride(context, request, response); }));}
    void SetMessageAllocatorFor_JsOverride(
        ::grpc::experimental::MessageAllocator< ::sensors::RemoteJsValues, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::RemoteJsValues, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_JsOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JsOverride(::grpc::ServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JsOverride(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JsOverride(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetDriveMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetDriveMode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::ModeCtrl, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::ModeCtrl* request, ::sensors::Response* response) { return this->SetDriveMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetDriveMode(
        ::grpc::experimental::MessageAllocator< ::sensors::ModeCtrl, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::ModeCtrl, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetDriveMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveMode(::grpc::ServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetDriveMode(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetDriveMode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRampMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRampMode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::RampMode, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::RampMode* request, ::sensors::Response* response) { return this->SetRampMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetRampMode(
        ::grpc::experimental::MessageAllocator< ::sensors::RampMode, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::RampMode, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRampMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRampMode(::grpc::ServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetRampMode(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetRampMode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetLuciOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetLuciOverride() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::LuciOverride, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::LuciOverride* request, ::sensors::Response* response) { return this->SetLuciOverride(context, request, response); }));}
    void SetMessageAllocatorFor_SetLuciOverride(
        ::grpc::experimental::MessageAllocator< ::sensors::LuciOverride, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::LuciOverride, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetLuciOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLuciOverride(::grpc::ServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetLuciOverride(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetLuciOverride(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExtPressCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExtPressCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::PressCountStreamData, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::PressCountStreamData* request, ::sensors::Response* response) { return this->ExtPressCount(context, request, response); }));}
    void SetMessageAllocatorFor_ExtPressCount(
        ::grpc::experimental::MessageAllocator< ::sensors::PressCountStreamData, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::PressCountStreamData, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExtPressCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExtPressCount(::grpc::ServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExtPressCount(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExtPressCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HmiStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_HmiStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::HmiStreamData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->HmiStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_HmiStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HmiStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::HmiStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::HmiStreamData>* HmiStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::HmiStreamData>* HmiStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PressCountStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PressCountStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackServerStreamingHandler< ::sensors::PressRequest, ::sensors::PressCountStreamData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::PressRequest* request) { return this->PressCountStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_PressCountStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PressCountStream(::grpc::ServerContext* /*context*/, const ::sensors::PressRequest* /*request*/, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::PressCountStreamData>* PressCountStream(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::PressRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::PressCountStreamData>* PressCountStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::PressRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UltrasonicStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::UltrasonicDistances>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->UltrasonicStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_UltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::UltrasonicDistances>* UltrasonicStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::UltrasonicDistances>* UltrasonicStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RawUltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RawUltrasonicStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::UltrasonicCurve>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->RawUltrasonicStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RawUltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::UltrasonicCurve>* RawUltrasonicStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::UltrasonicCurve>* RawUltrasonicStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RadarStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::RadarPoints>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->RadarStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::RadarPoints>* RadarStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::RadarPoints>* RadarStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RawRadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RawRadarStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::RadarPoints>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->RawRadarStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RawRadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawRadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::RadarPoints>* RawRadarStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::RadarPoints>* RawRadarStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChairSpeedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChairSpeedStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ChairSpeed>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->ChairSpeedStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ChairSpeedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairSpeedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairSpeed>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ChairSpeed>* ChairSpeedStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ChairSpeed>* ChairSpeedStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImuStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImuStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackServerStreamingHandler< ::sensors::ImuCtrl, ::sensors::ImuData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::ImuCtrl* request) { return this->ImuStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ImuStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImuStream(::grpc::ServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/, ::grpc::ServerWriter< ::sensors::ImuData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ImuData>* ImuStream(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ImuData>* ImuStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChairModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChairModeStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ChairMode>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->ChairModeStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ChairModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairMode>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ChairMode>* ChairModeStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ChairMode>* ChairModeStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChairProfileStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChairProfileStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ChairProfile>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->ChairProfileStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ChairProfileStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairProfileStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairProfile>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ChairProfile>* ChairProfileStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ChairProfile>* ChairProfileStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SpeedSettingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SpeedSettingStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::SpeedSetting>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->SpeedSettingStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SpeedSettingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeedSettingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SpeedSetting>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::SpeedSetting>* SpeedSettingStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::SpeedSetting>* SpeedSettingStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_JoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_JoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::Joystick>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->JoystickStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_JoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::Joystick>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::Joystick>* JoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::Joystick>* JoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VirtualJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VirtualJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->VirtualJoystickStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_VirtualJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::JoystickData>* VirtualJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::JoystickData>* VirtualJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PhysicalJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PhysicalJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->PhysicalJoystickStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_PhysicalJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::JoystickData>* PhysicalJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::JoystickData>* PhysicalJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ScaledJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ScaledJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->ScaledJoystickStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ScaledJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::JoystickData>* ScaledJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::JoystickData>* ScaledJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LuciJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LuciJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->LuciJoystickStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_LuciJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::JoystickData>* LuciJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::JoystickData>* LuciJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AhrsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AhrsStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::AhrsData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->AhrsStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_AhrsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AhrsStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AhrsData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::AhrsData>* AhrsStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::AhrsData>* AhrsStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RadarClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RadarClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->RadarClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RadarClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ClosestObstacles>* RadarClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ClosestObstacles>* RadarClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UltrasonicClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UltrasonicClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->UltrasonicClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_UltrasonicClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ClosestObstacles>* UltrasonicClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ClosestObstacles>* UltrasonicClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CameraCollisionClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CameraCollisionClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->CameraCollisionClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_CameraCollisionClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ClosestObstacles>* CameraCollisionClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ClosestObstacles>* CameraCollisionClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StepClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StepClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->StepClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_StepClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ClosestObstacles>* StepClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ClosestObstacles>* StepClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DropoffClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DropoffClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->DropoffClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_DropoffClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ClosestObstacles>* DropoffClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ClosestObstacles>* DropoffClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ScalingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ScalingStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::NavigationScaling>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->ScalingStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ScalingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScalingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::NavigationScaling>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::NavigationScaling>* ScalingStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::NavigationScaling>* ScalingStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BatteryVoltageStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BatteryVoltageStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::BatteryVoltage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->BatteryVoltageStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_BatteryVoltageStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::BatteryVoltage>* BatteryVoltageStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::BatteryVoltage>* BatteryVoltageStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BatteryPercentStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BatteryPercentStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::BatteryPercent>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->BatteryPercentStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_BatteryPercentStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryPercentStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryPercent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::BatteryPercent>* BatteryPercentStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::BatteryPercent>* BatteryPercentStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::CameraPoints>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->CameraStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_CameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::CameraPoints>* CameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::CameraPoints>* CameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FlatCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FlatCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::CameraPoints2D>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->FlatCameraStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_FlatCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlatCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::CameraPoints2D>* FlatCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::CameraPoints2D>* FlatCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DropoffCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DropoffCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::CameraPoints>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->DropoffCameraStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_DropoffCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::CameraPoints>* DropoffCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::CameraPoints>* DropoffCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CaneCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CaneCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ObjectDetection2D>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->CaneCameraStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_CaneCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaneCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ObjectDetection2D>* CaneCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ObjectDetection2D>* CaneCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GPSStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GPSStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::GPSData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->GPSStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GPSStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GPSStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::GPSData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::GPSData>* GPSStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::GPSData>* GPSStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SeatPressureStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SeatPressureStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::SeatPressure>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->SeatPressureStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SeatPressureStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SeatPressureStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SeatPressure>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::SeatPressure>* SeatPressureStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::SeatPressure>* SeatPressureStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DFParametersChangedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DFParametersChangedStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(49,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::DFParameters>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->DFParametersChangedStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_DFParametersChangedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFParameters>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::DFParameters>* DFParametersChangedStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::DFParameters>* DFParametersChangedStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DFEventStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DFEventStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(50,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::DFSeatEvent>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->DFEventStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_DFEventStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFEventStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::DFSeatEvent>* DFEventStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::DFSeatEvent>* DFEventStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendLogging() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::LoggingData, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::LoggingData* request, ::sensors::Response* response) { return this->SendLogging(context, request, response); }));}
    void SetMessageAllocatorFor_SendLogging(
        ::grpc::experimental::MessageAllocator< ::sensors::LoggingData, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(51);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::LoggingData, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendLogging(::grpc::ServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendLogging(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendLogging(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LoggingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LoggingStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(52,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::LoggingData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->LoggingStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_LoggingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoggingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LoggingData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::LoggingData>* LoggingStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::LoggingData>* LoggingStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StepCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StepCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(53,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::CameraPoints>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->StepCameraStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_StepCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::CameraPoints>* StepCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::CameraPoints>* StepCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IrStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IrStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(54,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::IrFrame>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->IrStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_IrStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IrStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::IrFrame>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::IrFrame>* IrStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::IrFrame>* IrStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RampAssistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RampAssistStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(55,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::RampAssistStates>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->RampAssistStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RampAssistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampAssistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampAssistStates>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::RampAssistStates>* RampAssistStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::RampAssistStates>* RampAssistStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DistStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(56,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::DistanceData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->DistStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_DistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DistanceData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::DistanceData>* DistStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::DistanceData>* DistStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartModeStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(57,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::StartModeData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->StartModeStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_StartModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::StartModeData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::StartModeData>* StartModeStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::StartModeData>* StartModeStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AudioPlaybackRequestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AudioPlaybackRequestStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(58,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::AudioPlaybackRequest>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->AudioPlaybackRequestStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_AudioPlaybackRequestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::AudioPlaybackRequest>* AudioPlaybackRequestStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::AudioPlaybackRequest>* AudioPlaybackRequestStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetZoneBoundaries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetZoneBoundaries() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::ZoneBoundaries>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::ZoneBoundaries* response) { return this->GetZoneBoundaries(context, request, response); }));}
    void SetMessageAllocatorFor_GetZoneBoundaries(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::ZoneBoundaries>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(59);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::ZoneBoundaries>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetZoneBoundaries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetZoneBoundaries(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetZoneBoundaries(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockedZones : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockedZones() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::BlockedZones>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::BlockedZones* response) { return this->GetBlockedZones(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockedZones(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::BlockedZones>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(60);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::BlockedZones>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockedZones() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockedZones(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockedZones(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockedZones(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetJoystickRanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetJoystickRanges() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::JoystickRanges>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::JoystickRanges* response) { return this->GetJoystickRanges(context, request, response); }));}
    void SetMessageAllocatorFor_GetJoystickRanges(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::JoystickRanges>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(61);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::JoystickRanges>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetJoystickRanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJoystickRanges(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetJoystickRanges(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetJoystickRanges(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EnableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EnableRadarFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::RadarFilter, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::RadarFilter* request, ::sensors::Response* response) { return this->EnableRadarFilter(context, request, response); }));}
    void SetMessageAllocatorFor_EnableRadarFilter(
        ::grpc::experimental::MessageAllocator< ::sensors::RadarFilter, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(62);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::RadarFilter, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EnableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EnableRadarFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EnableRadarFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DisableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DisableRadarFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::sensors::RadarFilter, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sensors::RadarFilter* request, ::sensors::Response* response) { return this->DisableRadarFilter(context, request, response); }));}
    void SetMessageAllocatorFor_DisableRadarFilter(
        ::grpc::experimental::MessageAllocator< ::sensors::RadarFilter, ::sensors::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(63);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sensors::RadarFilter, ::sensors::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DisableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DisableRadarFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DisableRadarFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EncoderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EncoderStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(64,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::EncoderData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->EncoderStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_EncoderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EncoderStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::EncoderData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::EncoderData>* EncoderStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::EncoderData>* EncoderStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCalMatrix : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCalMatrix() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::CalMatrix>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::CalMatrix* response) { return this->GetCalMatrix(context, request, response); }));}
    void SetMessageAllocatorFor_GetCalMatrix(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::CalMatrix>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(65);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::CalMatrix>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCalMatrix() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCalMatrix(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCalMatrix(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCalMatrix(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TestReaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TestReaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::ReactionTestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sensors::ReactionTestResult* response) { return this->TestReaction(context, request, response); }));}
    void SetMessageAllocatorFor_TestReaction(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sensors::ReactionTestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(66);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sensors::ReactionTestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TestReaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestReaction(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TestReaction(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TestReaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LuciOverrideStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LuciOverrideStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(67,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::LuciOverride>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->LuciOverrideStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_LuciOverrideStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciOverrideStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciOverride>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::LuciOverride>* LuciOverrideStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::LuciOverride>* LuciOverrideStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LuciLandmarkStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LuciLandmarkStreamPassThrough() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(68,
          new ::grpc::internal::CallbackClientStreamingHandler< ::sensors::LuciLandmark, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, ::sensors::Response* response) { return this->LuciLandmarkStreamPassThrough(context, response); }));
    }
    ~ExperimentalWithCallbackMethod_LuciLandmarkStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::LuciLandmark>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerReadReactor< ::sensors::LuciLandmark>* LuciLandmarkStreamPassThrough(
      ::grpc::CallbackServerContext* /*context*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerReadReactor< ::sensors::LuciLandmark>* LuciLandmarkStreamPassThrough(
      ::grpc::experimental::CallbackServerContext* /*context*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RampInfoStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RampInfoStreamPassThrough() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(69,
          new ::grpc::internal::CallbackClientStreamingHandler< ::sensors::RampInfo, ::sensors::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, ::sensors::Response* response) { return this->RampInfoStreamPassThrough(context, response); }));
    }
    ~ExperimentalWithCallbackMethod_RampInfoStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::RampInfo>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerReadReactor< ::sensors::RampInfo>* RampInfoStreamPassThrough(
      ::grpc::CallbackServerContext* /*context*/, ::sensors::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerReadReactor< ::sensors::RampInfo>* RampInfoStreamPassThrough(
      ::grpc::experimental::CallbackServerContext* /*context*/, ::sensors::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LuciLandmarkStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LuciLandmarkStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(70,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::LuciLandmark>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->LuciLandmarkStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_LuciLandmarkStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciLandmark>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::LuciLandmark>* LuciLandmarkStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::LuciLandmark>* LuciLandmarkStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RampInfoStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RampInfoStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(71,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::RampInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->RampInfoStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RampInfoStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::RampInfo>* RampInfoStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::RampInfo>* RampInfoStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DriveModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DriveModeStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(72,
          new ::grpc::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::sensors::ModeCtrl>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->DriveModeStream(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_DriveModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ModeCtrl>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sensors::ModeCtrl>* DriveModeStream(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sensors::ModeCtrl>* DriveModeStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_TurnOnLed<ExperimentalWithCallbackMethod_TurnOffLed<ExperimentalWithCallbackMethod_ActivateHmiState<ExperimentalWithCallbackMethod_DeactivateHmiState<ExperimentalWithCallbackMethod_SetNavigationScaling<ExperimentalWithCallbackMethod_TurnOnUltrasonic<ExperimentalWithCallbackMethod_TurnOffUltrasonic<ExperimentalWithCallbackMethod_TurnOnRadar<ExperimentalWithCallbackMethod_TurnOffRadar<ExperimentalWithCallbackMethod_CollectImuCalibration<ExperimentalWithCallbackMethod_DFGetCurrentParameters<ExperimentalWithCallbackMethod_DFGetBufferedEvents<ExperimentalWithCallbackMethod_DisableLuci<ExperimentalWithCallbackMethod_JsOverride<ExperimentalWithCallbackMethod_SetDriveMode<ExperimentalWithCallbackMethod_SetRampMode<ExperimentalWithCallbackMethod_SetLuciOverride<ExperimentalWithCallbackMethod_ExtPressCount<ExperimentalWithCallbackMethod_HmiStream<ExperimentalWithCallbackMethod_PressCountStream<ExperimentalWithCallbackMethod_UltrasonicStream<ExperimentalWithCallbackMethod_RawUltrasonicStream<ExperimentalWithCallbackMethod_RadarStream<ExperimentalWithCallbackMethod_RawRadarStream<ExperimentalWithCallbackMethod_ChairSpeedStream<ExperimentalWithCallbackMethod_ImuStream<ExperimentalWithCallbackMethod_ChairModeStream<ExperimentalWithCallbackMethod_ChairProfileStream<ExperimentalWithCallbackMethod_SpeedSettingStream<ExperimentalWithCallbackMethod_JoystickStream<ExperimentalWithCallbackMethod_VirtualJoystickStream<ExperimentalWithCallbackMethod_PhysicalJoystickStream<ExperimentalWithCallbackMethod_ScaledJoystickStream<ExperimentalWithCallbackMethod_LuciJoystickStream<ExperimentalWithCallbackMethod_AhrsStream<ExperimentalWithCallbackMethod_RadarClosestObstaclesStream<ExperimentalWithCallbackMethod_UltrasonicClosestObstaclesStream<ExperimentalWithCallbackMethod_CameraCollisionClosestObstaclesStream<ExperimentalWithCallbackMethod_StepClosestObstaclesStream<ExperimentalWithCallbackMethod_DropoffClosestObstaclesStream<ExperimentalWithCallbackMethod_ScalingStream<ExperimentalWithCallbackMethod_BatteryVoltageStream<ExperimentalWithCallbackMethod_BatteryPercentStream<ExperimentalWithCallbackMethod_CameraStream<ExperimentalWithCallbackMethod_FlatCameraStream<ExperimentalWithCallbackMethod_DropoffCameraStream<ExperimentalWithCallbackMethod_CaneCameraStream<ExperimentalWithCallbackMethod_GPSStream<ExperimentalWithCallbackMethod_SeatPressureStream<ExperimentalWithCallbackMethod_DFParametersChangedStream<ExperimentalWithCallbackMethod_DFEventStream<ExperimentalWithCallbackMethod_SendLogging<ExperimentalWithCallbackMethod_LoggingStream<ExperimentalWithCallbackMethod_StepCameraStream<ExperimentalWithCallbackMethod_IrStream<ExperimentalWithCallbackMethod_RampAssistStream<ExperimentalWithCallbackMethod_DistStream<ExperimentalWithCallbackMethod_StartModeStream<ExperimentalWithCallbackMethod_AudioPlaybackRequestStream<ExperimentalWithCallbackMethod_GetZoneBoundaries<ExperimentalWithCallbackMethod_GetBlockedZones<ExperimentalWithCallbackMethod_GetJoystickRanges<ExperimentalWithCallbackMethod_EnableRadarFilter<ExperimentalWithCallbackMethod_DisableRadarFilter<ExperimentalWithCallbackMethod_EncoderStream<ExperimentalWithCallbackMethod_GetCalMatrix<ExperimentalWithCallbackMethod_TestReaction<ExperimentalWithCallbackMethod_LuciOverrideStream<ExperimentalWithCallbackMethod_LuciLandmarkStreamPassThrough<ExperimentalWithCallbackMethod_RampInfoStreamPassThrough<ExperimentalWithCallbackMethod_LuciLandmarkStream<ExperimentalWithCallbackMethod_RampInfoStream<ExperimentalWithCallbackMethod_DriveModeStream<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_TurnOnLed<ExperimentalWithCallbackMethod_TurnOffLed<ExperimentalWithCallbackMethod_ActivateHmiState<ExperimentalWithCallbackMethod_DeactivateHmiState<ExperimentalWithCallbackMethod_SetNavigationScaling<ExperimentalWithCallbackMethod_TurnOnUltrasonic<ExperimentalWithCallbackMethod_TurnOffUltrasonic<ExperimentalWithCallbackMethod_TurnOnRadar<ExperimentalWithCallbackMethod_TurnOffRadar<ExperimentalWithCallbackMethod_CollectImuCalibration<ExperimentalWithCallbackMethod_DFGetCurrentParameters<ExperimentalWithCallbackMethod_DFGetBufferedEvents<ExperimentalWithCallbackMethod_DisableLuci<ExperimentalWithCallbackMethod_JsOverride<ExperimentalWithCallbackMethod_SetDriveMode<ExperimentalWithCallbackMethod_SetRampMode<ExperimentalWithCallbackMethod_SetLuciOverride<ExperimentalWithCallbackMethod_ExtPressCount<ExperimentalWithCallbackMethod_HmiStream<ExperimentalWithCallbackMethod_PressCountStream<ExperimentalWithCallbackMethod_UltrasonicStream<ExperimentalWithCallbackMethod_RawUltrasonicStream<ExperimentalWithCallbackMethod_RadarStream<ExperimentalWithCallbackMethod_RawRadarStream<ExperimentalWithCallbackMethod_ChairSpeedStream<ExperimentalWithCallbackMethod_ImuStream<ExperimentalWithCallbackMethod_ChairModeStream<ExperimentalWithCallbackMethod_ChairProfileStream<ExperimentalWithCallbackMethod_SpeedSettingStream<ExperimentalWithCallbackMethod_JoystickStream<ExperimentalWithCallbackMethod_VirtualJoystickStream<ExperimentalWithCallbackMethod_PhysicalJoystickStream<ExperimentalWithCallbackMethod_ScaledJoystickStream<ExperimentalWithCallbackMethod_LuciJoystickStream<ExperimentalWithCallbackMethod_AhrsStream<ExperimentalWithCallbackMethod_RadarClosestObstaclesStream<ExperimentalWithCallbackMethod_UltrasonicClosestObstaclesStream<ExperimentalWithCallbackMethod_CameraCollisionClosestObstaclesStream<ExperimentalWithCallbackMethod_StepClosestObstaclesStream<ExperimentalWithCallbackMethod_DropoffClosestObstaclesStream<ExperimentalWithCallbackMethod_ScalingStream<ExperimentalWithCallbackMethod_BatteryVoltageStream<ExperimentalWithCallbackMethod_BatteryPercentStream<ExperimentalWithCallbackMethod_CameraStream<ExperimentalWithCallbackMethod_FlatCameraStream<ExperimentalWithCallbackMethod_DropoffCameraStream<ExperimentalWithCallbackMethod_CaneCameraStream<ExperimentalWithCallbackMethod_GPSStream<ExperimentalWithCallbackMethod_SeatPressureStream<ExperimentalWithCallbackMethod_DFParametersChangedStream<ExperimentalWithCallbackMethod_DFEventStream<ExperimentalWithCallbackMethod_SendLogging<ExperimentalWithCallbackMethod_LoggingStream<ExperimentalWithCallbackMethod_StepCameraStream<ExperimentalWithCallbackMethod_IrStream<ExperimentalWithCallbackMethod_RampAssistStream<ExperimentalWithCallbackMethod_DistStream<ExperimentalWithCallbackMethod_StartModeStream<ExperimentalWithCallbackMethod_AudioPlaybackRequestStream<ExperimentalWithCallbackMethod_GetZoneBoundaries<ExperimentalWithCallbackMethod_GetBlockedZones<ExperimentalWithCallbackMethod_GetJoystickRanges<ExperimentalWithCallbackMethod_EnableRadarFilter<ExperimentalWithCallbackMethod_DisableRadarFilter<ExperimentalWithCallbackMethod_EncoderStream<ExperimentalWithCallbackMethod_GetCalMatrix<ExperimentalWithCallbackMethod_TestReaction<ExperimentalWithCallbackMethod_LuciOverrideStream<ExperimentalWithCallbackMethod_LuciLandmarkStreamPassThrough<ExperimentalWithCallbackMethod_RampInfoStreamPassThrough<ExperimentalWithCallbackMethod_LuciLandmarkStream<ExperimentalWithCallbackMethod_RampInfoStream<ExperimentalWithCallbackMethod_DriveModeStream<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_TurnOnLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TurnOnLed() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_TurnOnLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TurnOffLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TurnOffLed() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_TurnOffLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ActivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ActivateHmiState() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ActivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeactivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeactivateHmiState() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeactivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeactivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetNavigationScaling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetNavigationScaling() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetNavigationScaling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNavigationScaling(::grpc::ServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TurnOnUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TurnOnUltrasonic() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_TurnOnUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TurnOffUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TurnOffUltrasonic() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_TurnOffUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TurnOnRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TurnOnRadar() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_TurnOnRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TurnOffRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TurnOffRadar() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_TurnOffRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CollectImuCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CollectImuCalibration() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_CollectImuCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CollectImuCalibration(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DFGetCurrentParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DFGetCurrentParameters() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_DFGetCurrentParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DFGetBufferedEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DFGetBufferedEvents() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_DFGetBufferedEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableLuci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableLuci() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_DisableLuci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableLuci(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JsOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JsOverride() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_JsOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JsOverride(::grpc::ServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDriveMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDriveMode() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SetDriveMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveMode(::grpc::ServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRampMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRampMode() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SetRampMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRampMode(::grpc::ServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetLuciOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetLuciOverride() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SetLuciOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLuciOverride(::grpc::ServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExtPressCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExtPressCount() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ExtPressCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExtPressCount(::grpc::ServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HmiStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HmiStream() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_HmiStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HmiStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::HmiStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PressCountStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PressCountStream() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_PressCountStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PressCountStream(::grpc::ServerContext* /*context*/, const ::sensors::PressRequest* /*request*/, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UltrasonicStream() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_UltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RawUltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RawUltrasonicStream() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_RawUltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RadarStream() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_RadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RawRadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RawRadarStream() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_RawRadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawRadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChairSpeedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChairSpeedStream() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ChairSpeedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairSpeedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairSpeed>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImuStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImuStream() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_ImuStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImuStream(::grpc::ServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/, ::grpc::ServerWriter< ::sensors::ImuData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChairModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChairModeStream() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_ChairModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairMode>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChairProfileStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChairProfileStream() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_ChairProfileStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairProfileStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairProfile>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpeedSettingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpeedSettingStream() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_SpeedSettingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeedSettingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SpeedSetting>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JoystickStream() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_JoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::Joystick>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VirtualJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VirtualJoystickStream() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_VirtualJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PhysicalJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PhysicalJoystickStream() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_PhysicalJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ScaledJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ScaledJoystickStream() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_ScaledJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LuciJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LuciJoystickStream() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_LuciJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AhrsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AhrsStream() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_AhrsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AhrsStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AhrsData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RadarClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RadarClosestObstaclesStream() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_RadarClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UltrasonicClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UltrasonicClosestObstaclesStream() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_UltrasonicClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CameraCollisionClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CameraCollisionClosestObstaclesStream() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_CameraCollisionClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StepClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StepClosestObstaclesStream() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_StepClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DropoffClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DropoffClosestObstaclesStream() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_DropoffClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ScalingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ScalingStream() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_ScalingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScalingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::NavigationScaling>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatteryVoltageStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatteryVoltageStream() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_BatteryVoltageStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatteryPercentStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatteryPercentStream() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_BatteryPercentStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryPercentStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryPercent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CameraStream() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_CameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FlatCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FlatCameraStream() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_FlatCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlatCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DropoffCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DropoffCameraStream() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_DropoffCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CaneCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CaneCameraStream() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_CaneCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaneCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GPSStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GPSStream() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_GPSStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GPSStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::GPSData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SeatPressureStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SeatPressureStream() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_SeatPressureStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SeatPressureStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SeatPressure>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DFParametersChangedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DFParametersChangedStream() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_DFParametersChangedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFParameters>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DFEventStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DFEventStream() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_DFEventStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFEventStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendLogging() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_SendLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendLogging(::grpc::ServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoggingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoggingStream() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_LoggingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoggingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LoggingData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StepCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StepCameraStream() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_StepCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IrStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IrStream() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_IrStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IrStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::IrFrame>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RampAssistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RampAssistStream() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_RampAssistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampAssistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampAssistStates>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DistStream() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_DistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DistanceData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartModeStream() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_StartModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::StartModeData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AudioPlaybackRequestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AudioPlaybackRequestStream() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_AudioPlaybackRequestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetZoneBoundaries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetZoneBoundaries() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_GetZoneBoundaries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockedZones : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockedZones() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_GetBlockedZones() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockedZones(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJoystickRanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJoystickRanges() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_GetJoystickRanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJoystickRanges(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableRadarFilter() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_EnableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableRadarFilter() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_DisableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EncoderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EncoderStream() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_EncoderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EncoderStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::EncoderData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCalMatrix : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCalMatrix() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_GetCalMatrix() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCalMatrix(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TestReaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TestReaction() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_TestReaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestReaction(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LuciOverrideStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LuciOverrideStream() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_LuciOverrideStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciOverrideStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciOverride>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LuciLandmarkStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LuciLandmarkStreamPassThrough() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_LuciLandmarkStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::LuciLandmark>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RampInfoStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RampInfoStreamPassThrough() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_RampInfoStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::RampInfo>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LuciLandmarkStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LuciLandmarkStream() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_LuciLandmarkStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciLandmark>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RampInfoStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RampInfoStream() {
      ::grpc::Service::MarkMethodGeneric(71);
    }
    ~WithGenericMethod_RampInfoStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DriveModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DriveModeStream() {
      ::grpc::Service::MarkMethodGeneric(72);
    }
    ~WithGenericMethod_DriveModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ModeCtrl>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_TurnOnLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TurnOnLed() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_TurnOnLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOnLed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TurnOffLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TurnOffLed() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_TurnOffLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOffLed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ActivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ActivateHmiState() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ActivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActivateHmiState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeactivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeactivateHmiState() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeactivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeactivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeactivateHmiState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetNavigationScaling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetNavigationScaling() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetNavigationScaling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNavigationScaling(::grpc::ServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetNavigationScaling(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TurnOnUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TurnOnUltrasonic() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_TurnOnUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOnUltrasonic(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TurnOffUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TurnOffUltrasonic() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_TurnOffUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOffUltrasonic(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TurnOnRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TurnOnRadar() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_TurnOnRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOnRadar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TurnOffRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TurnOffRadar() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_TurnOffRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTurnOffRadar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CollectImuCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CollectImuCalibration() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_CollectImuCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CollectImuCalibration(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCollectImuCalibration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DFGetCurrentParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DFGetCurrentParameters() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_DFGetCurrentParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFGetCurrentParameters(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DFGetBufferedEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DFGetBufferedEvents() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_DFGetBufferedEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFGetBufferedEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableLuci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableLuci() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_DisableLuci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableLuci(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableLuci(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JsOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JsOverride() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_JsOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JsOverride(::grpc::ServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJsOverride(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDriveMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDriveMode() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SetDriveMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveMode(::grpc::ServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDriveMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRampMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRampMode() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SetRampMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRampMode(::grpc::ServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRampMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetLuciOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetLuciOverride() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SetLuciOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLuciOverride(::grpc::ServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLuciOverride(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExtPressCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExtPressCount() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_ExtPressCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExtPressCount(::grpc::ServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExtPressCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HmiStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HmiStream() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_HmiStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HmiStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::HmiStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHmiStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(18, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PressCountStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PressCountStream() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_PressCountStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PressCountStream(::grpc::ServerContext* /*context*/, const ::sensors::PressRequest* /*request*/, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPressCountStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(19, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UltrasonicStream() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_UltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUltrasonicStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(20, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RawUltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RawUltrasonicStream() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_RawUltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawUltrasonicStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(21, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RadarStream() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_RadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRadarStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RawRadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RawRadarStream() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_RawRadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawRadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawRadarStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(23, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChairSpeedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChairSpeedStream() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ChairSpeedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairSpeedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairSpeed>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChairSpeedStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImuStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImuStream() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_ImuStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImuStream(::grpc::ServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/, ::grpc::ServerWriter< ::sensors::ImuData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImuStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChairModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChairModeStream() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_ChairModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairMode>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChairModeStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(26, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChairProfileStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChairProfileStream() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_ChairProfileStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairProfileStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairProfile>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChairProfileStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(27, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpeedSettingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpeedSettingStream() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_SpeedSettingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeedSettingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SpeedSetting>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpeedSettingStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(28, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JoystickStream() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_JoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::Joystick>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoystickStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(29, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VirtualJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VirtualJoystickStream() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_VirtualJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVirtualJoystickStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(30, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PhysicalJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PhysicalJoystickStream() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_PhysicalJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPhysicalJoystickStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(31, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ScaledJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ScaledJoystickStream() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_ScaledJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScaledJoystickStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(32, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LuciJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LuciJoystickStream() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_LuciJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciJoystickStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(33, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AhrsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AhrsStream() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_AhrsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AhrsStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AhrsData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAhrsStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(34, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RadarClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RadarClosestObstaclesStream() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_RadarClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRadarClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(35, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UltrasonicClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UltrasonicClosestObstaclesStream() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_UltrasonicClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUltrasonicClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(36, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CameraCollisionClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CameraCollisionClosestObstaclesStream() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_CameraCollisionClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCameraCollisionClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(37, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StepClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StepClosestObstaclesStream() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_StepClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStepClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(38, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DropoffClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DropoffClosestObstaclesStream() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_DropoffClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDropoffClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(39, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ScalingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ScalingStream() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_ScalingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScalingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::NavigationScaling>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScalingStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(40, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatteryVoltageStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatteryVoltageStream() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_BatteryVoltageStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatteryVoltageStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(41, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatteryPercentStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatteryPercentStream() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_BatteryPercentStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryPercentStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryPercent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatteryPercentStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(42, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CameraStream() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_CameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCameraStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(43, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FlatCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FlatCameraStream() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_FlatCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlatCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFlatCameraStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(44, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DropoffCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DropoffCameraStream() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_DropoffCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDropoffCameraStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CaneCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CaneCameraStream() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_CaneCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaneCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCaneCameraStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(46, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GPSStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GPSStream() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_GPSStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GPSStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::GPSData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGPSStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(47, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SeatPressureStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SeatPressureStream() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_SeatPressureStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SeatPressureStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SeatPressure>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSeatPressureStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(48, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DFParametersChangedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DFParametersChangedStream() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_DFParametersChangedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFParameters>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFParametersChangedStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(49, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DFEventStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DFEventStream() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_DFEventStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFEventStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDFEventStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(50, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendLogging() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_SendLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendLogging(::grpc::ServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendLogging(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoggingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoggingStream() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_LoggingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoggingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LoggingData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoggingStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(52, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StepCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StepCameraStream() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_StepCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStepCameraStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(53, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IrStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IrStream() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_IrStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IrStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::IrFrame>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIrStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(54, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RampAssistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RampAssistStream() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_RampAssistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampAssistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampAssistStates>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRampAssistStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(55, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DistStream() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_DistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DistanceData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDistStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(56, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartModeStream() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_StartModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::StartModeData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartModeStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(57, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AudioPlaybackRequestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AudioPlaybackRequestStream() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_AudioPlaybackRequestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAudioPlaybackRequestStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(58, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetZoneBoundaries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetZoneBoundaries() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_GetZoneBoundaries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetZoneBoundaries(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockedZones : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockedZones() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_GetBlockedZones() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockedZones(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockedZones(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJoystickRanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJoystickRanges() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_GetJoystickRanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJoystickRanges(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJoystickRanges(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableRadarFilter() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_EnableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableRadarFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableRadarFilter() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_DisableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableRadarFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EncoderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EncoderStream() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_EncoderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EncoderStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::EncoderData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEncoderStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(64, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCalMatrix : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCalMatrix() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_GetCalMatrix() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCalMatrix(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCalMatrix(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TestReaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TestReaction() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_TestReaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestReaction(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestReaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LuciOverrideStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LuciOverrideStream() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_LuciOverrideStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciOverrideStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciOverride>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciOverrideStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(67, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LuciLandmarkStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LuciLandmarkStreamPassThrough() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_LuciLandmarkStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::LuciLandmark>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciLandmarkStreamPassThrough(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(68, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RampInfoStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RampInfoStreamPassThrough() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_RampInfoStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::RampInfo>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRampInfoStreamPassThrough(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(69, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LuciLandmarkStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LuciLandmarkStream() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_LuciLandmarkStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciLandmark>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLuciLandmarkStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(70, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RampInfoStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RampInfoStream() {
      ::grpc::Service::MarkMethodRaw(71);
    }
    ~WithRawMethod_RampInfoStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRampInfoStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(71, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DriveModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DriveModeStream() {
      ::grpc::Service::MarkMethodRaw(72);
    }
    ~WithRawMethod_DriveModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ModeCtrl>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDriveModeStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(72, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TurnOnLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TurnOnLed() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TurnOnLed(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TurnOnLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOnLed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOnLed(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TurnOffLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TurnOffLed() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TurnOffLed(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TurnOffLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOffLed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOffLed(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ActivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ActivateHmiState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ActivateHmiState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ActivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ActivateHmiState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ActivateHmiState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeactivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeactivateHmiState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeactivateHmiState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeactivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeactivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeactivateHmiState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeactivateHmiState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetNavigationScaling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetNavigationScaling() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetNavigationScaling(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetNavigationScaling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNavigationScaling(::grpc::ServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetNavigationScaling(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetNavigationScaling(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TurnOnUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TurnOnUltrasonic() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TurnOnUltrasonic(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TurnOnUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOnUltrasonic(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOnUltrasonic(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TurnOffUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TurnOffUltrasonic() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TurnOffUltrasonic(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TurnOffUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOffUltrasonic(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOffUltrasonic(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TurnOnRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TurnOnRadar() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TurnOnRadar(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TurnOnRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOnRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOnRadar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOnRadar(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TurnOffRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TurnOffRadar() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TurnOffRadar(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TurnOffRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TurnOffRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TurnOffRadar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TurnOffRadar(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CollectImuCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CollectImuCalibration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CollectImuCalibration(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CollectImuCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CollectImuCalibration(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CollectImuCalibration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CollectImuCalibration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DFGetCurrentParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DFGetCurrentParameters() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DFGetCurrentParameters(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DFGetCurrentParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DFGetCurrentParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DFGetCurrentParameters(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DFGetBufferedEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DFGetBufferedEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DFGetBufferedEvents(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DFGetBufferedEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DFGetBufferedEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DFGetBufferedEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DisableLuci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DisableLuci() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableLuci(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DisableLuci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableLuci(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DisableLuci(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DisableLuci(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_JsOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_JsOverride() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JsOverride(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_JsOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JsOverride(::grpc::ServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JsOverride(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JsOverride(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetDriveMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetDriveMode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDriveMode(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetDriveMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveMode(::grpc::ServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetDriveMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetDriveMode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRampMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRampMode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRampMode(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRampMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRampMode(::grpc::ServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetRampMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetRampMode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetLuciOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetLuciOverride() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetLuciOverride(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetLuciOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLuciOverride(::grpc::ServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetLuciOverride(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetLuciOverride(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExtPressCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExtPressCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExtPressCount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExtPressCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExtPressCount(::grpc::ServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExtPressCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExtPressCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HmiStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_HmiStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->HmiStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_HmiStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HmiStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::HmiStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* HmiStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* HmiStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PressCountStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PressCountStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->PressCountStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_PressCountStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PressCountStream(::grpc::ServerContext* /*context*/, const ::sensors::PressRequest* /*request*/, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* PressCountStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* PressCountStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UltrasonicStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->UltrasonicStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_UltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* UltrasonicStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* UltrasonicStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RawUltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RawUltrasonicStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RawUltrasonicStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RawUltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RawUltrasonicStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RawUltrasonicStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RadarStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RadarStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RadarStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RadarStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RawRadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RawRadarStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RawRadarStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RawRadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawRadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RawRadarStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RawRadarStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChairSpeedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChairSpeedStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ChairSpeedStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChairSpeedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairSpeedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairSpeed>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ChairSpeedStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ChairSpeedStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImuStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImuStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ImuStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImuStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImuStream(::grpc::ServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/, ::grpc::ServerWriter< ::sensors::ImuData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ImuStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ImuStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChairModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChairModeStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ChairModeStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChairModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairMode>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ChairModeStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ChairModeStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChairProfileStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChairProfileStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ChairProfileStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChairProfileStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChairProfileStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairProfile>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ChairProfileStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ChairProfileStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SpeedSettingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SpeedSettingStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SpeedSettingStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SpeedSettingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeedSettingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SpeedSetting>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SpeedSettingStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SpeedSettingStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_JoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_JoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->JoystickStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_JoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::Joystick>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* JoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* JoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VirtualJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VirtualJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->VirtualJoystickStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_VirtualJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* VirtualJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* VirtualJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PhysicalJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PhysicalJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->PhysicalJoystickStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_PhysicalJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* PhysicalJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* PhysicalJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ScaledJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ScaledJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ScaledJoystickStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ScaledJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ScaledJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ScaledJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LuciJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LuciJoystickStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->LuciJoystickStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_LuciJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* LuciJoystickStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* LuciJoystickStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AhrsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AhrsStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->AhrsStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_AhrsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AhrsStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AhrsData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* AhrsStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* AhrsStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RadarClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RadarClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RadarClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RadarClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RadarClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RadarClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UltrasonicClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UltrasonicClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->UltrasonicClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_UltrasonicClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* UltrasonicClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* UltrasonicClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CameraCollisionClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CameraCollisionClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->CameraCollisionClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_CameraCollisionClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* CameraCollisionClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* CameraCollisionClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StepClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StepClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->StepClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_StepClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StepClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* StepClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DropoffClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DropoffClosestObstaclesStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->DropoffClosestObstaclesStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_DropoffClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DropoffClosestObstaclesStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* DropoffClosestObstaclesStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ScalingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ScalingStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ScalingStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ScalingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScalingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::NavigationScaling>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ScalingStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ScalingStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BatteryVoltageStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BatteryVoltageStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->BatteryVoltageStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_BatteryVoltageStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* BatteryVoltageStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* BatteryVoltageStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BatteryPercentStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BatteryPercentStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->BatteryPercentStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_BatteryPercentStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatteryPercentStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryPercent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* BatteryPercentStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* BatteryPercentStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->CameraStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_CameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* CameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* CameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FlatCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FlatCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->FlatCameraStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_FlatCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlatCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* FlatCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* FlatCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DropoffCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DropoffCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->DropoffCameraStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_DropoffCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropoffCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DropoffCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* DropoffCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CaneCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CaneCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->CaneCameraStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_CaneCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaneCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* CaneCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* CaneCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GPSStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GPSStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GPSStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GPSStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GPSStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::GPSData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GPSStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GPSStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SeatPressureStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SeatPressureStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SeatPressureStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SeatPressureStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SeatPressureStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SeatPressure>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SeatPressureStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SeatPressureStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DFParametersChangedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DFParametersChangedStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->DFParametersChangedStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_DFParametersChangedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFParameters>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DFParametersChangedStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* DFParametersChangedStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DFEventStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DFEventStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->DFEventStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_DFEventStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DFEventStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DFEventStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* DFEventStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendLogging() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendLogging(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendLogging(::grpc::ServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendLogging(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendLogging(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LoggingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LoggingStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->LoggingStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_LoggingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoggingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LoggingData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* LoggingStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* LoggingStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StepCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StepCameraStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->StepCameraStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_StepCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StepCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StepCameraStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* StepCameraStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IrStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IrStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->IrStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_IrStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IrStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::IrFrame>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* IrStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* IrStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RampAssistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RampAssistStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RampAssistStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RampAssistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampAssistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampAssistStates>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RampAssistStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RampAssistStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DistStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->DistStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_DistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DistanceData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DistStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* DistStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartModeStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->StartModeStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::StartModeData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StartModeStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* StartModeStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AudioPlaybackRequestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AudioPlaybackRequestStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->AudioPlaybackRequestStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_AudioPlaybackRequestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* AudioPlaybackRequestStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* AudioPlaybackRequestStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetZoneBoundaries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetZoneBoundaries() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetZoneBoundaries(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetZoneBoundaries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetZoneBoundaries(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetZoneBoundaries(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockedZones : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockedZones() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockedZones(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockedZones() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockedZones(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockedZones(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockedZones(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetJoystickRanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetJoystickRanges() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJoystickRanges(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetJoystickRanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJoystickRanges(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetJoystickRanges(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetJoystickRanges(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EnableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EnableRadarFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableRadarFilter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EnableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EnableRadarFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EnableRadarFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DisableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DisableRadarFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableRadarFilter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DisableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DisableRadarFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DisableRadarFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EncoderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EncoderStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->EncoderStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_EncoderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EncoderStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::EncoderData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* EncoderStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* EncoderStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCalMatrix : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCalMatrix() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCalMatrix(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCalMatrix() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCalMatrix(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCalMatrix(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCalMatrix(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TestReaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TestReaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TestReaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TestReaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestReaction(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TestReaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TestReaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LuciOverrideStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LuciOverrideStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(67,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->LuciOverrideStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_LuciOverrideStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciOverrideStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciOverride>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* LuciOverrideStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* LuciOverrideStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LuciLandmarkStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LuciLandmarkStreamPassThrough() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(68,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, ::grpc::ByteBuffer* response) { return this->LuciLandmarkStreamPassThrough(context, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LuciLandmarkStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::LuciLandmark>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* LuciLandmarkStreamPassThrough(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer>* LuciLandmarkStreamPassThrough(
      ::grpc::experimental::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RampInfoStreamPassThrough : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RampInfoStreamPassThrough() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(69,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, ::grpc::ByteBuffer* response) { return this->RampInfoStreamPassThrough(context, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RampInfoStreamPassThrough() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStreamPassThrough(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::sensors::RampInfo>* /*reader*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* RampInfoStreamPassThrough(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer>* RampInfoStreamPassThrough(
      ::grpc::experimental::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LuciLandmarkStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LuciLandmarkStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(70,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->LuciLandmarkStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_LuciLandmarkStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciLandmark>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* LuciLandmarkStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* LuciLandmarkStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RampInfoStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RampInfoStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(71,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RampInfoStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RampInfoStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RampInfoStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RampInfoStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RampInfoStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DriveModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DriveModeStream() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(72,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->DriveModeStream(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_DriveModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ModeCtrl>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DriveModeStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* DriveModeStream(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TurnOnLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TurnOnLed() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::Led, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::Led, ::sensors::Response>* streamer) {
                       return this->StreamedTurnOnLed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TurnOnLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TurnOnLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTurnOnLed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::Led,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TurnOffLed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TurnOffLed() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::Led, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::Led, ::sensors::Response>* streamer) {
                       return this->StreamedTurnOffLed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TurnOffLed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TurnOffLed(::grpc::ServerContext* /*context*/, const ::sensors::Led* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTurnOffLed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::Led,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ActivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ActivateHmiState() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::HmiState, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::HmiState, ::sensors::Response>* streamer) {
                       return this->StreamedActivateHmiState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ActivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ActivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedActivateHmiState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::HmiState,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeactivateHmiState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeactivateHmiState() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::HmiState, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::HmiState, ::sensors::Response>* streamer) {
                       return this->StreamedDeactivateHmiState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeactivateHmiState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeactivateHmiState(::grpc::ServerContext* /*context*/, const ::sensors::HmiState* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeactivateHmiState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::HmiState,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetNavigationScaling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetNavigationScaling() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::NavigationScaling, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::NavigationScaling, ::sensors::Response>* streamer) {
                       return this->StreamedSetNavigationScaling(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetNavigationScaling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetNavigationScaling(::grpc::ServerContext* /*context*/, const ::sensors::NavigationScaling* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetNavigationScaling(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::NavigationScaling,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TurnOnUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TurnOnUltrasonic() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::UltrasonicCtrl, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::UltrasonicCtrl, ::sensors::Response>* streamer) {
                       return this->StreamedTurnOnUltrasonic(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TurnOnUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TurnOnUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTurnOnUltrasonic(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::UltrasonicCtrl,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TurnOffUltrasonic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TurnOffUltrasonic() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::UltrasonicCtrl, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::UltrasonicCtrl, ::sensors::Response>* streamer) {
                       return this->StreamedTurnOffUltrasonic(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TurnOffUltrasonic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TurnOffUltrasonic(::grpc::ServerContext* /*context*/, const ::sensors::UltrasonicCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTurnOffUltrasonic(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::UltrasonicCtrl,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TurnOnRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TurnOnRadar() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::RadarCtrl, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::RadarCtrl, ::sensors::Response>* streamer) {
                       return this->StreamedTurnOnRadar(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TurnOnRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TurnOnRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTurnOnRadar(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::RadarCtrl,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TurnOffRadar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TurnOffRadar() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::RadarCtrl, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::RadarCtrl, ::sensors::Response>* streamer) {
                       return this->StreamedTurnOffRadar(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TurnOffRadar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TurnOffRadar(::grpc::ServerContext* /*context*/, const ::sensors::RadarCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTurnOffRadar(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::RadarCtrl,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CollectImuCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CollectImuCalibration() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::Response>* streamer) {
                       return this->StreamedCollectImuCalibration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CollectImuCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CollectImuCalibration(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCollectImuCalibration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DFGetCurrentParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DFGetCurrentParameters() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::Response>* streamer) {
                       return this->StreamedDFGetCurrentParameters(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DFGetCurrentParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DFGetCurrentParameters(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDFGetCurrentParameters(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DFGetBufferedEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DFGetBufferedEvents() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::Response>* streamer) {
                       return this->StreamedDFGetBufferedEvents(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DFGetBufferedEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DFGetBufferedEvents(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDFGetBufferedEvents(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableLuci : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableLuci() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::Response>* streamer) {
                       return this->StreamedDisableLuci(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableLuci() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableLuci(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableLuci(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JsOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JsOverride() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::RemoteJsValues, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::RemoteJsValues, ::sensors::Response>* streamer) {
                       return this->StreamedJsOverride(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JsOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JsOverride(::grpc::ServerContext* /*context*/, const ::sensors::RemoteJsValues* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJsOverride(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::RemoteJsValues,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDriveMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDriveMode() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::ModeCtrl, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::ModeCtrl, ::sensors::Response>* streamer) {
                       return this->StreamedSetDriveMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDriveMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDriveMode(::grpc::ServerContext* /*context*/, const ::sensors::ModeCtrl* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDriveMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::ModeCtrl,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRampMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRampMode() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::RampMode, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::RampMode, ::sensors::Response>* streamer) {
                       return this->StreamedSetRampMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRampMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRampMode(::grpc::ServerContext* /*context*/, const ::sensors::RampMode* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRampMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::RampMode,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetLuciOverride : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetLuciOverride() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::LuciOverride, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::LuciOverride, ::sensors::Response>* streamer) {
                       return this->StreamedSetLuciOverride(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetLuciOverride() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetLuciOverride(::grpc::ServerContext* /*context*/, const ::sensors::LuciOverride* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetLuciOverride(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::LuciOverride,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExtPressCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExtPressCount() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::PressCountStreamData, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::PressCountStreamData, ::sensors::Response>* streamer) {
                       return this->StreamedExtPressCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExtPressCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExtPressCount(::grpc::ServerContext* /*context*/, const ::sensors::PressCountStreamData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExtPressCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::PressCountStreamData,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendLogging() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::LoggingData, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::LoggingData, ::sensors::Response>* streamer) {
                       return this->StreamedSendLogging(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendLogging(::grpc::ServerContext* /*context*/, const ::sensors::LoggingData* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendLogging(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::LoggingData,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetZoneBoundaries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetZoneBoundaries() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::ZoneBoundaries>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::ZoneBoundaries>* streamer) {
                       return this->StreamedGetZoneBoundaries(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetZoneBoundaries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetZoneBoundaries(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ZoneBoundaries* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetZoneBoundaries(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::ZoneBoundaries>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockedZones : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockedZones() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::BlockedZones>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::BlockedZones>* streamer) {
                       return this->StreamedGetBlockedZones(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockedZones() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockedZones(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::BlockedZones* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockedZones(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::BlockedZones>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJoystickRanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJoystickRanges() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::JoystickRanges>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::JoystickRanges>* streamer) {
                       return this->StreamedGetJoystickRanges(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJoystickRanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJoystickRanges(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::JoystickRanges* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJoystickRanges(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::JoystickRanges>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableRadarFilter() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::RadarFilter, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::RadarFilter, ::sensors::Response>* streamer) {
                       return this->StreamedEnableRadarFilter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableRadarFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::RadarFilter,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableRadarFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableRadarFilter() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sensors::RadarFilter, ::sensors::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sensors::RadarFilter, ::sensors::Response>* streamer) {
                       return this->StreamedDisableRadarFilter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableRadarFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableRadarFilter(::grpc::ServerContext* /*context*/, const ::sensors::RadarFilter* /*request*/, ::sensors::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableRadarFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sensors::RadarFilter,::sensors::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCalMatrix : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCalMatrix() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::CalMatrix>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::CalMatrix>* streamer) {
                       return this->StreamedGetCalMatrix(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCalMatrix() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCalMatrix(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::CalMatrix* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCalMatrix(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::CalMatrix>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TestReaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TestReaction() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sensors::ReactionTestResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sensors::ReactionTestResult>* streamer) {
                       return this->StreamedTestReaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TestReaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TestReaction(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sensors::ReactionTestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTestReaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sensors::ReactionTestResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_TurnOnLed<WithStreamedUnaryMethod_TurnOffLed<WithStreamedUnaryMethod_ActivateHmiState<WithStreamedUnaryMethod_DeactivateHmiState<WithStreamedUnaryMethod_SetNavigationScaling<WithStreamedUnaryMethod_TurnOnUltrasonic<WithStreamedUnaryMethod_TurnOffUltrasonic<WithStreamedUnaryMethod_TurnOnRadar<WithStreamedUnaryMethod_TurnOffRadar<WithStreamedUnaryMethod_CollectImuCalibration<WithStreamedUnaryMethod_DFGetCurrentParameters<WithStreamedUnaryMethod_DFGetBufferedEvents<WithStreamedUnaryMethod_DisableLuci<WithStreamedUnaryMethod_JsOverride<WithStreamedUnaryMethod_SetDriveMode<WithStreamedUnaryMethod_SetRampMode<WithStreamedUnaryMethod_SetLuciOverride<WithStreamedUnaryMethod_ExtPressCount<WithStreamedUnaryMethod_SendLogging<WithStreamedUnaryMethod_GetZoneBoundaries<WithStreamedUnaryMethod_GetBlockedZones<WithStreamedUnaryMethod_GetJoystickRanges<WithStreamedUnaryMethod_EnableRadarFilter<WithStreamedUnaryMethod_DisableRadarFilter<WithStreamedUnaryMethod_GetCalMatrix<WithStreamedUnaryMethod_TestReaction<Service > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_HmiStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_HmiStream() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::HmiStreamData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::HmiStreamData>* streamer) {
                       return this->StreamedHmiStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_HmiStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HmiStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::HmiStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedHmiStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::HmiStreamData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_PressCountStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_PressCountStream() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sensors::PressRequest, ::sensors::PressCountStreamData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::sensors::PressRequest, ::sensors::PressCountStreamData>* streamer) {
                       return this->StreamedPressCountStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_PressCountStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PressCountStream(::grpc::ServerContext* /*context*/, const ::sensors::PressRequest* /*request*/, ::grpc::ServerWriter< ::sensors::PressCountStreamData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPressCountStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sensors::PressRequest,::sensors::PressCountStreamData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_UltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_UltrasonicStream() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::UltrasonicDistances>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::UltrasonicDistances>* streamer) {
                       return this->StreamedUltrasonicStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_UltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicDistances>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedUltrasonicStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::UltrasonicDistances>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RawUltrasonicStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RawUltrasonicStream() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::UltrasonicCurve>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::UltrasonicCurve>* streamer) {
                       return this->StreamedRawUltrasonicStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RawUltrasonicStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RawUltrasonicStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::UltrasonicCurve>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRawUltrasonicStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::UltrasonicCurve>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RadarStream() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::RadarPoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::RadarPoints>* streamer) {
                       return this->StreamedRadarStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRadarStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::RadarPoints>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RawRadarStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RawRadarStream() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::RadarPoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::RadarPoints>* streamer) {
                       return this->StreamedRawRadarStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RawRadarStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RawRadarStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RadarPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRawRadarStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::RadarPoints>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ChairSpeedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ChairSpeedStream() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ChairSpeed>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ChairSpeed>* streamer) {
                       return this->StreamedChairSpeedStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ChairSpeedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChairSpeedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairSpeed>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedChairSpeedStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ChairSpeed>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ImuStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ImuStream() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sensors::ImuCtrl, ::sensors::ImuData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::sensors::ImuCtrl, ::sensors::ImuData>* streamer) {
                       return this->StreamedImuStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ImuStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImuStream(::grpc::ServerContext* /*context*/, const ::sensors::ImuCtrl* /*request*/, ::grpc::ServerWriter< ::sensors::ImuData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedImuStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sensors::ImuCtrl,::sensors::ImuData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ChairModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ChairModeStream() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ChairMode>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ChairMode>* streamer) {
                       return this->StreamedChairModeStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ChairModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChairModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairMode>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedChairModeStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ChairMode>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ChairProfileStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ChairProfileStream() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ChairProfile>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ChairProfile>* streamer) {
                       return this->StreamedChairProfileStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ChairProfileStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChairProfileStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ChairProfile>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedChairProfileStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ChairProfile>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SpeedSettingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SpeedSettingStream() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::SpeedSetting>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::SpeedSetting>* streamer) {
                       return this->StreamedSpeedSettingStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SpeedSettingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpeedSettingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SpeedSetting>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSpeedSettingStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::SpeedSetting>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_JoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_JoystickStream() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::Joystick>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::Joystick>* streamer) {
                       return this->StreamedJoystickStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_JoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::Joystick>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedJoystickStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::Joystick>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_VirtualJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_VirtualJoystickStream() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::JoystickData>* streamer) {
                       return this->StreamedVirtualJoystickStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_VirtualJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VirtualJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedVirtualJoystickStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::JoystickData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_PhysicalJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_PhysicalJoystickStream() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::JoystickData>* streamer) {
                       return this->StreamedPhysicalJoystickStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_PhysicalJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PhysicalJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPhysicalJoystickStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::JoystickData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ScaledJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ScaledJoystickStream() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::JoystickData>* streamer) {
                       return this->StreamedScaledJoystickStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ScaledJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ScaledJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedScaledJoystickStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::JoystickData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_LuciJoystickStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_LuciJoystickStream() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::JoystickData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::JoystickData>* streamer) {
                       return this->StreamedLuciJoystickStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_LuciJoystickStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LuciJoystickStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::JoystickData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedLuciJoystickStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::JoystickData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_AhrsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_AhrsStream() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::AhrsData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::AhrsData>* streamer) {
                       return this->StreamedAhrsStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_AhrsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AhrsStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AhrsData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedAhrsStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::AhrsData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RadarClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RadarClosestObstaclesStream() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ClosestObstacles>* streamer) {
                       return this->StreamedRadarClosestObstaclesStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RadarClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RadarClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRadarClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ClosestObstacles>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_UltrasonicClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_UltrasonicClosestObstaclesStream() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ClosestObstacles>* streamer) {
                       return this->StreamedUltrasonicClosestObstaclesStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_UltrasonicClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UltrasonicClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedUltrasonicClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ClosestObstacles>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_CameraCollisionClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_CameraCollisionClosestObstaclesStream() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ClosestObstacles>* streamer) {
                       return this->StreamedCameraCollisionClosestObstaclesStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_CameraCollisionClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CameraCollisionClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCameraCollisionClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ClosestObstacles>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StepClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StepClosestObstaclesStream() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ClosestObstacles>* streamer) {
                       return this->StreamedStepClosestObstaclesStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StepClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StepClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStepClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ClosestObstacles>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DropoffClosestObstaclesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DropoffClosestObstaclesStream() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ClosestObstacles>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ClosestObstacles>* streamer) {
                       return this->StreamedDropoffClosestObstaclesStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DropoffClosestObstaclesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DropoffClosestObstaclesStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ClosestObstacles>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDropoffClosestObstaclesStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ClosestObstacles>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ScalingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ScalingStream() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::NavigationScaling>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::NavigationScaling>* streamer) {
                       return this->StreamedScalingStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ScalingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ScalingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::NavigationScaling>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedScalingStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::NavigationScaling>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_BatteryVoltageStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_BatteryVoltageStream() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::BatteryVoltage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::BatteryVoltage>* streamer) {
                       return this->StreamedBatteryVoltageStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_BatteryVoltageStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatteryVoltageStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryVoltage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedBatteryVoltageStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::BatteryVoltage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_BatteryPercentStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_BatteryPercentStream() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::BatteryPercent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::BatteryPercent>* streamer) {
                       return this->StreamedBatteryPercentStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_BatteryPercentStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatteryPercentStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::BatteryPercent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedBatteryPercentStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::BatteryPercent>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_CameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_CameraStream() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::CameraPoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::CameraPoints>* streamer) {
                       return this->StreamedCameraStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_CameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCameraStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::CameraPoints>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_FlatCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_FlatCameraStream() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::CameraPoints2D>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::CameraPoints2D>* streamer) {
                       return this->StreamedFlatCameraStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_FlatCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FlatCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedFlatCameraStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::CameraPoints2D>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DropoffCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DropoffCameraStream() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::CameraPoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::CameraPoints>* streamer) {
                       return this->StreamedDropoffCameraStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DropoffCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DropoffCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDropoffCameraStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::CameraPoints>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_CaneCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_CaneCameraStream() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ObjectDetection2D>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ObjectDetection2D>* streamer) {
                       return this->StreamedCaneCameraStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_CaneCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CaneCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ObjectDetection2D>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCaneCameraStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ObjectDetection2D>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GPSStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GPSStream() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::GPSData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::GPSData>* streamer) {
                       return this->StreamedGPSStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GPSStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GPSStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::GPSData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGPSStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::GPSData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SeatPressureStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SeatPressureStream() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::SeatPressure>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::SeatPressure>* streamer) {
                       return this->StreamedSeatPressureStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SeatPressureStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SeatPressureStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::SeatPressure>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSeatPressureStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::SeatPressure>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DFParametersChangedStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DFParametersChangedStream() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::DFParameters>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::DFParameters>* streamer) {
                       return this->StreamedDFParametersChangedStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DFParametersChangedStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DFParametersChangedStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFParameters>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDFParametersChangedStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::DFParameters>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DFEventStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DFEventStream() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::DFSeatEvent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::DFSeatEvent>* streamer) {
                       return this->StreamedDFEventStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DFEventStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DFEventStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DFSeatEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDFEventStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::DFSeatEvent>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_LoggingStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_LoggingStream() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::LoggingData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::LoggingData>* streamer) {
                       return this->StreamedLoggingStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_LoggingStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoggingStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LoggingData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedLoggingStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::LoggingData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StepCameraStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StepCameraStream() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::CameraPoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::CameraPoints>* streamer) {
                       return this->StreamedStepCameraStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StepCameraStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StepCameraStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::CameraPoints>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStepCameraStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::CameraPoints>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_IrStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_IrStream() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::IrFrame>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::IrFrame>* streamer) {
                       return this->StreamedIrStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_IrStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IrStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::IrFrame>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedIrStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::IrFrame>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RampAssistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RampAssistStream() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::RampAssistStates>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::RampAssistStates>* streamer) {
                       return this->StreamedRampAssistStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RampAssistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RampAssistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampAssistStates>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRampAssistStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::RampAssistStates>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DistStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DistStream() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::DistanceData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::DistanceData>* streamer) {
                       return this->StreamedDistStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DistStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DistStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::DistanceData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDistStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::DistanceData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StartModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StartModeStream() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::StartModeData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::StartModeData>* streamer) {
                       return this->StreamedStartModeStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StartModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::StartModeData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartModeStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::StartModeData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_AudioPlaybackRequestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_AudioPlaybackRequestStream() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::AudioPlaybackRequest>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::AudioPlaybackRequest>* streamer) {
                       return this->StreamedAudioPlaybackRequestStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_AudioPlaybackRequestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AudioPlaybackRequestStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::AudioPlaybackRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedAudioPlaybackRequestStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::AudioPlaybackRequest>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_EncoderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_EncoderStream() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::EncoderData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::EncoderData>* streamer) {
                       return this->StreamedEncoderStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_EncoderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EncoderStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::EncoderData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedEncoderStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::EncoderData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_LuciOverrideStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_LuciOverrideStream() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::LuciOverride>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::LuciOverride>* streamer) {
                       return this->StreamedLuciOverrideStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_LuciOverrideStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LuciOverrideStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciOverride>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedLuciOverrideStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::LuciOverride>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_LuciLandmarkStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_LuciLandmarkStream() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::LuciLandmark>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::LuciLandmark>* streamer) {
                       return this->StreamedLuciLandmarkStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_LuciLandmarkStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LuciLandmarkStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::LuciLandmark>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedLuciLandmarkStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::LuciLandmark>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RampInfoStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RampInfoStream() {
      ::grpc::Service::MarkMethodStreamed(71,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::RampInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::RampInfo>* streamer) {
                       return this->StreamedRampInfoStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RampInfoStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RampInfoStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::RampInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRampInfoStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::RampInfo>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DriveModeStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DriveModeStream() {
      ::grpc::Service::MarkMethodStreamed(72,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::sensors::ModeCtrl>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::sensors::ModeCtrl>* streamer) {
                       return this->StreamedDriveModeStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DriveModeStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DriveModeStream(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::sensors::ModeCtrl>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDriveModeStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::sensors::ModeCtrl>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_HmiStream<WithSplitStreamingMethod_PressCountStream<WithSplitStreamingMethod_UltrasonicStream<WithSplitStreamingMethod_RawUltrasonicStream<WithSplitStreamingMethod_RadarStream<WithSplitStreamingMethod_RawRadarStream<WithSplitStreamingMethod_ChairSpeedStream<WithSplitStreamingMethod_ImuStream<WithSplitStreamingMethod_ChairModeStream<WithSplitStreamingMethod_ChairProfileStream<WithSplitStreamingMethod_SpeedSettingStream<WithSplitStreamingMethod_JoystickStream<WithSplitStreamingMethod_VirtualJoystickStream<WithSplitStreamingMethod_PhysicalJoystickStream<WithSplitStreamingMethod_ScaledJoystickStream<WithSplitStreamingMethod_LuciJoystickStream<WithSplitStreamingMethod_AhrsStream<WithSplitStreamingMethod_RadarClosestObstaclesStream<WithSplitStreamingMethod_UltrasonicClosestObstaclesStream<WithSplitStreamingMethod_CameraCollisionClosestObstaclesStream<WithSplitStreamingMethod_StepClosestObstaclesStream<WithSplitStreamingMethod_DropoffClosestObstaclesStream<WithSplitStreamingMethod_ScalingStream<WithSplitStreamingMethod_BatteryVoltageStream<WithSplitStreamingMethod_BatteryPercentStream<WithSplitStreamingMethod_CameraStream<WithSplitStreamingMethod_FlatCameraStream<WithSplitStreamingMethod_DropoffCameraStream<WithSplitStreamingMethod_CaneCameraStream<WithSplitStreamingMethod_GPSStream<WithSplitStreamingMethod_SeatPressureStream<WithSplitStreamingMethod_DFParametersChangedStream<WithSplitStreamingMethod_DFEventStream<WithSplitStreamingMethod_LoggingStream<WithSplitStreamingMethod_StepCameraStream<WithSplitStreamingMethod_IrStream<WithSplitStreamingMethod_RampAssistStream<WithSplitStreamingMethod_DistStream<WithSplitStreamingMethod_StartModeStream<WithSplitStreamingMethod_AudioPlaybackRequestStream<WithSplitStreamingMethod_EncoderStream<WithSplitStreamingMethod_LuciOverrideStream<WithSplitStreamingMethod_LuciLandmarkStream<WithSplitStreamingMethod_RampInfoStream<WithSplitStreamingMethod_DriveModeStream<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_TurnOnLed<WithStreamedUnaryMethod_TurnOffLed<WithStreamedUnaryMethod_ActivateHmiState<WithStreamedUnaryMethod_DeactivateHmiState<WithStreamedUnaryMethod_SetNavigationScaling<WithStreamedUnaryMethod_TurnOnUltrasonic<WithStreamedUnaryMethod_TurnOffUltrasonic<WithStreamedUnaryMethod_TurnOnRadar<WithStreamedUnaryMethod_TurnOffRadar<WithStreamedUnaryMethod_CollectImuCalibration<WithStreamedUnaryMethod_DFGetCurrentParameters<WithStreamedUnaryMethod_DFGetBufferedEvents<WithStreamedUnaryMethod_DisableLuci<WithStreamedUnaryMethod_JsOverride<WithStreamedUnaryMethod_SetDriveMode<WithStreamedUnaryMethod_SetRampMode<WithStreamedUnaryMethod_SetLuciOverride<WithStreamedUnaryMethod_ExtPressCount<WithSplitStreamingMethod_HmiStream<WithSplitStreamingMethod_PressCountStream<WithSplitStreamingMethod_UltrasonicStream<WithSplitStreamingMethod_RawUltrasonicStream<WithSplitStreamingMethod_RadarStream<WithSplitStreamingMethod_RawRadarStream<WithSplitStreamingMethod_ChairSpeedStream<WithSplitStreamingMethod_ImuStream<WithSplitStreamingMethod_ChairModeStream<WithSplitStreamingMethod_ChairProfileStream<WithSplitStreamingMethod_SpeedSettingStream<WithSplitStreamingMethod_JoystickStream<WithSplitStreamingMethod_VirtualJoystickStream<WithSplitStreamingMethod_PhysicalJoystickStream<WithSplitStreamingMethod_ScaledJoystickStream<WithSplitStreamingMethod_LuciJoystickStream<WithSplitStreamingMethod_AhrsStream<WithSplitStreamingMethod_RadarClosestObstaclesStream<WithSplitStreamingMethod_UltrasonicClosestObstaclesStream<WithSplitStreamingMethod_CameraCollisionClosestObstaclesStream<WithSplitStreamingMethod_StepClosestObstaclesStream<WithSplitStreamingMethod_DropoffClosestObstaclesStream<WithSplitStreamingMethod_ScalingStream<WithSplitStreamingMethod_BatteryVoltageStream<WithSplitStreamingMethod_BatteryPercentStream<WithSplitStreamingMethod_CameraStream<WithSplitStreamingMethod_FlatCameraStream<WithSplitStreamingMethod_DropoffCameraStream<WithSplitStreamingMethod_CaneCameraStream<WithSplitStreamingMethod_GPSStream<WithSplitStreamingMethod_SeatPressureStream<WithSplitStreamingMethod_DFParametersChangedStream<WithSplitStreamingMethod_DFEventStream<WithStreamedUnaryMethod_SendLogging<WithSplitStreamingMethod_LoggingStream<WithSplitStreamingMethod_StepCameraStream<WithSplitStreamingMethod_IrStream<WithSplitStreamingMethod_RampAssistStream<WithSplitStreamingMethod_DistStream<WithSplitStreamingMethod_StartModeStream<WithSplitStreamingMethod_AudioPlaybackRequestStream<WithStreamedUnaryMethod_GetZoneBoundaries<WithStreamedUnaryMethod_GetBlockedZones<WithStreamedUnaryMethod_GetJoystickRanges<WithStreamedUnaryMethod_EnableRadarFilter<WithStreamedUnaryMethod_DisableRadarFilter<WithSplitStreamingMethod_EncoderStream<WithStreamedUnaryMethod_GetCalMatrix<WithStreamedUnaryMethod_TestReaction<WithSplitStreamingMethod_LuciOverrideStream<WithSplitStreamingMethod_LuciLandmarkStream<WithSplitStreamingMethod_RampInfoStream<WithSplitStreamingMethod_DriveModeStream<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace sensors


#endif  // GRPC_sensors_5fgrpc_2fsensors_2eproto__INCLUDED
