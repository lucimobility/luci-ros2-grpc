// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ptolemy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ptolemy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ptolemy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ptolemy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ptolemy_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[57]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ptolemy_2eproto;
namespace sensors {
class AhrsData;
struct AhrsDataDefaultTypeInternal;
extern AhrsDataDefaultTypeInternal _AhrsData_default_instance_;
class AudioPlaybackRequest;
struct AudioPlaybackRequestDefaultTypeInternal;
extern AudioPlaybackRequestDefaultTypeInternal _AudioPlaybackRequest_default_instance_;
class BatteryPercent;
struct BatteryPercentDefaultTypeInternal;
extern BatteryPercentDefaultTypeInternal _BatteryPercent_default_instance_;
class BatteryVoltage;
struct BatteryVoltageDefaultTypeInternal;
extern BatteryVoltageDefaultTypeInternal _BatteryVoltage_default_instance_;
class BlockedZone;
struct BlockedZoneDefaultTypeInternal;
extern BlockedZoneDefaultTypeInternal _BlockedZone_default_instance_;
class BlockedZones;
struct BlockedZonesDefaultTypeInternal;
extern BlockedZonesDefaultTypeInternal _BlockedZones_default_instance_;
class CameraPoints;
struct CameraPointsDefaultTypeInternal;
extern CameraPointsDefaultTypeInternal _CameraPoints_default_instance_;
class CameraPoints2D;
struct CameraPoints2DDefaultTypeInternal;
extern CameraPoints2DDefaultTypeInternal _CameraPoints2D_default_instance_;
class ChairMode;
struct ChairModeDefaultTypeInternal;
extern ChairModeDefaultTypeInternal _ChairMode_default_instance_;
class ChairProfile;
struct ChairProfileDefaultTypeInternal;
extern ChairProfileDefaultTypeInternal _ChairProfile_default_instance_;
class ChairSpeed;
struct ChairSpeedDefaultTypeInternal;
extern ChairSpeedDefaultTypeInternal _ChairSpeed_default_instance_;
class ClosestObstacles;
struct ClosestObstaclesDefaultTypeInternal;
extern ClosestObstaclesDefaultTypeInternal _ClosestObstacles_default_instance_;
class DFParameters;
struct DFParametersDefaultTypeInternal;
extern DFParametersDefaultTypeInternal _DFParameters_default_instance_;
class DFSeatEvent;
struct DFSeatEventDefaultTypeInternal;
extern DFSeatEventDefaultTypeInternal _DFSeatEvent_default_instance_;
class DistanceData;
struct DistanceDataDefaultTypeInternal;
extern DistanceDataDefaultTypeInternal _DistanceData_default_instance_;
class EncoderData;
struct EncoderDataDefaultTypeInternal;
extern EncoderDataDefaultTypeInternal _EncoderData_default_instance_;
class GPSData;
struct GPSDataDefaultTypeInternal;
extern GPSDataDefaultTypeInternal _GPSData_default_instance_;
class HmiState;
struct HmiStateDefaultTypeInternal;
extern HmiStateDefaultTypeInternal _HmiState_default_instance_;
class HmiStreamData;
struct HmiStreamDataDefaultTypeInternal;
extern HmiStreamDataDefaultTypeInternal _HmiStreamData_default_instance_;
class ImuCtrl;
struct ImuCtrlDefaultTypeInternal;
extern ImuCtrlDefaultTypeInternal _ImuCtrl_default_instance_;
class ImuData;
struct ImuDataDefaultTypeInternal;
extern ImuDataDefaultTypeInternal _ImuData_default_instance_;
class IrFrame;
struct IrFrameDefaultTypeInternal;
extern IrFrameDefaultTypeInternal _IrFrame_default_instance_;
class Joystick;
struct JoystickDefaultTypeInternal;
extern JoystickDefaultTypeInternal _Joystick_default_instance_;
class JoystickData;
struct JoystickDataDefaultTypeInternal;
extern JoystickDataDefaultTypeInternal _JoystickData_default_instance_;
class JoystickRange;
struct JoystickRangeDefaultTypeInternal;
extern JoystickRangeDefaultTypeInternal _JoystickRange_default_instance_;
class JoystickRanges;
struct JoystickRangesDefaultTypeInternal;
extern JoystickRangesDefaultTypeInternal _JoystickRanges_default_instance_;
class Led;
struct LedDefaultTypeInternal;
extern LedDefaultTypeInternal _Led_default_instance_;
class LoggingData;
struct LoggingDataDefaultTypeInternal;
extern LoggingDataDefaultTypeInternal _LoggingData_default_instance_;
class ModeCtrl;
struct ModeCtrlDefaultTypeInternal;
extern ModeCtrlDefaultTypeInternal _ModeCtrl_default_instance_;
class NavigationScaling;
struct NavigationScalingDefaultTypeInternal;
extern NavigationScalingDefaultTypeInternal _NavigationScaling_default_instance_;
class ObstacleValue;
struct ObstacleValueDefaultTypeInternal;
extern ObstacleValueDefaultTypeInternal _ObstacleValue_default_instance_;
class ObstacleValue_Angular;
struct ObstacleValue_AngularDefaultTypeInternal;
extern ObstacleValue_AngularDefaultTypeInternal _ObstacleValue_Angular_default_instance_;
class ObstacleValue_Combo;
struct ObstacleValue_ComboDefaultTypeInternal;
extern ObstacleValue_ComboDefaultTypeInternal _ObstacleValue_Combo_default_instance_;
class ObstacleValue_Linear;
struct ObstacleValue_LinearDefaultTypeInternal;
extern ObstacleValue_LinearDefaultTypeInternal _ObstacleValue_Linear_default_instance_;
class Point2D;
struct Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
struct Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PressCountStreamData;
struct PressCountStreamDataDefaultTypeInternal;
extern PressCountStreamDataDefaultTypeInternal _PressCountStreamData_default_instance_;
class PressRequest;
struct PressRequestDefaultTypeInternal;
extern PressRequestDefaultTypeInternal _PressRequest_default_instance_;
class RadarCtrl;
struct RadarCtrlDefaultTypeInternal;
extern RadarCtrlDefaultTypeInternal _RadarCtrl_default_instance_;
class RadarFilter;
struct RadarFilterDefaultTypeInternal;
extern RadarFilterDefaultTypeInternal _RadarFilter_default_instance_;
class RadarPoint;
struct RadarPointDefaultTypeInternal;
extern RadarPointDefaultTypeInternal _RadarPoint_default_instance_;
class RadarPoints;
struct RadarPointsDefaultTypeInternal;
extern RadarPointsDefaultTypeInternal _RadarPoints_default_instance_;
class RampAssistStates;
struct RampAssistStatesDefaultTypeInternal;
extern RampAssistStatesDefaultTypeInternal _RampAssistStates_default_instance_;
class RampMode;
struct RampModeDefaultTypeInternal;
extern RampModeDefaultTypeInternal _RampMode_default_instance_;
class RemoteJsValues;
struct RemoteJsValuesDefaultTypeInternal;
extern RemoteJsValuesDefaultTypeInternal _RemoteJsValues_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SeatPressure;
struct SeatPressureDefaultTypeInternal;
extern SeatPressureDefaultTypeInternal _SeatPressure_default_instance_;
class SpeedSetting;
struct SpeedSettingDefaultTypeInternal;
extern SpeedSettingDefaultTypeInternal _SpeedSetting_default_instance_;
class StartModeData;
struct StartModeDataDefaultTypeInternal;
extern StartModeDataDefaultTypeInternal _StartModeData_default_instance_;
class UltrasonicCtrl;
struct UltrasonicCtrlDefaultTypeInternal;
extern UltrasonicCtrlDefaultTypeInternal _UltrasonicCtrl_default_instance_;
class UltrasonicCurve;
struct UltrasonicCurveDefaultTypeInternal;
extern UltrasonicCurveDefaultTypeInternal _UltrasonicCurve_default_instance_;
class UltrasonicDistance;
struct UltrasonicDistanceDefaultTypeInternal;
extern UltrasonicDistanceDefaultTypeInternal _UltrasonicDistance_default_instance_;
class UltrasonicDistances;
struct UltrasonicDistancesDefaultTypeInternal;
extern UltrasonicDistancesDefaultTypeInternal _UltrasonicDistances_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec4;
struct Vec4DefaultTypeInternal;
extern Vec4DefaultTypeInternal _Vec4_default_instance_;
class ZoneBoundaries;
struct ZoneBoundariesDefaultTypeInternal;
extern ZoneBoundariesDefaultTypeInternal _ZoneBoundaries_default_instance_;
class ZoneBoundary;
struct ZoneBoundaryDefaultTypeInternal;
extern ZoneBoundaryDefaultTypeInternal _ZoneBoundary_default_instance_;
}  // namespace sensors
PROTOBUF_NAMESPACE_OPEN
template<> ::sensors::AhrsData* Arena::CreateMaybeMessage<::sensors::AhrsData>(Arena*);
template<> ::sensors::AudioPlaybackRequest* Arena::CreateMaybeMessage<::sensors::AudioPlaybackRequest>(Arena*);
template<> ::sensors::BatteryPercent* Arena::CreateMaybeMessage<::sensors::BatteryPercent>(Arena*);
template<> ::sensors::BatteryVoltage* Arena::CreateMaybeMessage<::sensors::BatteryVoltage>(Arena*);
template<> ::sensors::BlockedZone* Arena::CreateMaybeMessage<::sensors::BlockedZone>(Arena*);
template<> ::sensors::BlockedZones* Arena::CreateMaybeMessage<::sensors::BlockedZones>(Arena*);
template<> ::sensors::CameraPoints* Arena::CreateMaybeMessage<::sensors::CameraPoints>(Arena*);
template<> ::sensors::CameraPoints2D* Arena::CreateMaybeMessage<::sensors::CameraPoints2D>(Arena*);
template<> ::sensors::ChairMode* Arena::CreateMaybeMessage<::sensors::ChairMode>(Arena*);
template<> ::sensors::ChairProfile* Arena::CreateMaybeMessage<::sensors::ChairProfile>(Arena*);
template<> ::sensors::ChairSpeed* Arena::CreateMaybeMessage<::sensors::ChairSpeed>(Arena*);
template<> ::sensors::ClosestObstacles* Arena::CreateMaybeMessage<::sensors::ClosestObstacles>(Arena*);
template<> ::sensors::DFParameters* Arena::CreateMaybeMessage<::sensors::DFParameters>(Arena*);
template<> ::sensors::DFSeatEvent* Arena::CreateMaybeMessage<::sensors::DFSeatEvent>(Arena*);
template<> ::sensors::DistanceData* Arena::CreateMaybeMessage<::sensors::DistanceData>(Arena*);
template<> ::sensors::EncoderData* Arena::CreateMaybeMessage<::sensors::EncoderData>(Arena*);
template<> ::sensors::GPSData* Arena::CreateMaybeMessage<::sensors::GPSData>(Arena*);
template<> ::sensors::HmiState* Arena::CreateMaybeMessage<::sensors::HmiState>(Arena*);
template<> ::sensors::HmiStreamData* Arena::CreateMaybeMessage<::sensors::HmiStreamData>(Arena*);
template<> ::sensors::ImuCtrl* Arena::CreateMaybeMessage<::sensors::ImuCtrl>(Arena*);
template<> ::sensors::ImuData* Arena::CreateMaybeMessage<::sensors::ImuData>(Arena*);
template<> ::sensors::IrFrame* Arena::CreateMaybeMessage<::sensors::IrFrame>(Arena*);
template<> ::sensors::Joystick* Arena::CreateMaybeMessage<::sensors::Joystick>(Arena*);
template<> ::sensors::JoystickData* Arena::CreateMaybeMessage<::sensors::JoystickData>(Arena*);
template<> ::sensors::JoystickRange* Arena::CreateMaybeMessage<::sensors::JoystickRange>(Arena*);
template<> ::sensors::JoystickRanges* Arena::CreateMaybeMessage<::sensors::JoystickRanges>(Arena*);
template<> ::sensors::Led* Arena::CreateMaybeMessage<::sensors::Led>(Arena*);
template<> ::sensors::LoggingData* Arena::CreateMaybeMessage<::sensors::LoggingData>(Arena*);
template<> ::sensors::ModeCtrl* Arena::CreateMaybeMessage<::sensors::ModeCtrl>(Arena*);
template<> ::sensors::NavigationScaling* Arena::CreateMaybeMessage<::sensors::NavigationScaling>(Arena*);
template<> ::sensors::ObstacleValue* Arena::CreateMaybeMessage<::sensors::ObstacleValue>(Arena*);
template<> ::sensors::ObstacleValue_Angular* Arena::CreateMaybeMessage<::sensors::ObstacleValue_Angular>(Arena*);
template<> ::sensors::ObstacleValue_Combo* Arena::CreateMaybeMessage<::sensors::ObstacleValue_Combo>(Arena*);
template<> ::sensors::ObstacleValue_Linear* Arena::CreateMaybeMessage<::sensors::ObstacleValue_Linear>(Arena*);
template<> ::sensors::Point2D* Arena::CreateMaybeMessage<::sensors::Point2D>(Arena*);
template<> ::sensors::Point3D* Arena::CreateMaybeMessage<::sensors::Point3D>(Arena*);
template<> ::sensors::PressCountStreamData* Arena::CreateMaybeMessage<::sensors::PressCountStreamData>(Arena*);
template<> ::sensors::PressRequest* Arena::CreateMaybeMessage<::sensors::PressRequest>(Arena*);
template<> ::sensors::RadarCtrl* Arena::CreateMaybeMessage<::sensors::RadarCtrl>(Arena*);
template<> ::sensors::RadarFilter* Arena::CreateMaybeMessage<::sensors::RadarFilter>(Arena*);
template<> ::sensors::RadarPoint* Arena::CreateMaybeMessage<::sensors::RadarPoint>(Arena*);
template<> ::sensors::RadarPoints* Arena::CreateMaybeMessage<::sensors::RadarPoints>(Arena*);
template<> ::sensors::RampAssistStates* Arena::CreateMaybeMessage<::sensors::RampAssistStates>(Arena*);
template<> ::sensors::RampMode* Arena::CreateMaybeMessage<::sensors::RampMode>(Arena*);
template<> ::sensors::RemoteJsValues* Arena::CreateMaybeMessage<::sensors::RemoteJsValues>(Arena*);
template<> ::sensors::Response* Arena::CreateMaybeMessage<::sensors::Response>(Arena*);
template<> ::sensors::SeatPressure* Arena::CreateMaybeMessage<::sensors::SeatPressure>(Arena*);
template<> ::sensors::SpeedSetting* Arena::CreateMaybeMessage<::sensors::SpeedSetting>(Arena*);
template<> ::sensors::StartModeData* Arena::CreateMaybeMessage<::sensors::StartModeData>(Arena*);
template<> ::sensors::UltrasonicCtrl* Arena::CreateMaybeMessage<::sensors::UltrasonicCtrl>(Arena*);
template<> ::sensors::UltrasonicCurve* Arena::CreateMaybeMessage<::sensors::UltrasonicCurve>(Arena*);
template<> ::sensors::UltrasonicDistance* Arena::CreateMaybeMessage<::sensors::UltrasonicDistance>(Arena*);
template<> ::sensors::UltrasonicDistances* Arena::CreateMaybeMessage<::sensors::UltrasonicDistances>(Arena*);
template<> ::sensors::Vec3* Arena::CreateMaybeMessage<::sensors::Vec3>(Arena*);
template<> ::sensors::Vec4* Arena::CreateMaybeMessage<::sensors::Vec4>(Arena*);
template<> ::sensors::ZoneBoundaries* Arena::CreateMaybeMessage<::sensors::ZoneBoundaries>(Arena*);
template<> ::sensors::ZoneBoundary* Arena::CreateMaybeMessage<::sensors::ZoneBoundary>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensors {

enum AudioPlaybackRequest_RequestedPlayback : int {
  AudioPlaybackRequest_RequestedPlayback_ERROR_DISABLE = 0,
  AudioPlaybackRequest_RequestedPlayback_AudioPlaybackRequest_RequestedPlayback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioPlaybackRequest_RequestedPlayback_AudioPlaybackRequest_RequestedPlayback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioPlaybackRequest_RequestedPlayback_IsValid(int value);
constexpr AudioPlaybackRequest_RequestedPlayback AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_MIN = AudioPlaybackRequest_RequestedPlayback_ERROR_DISABLE;
constexpr AudioPlaybackRequest_RequestedPlayback AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_MAX = AudioPlaybackRequest_RequestedPlayback_ERROR_DISABLE;
constexpr int AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_ARRAYSIZE = AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioPlaybackRequest_RequestedPlayback_descriptor();
template<typename T>
inline const std::string& AudioPlaybackRequest_RequestedPlayback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioPlaybackRequest_RequestedPlayback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioPlaybackRequest_RequestedPlayback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioPlaybackRequest_RequestedPlayback_descriptor(), enum_t_value);
}
inline bool AudioPlaybackRequest_RequestedPlayback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPlaybackRequest_RequestedPlayback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioPlaybackRequest_RequestedPlayback>(
    AudioPlaybackRequest_RequestedPlayback_descriptor(), name, value);
}
enum StartModeData_StartModes : int {
  StartModeData_StartModes_UNKNOWN = 0,
  StartModeData_StartModes_NORMAL = 1,
  StartModeData_StartModes_AUTO = 2,
  StartModeData_StartModes_DISABLED = 3,
  StartModeData_StartModes_StartModeData_StartModes_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartModeData_StartModes_StartModeData_StartModes_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartModeData_StartModes_IsValid(int value);
constexpr StartModeData_StartModes StartModeData_StartModes_StartModes_MIN = StartModeData_StartModes_UNKNOWN;
constexpr StartModeData_StartModes StartModeData_StartModes_StartModes_MAX = StartModeData_StartModes_DISABLED;
constexpr int StartModeData_StartModes_StartModes_ARRAYSIZE = StartModeData_StartModes_StartModes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StartModeData_StartModes_descriptor();
template<typename T>
inline const std::string& StartModeData_StartModes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartModeData_StartModes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartModeData_StartModes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StartModeData_StartModes_descriptor(), enum_t_value);
}
inline bool StartModeData_StartModes_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StartModeData_StartModes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StartModeData_StartModes>(
    StartModeData_StartModes_descriptor(), name, value);
}
enum DFSeatEvent_EventGroup : int {
  DFSeatEvent_EventGroup_UNKNOWN_EVENT_GROUP = 0,
  DFSeatEvent_EventGroup_PRESSURE = 161,
  DFSeatEvent_EventGroup_WETNESS = 162,
  DFSeatEvent_EventGroup_INFLATION = 163,
  DFSeatEvent_EventGroup_DFSeatEvent_EventGroup_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DFSeatEvent_EventGroup_DFSeatEvent_EventGroup_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DFSeatEvent_EventGroup_IsValid(int value);
constexpr DFSeatEvent_EventGroup DFSeatEvent_EventGroup_EventGroup_MIN = DFSeatEvent_EventGroup_UNKNOWN_EVENT_GROUP;
constexpr DFSeatEvent_EventGroup DFSeatEvent_EventGroup_EventGroup_MAX = DFSeatEvent_EventGroup_INFLATION;
constexpr int DFSeatEvent_EventGroup_EventGroup_ARRAYSIZE = DFSeatEvent_EventGroup_EventGroup_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DFSeatEvent_EventGroup_descriptor();
template<typename T>
inline const std::string& DFSeatEvent_EventGroup_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DFSeatEvent_EventGroup>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DFSeatEvent_EventGroup_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DFSeatEvent_EventGroup_descriptor(), enum_t_value);
}
inline bool DFSeatEvent_EventGroup_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DFSeatEvent_EventGroup* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DFSeatEvent_EventGroup>(
    DFSeatEvent_EventGroup_descriptor(), name, value);
}
enum DFSeatEvent_EventType : int {
  DFSeatEvent_EventType_UNKNOWN_PRESSURE_EVENT_TYPE = 0,
  DFSeatEvent_EventType_OUT_OF_SEAT = 18,
  DFSeatEvent_EventType_PRESSURE_HIGH = 19,
  DFSeatEvent_EventType_PRESSURE_LOW = 20,
  DFSeatEvent_EventType_OFFLOAD = 21,
  DFSeatEvent_EventType_PRESSURE_OK = 22,
  DFSeatEvent_EventType_DFSeatEvent_EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DFSeatEvent_EventType_DFSeatEvent_EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DFSeatEvent_EventType_IsValid(int value);
constexpr DFSeatEvent_EventType DFSeatEvent_EventType_EventType_MIN = DFSeatEvent_EventType_UNKNOWN_PRESSURE_EVENT_TYPE;
constexpr DFSeatEvent_EventType DFSeatEvent_EventType_EventType_MAX = DFSeatEvent_EventType_PRESSURE_OK;
constexpr int DFSeatEvent_EventType_EventType_ARRAYSIZE = DFSeatEvent_EventType_EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DFSeatEvent_EventType_descriptor();
template<typename T>
inline const std::string& DFSeatEvent_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DFSeatEvent_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DFSeatEvent_EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DFSeatEvent_EventType_descriptor(), enum_t_value);
}
inline bool DFSeatEvent_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DFSeatEvent_EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DFSeatEvent_EventType>(
    DFSeatEvent_EventType_descriptor(), name, value);
}
enum Led_Leds : int {
  Led_Leds_UNKNOWN = 0,
  Led_Leds_SYSTEM_STATUS = 1,
  Led_Leds_SENSOR_OK = 2,
  Led_Leds_SENSOR_BLOCKED = 3,
  Led_Leds_SENSOR_ERROR = 4,
  Led_Leds_WIFI_CONNECTED = 5,
  Led_Leds_CELL_CONNECTED = 6,
  Led_Leds_BLUETOOTH_CONNECTED = 7,
  Led_Leds_Led_Leds_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Led_Leds_Led_Leds_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Led_Leds_IsValid(int value);
constexpr Led_Leds Led_Leds_Leds_MIN = Led_Leds_UNKNOWN;
constexpr Led_Leds Led_Leds_Leds_MAX = Led_Leds_BLUETOOTH_CONNECTED;
constexpr int Led_Leds_Leds_ARRAYSIZE = Led_Leds_Leds_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Led_Leds_descriptor();
template<typename T>
inline const std::string& Led_Leds_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Led_Leds>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Led_Leds_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Led_Leds_descriptor(), enum_t_value);
}
inline bool Led_Leds_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Led_Leds* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Led_Leds>(
    Led_Leds_descriptor(), name, value);
}
enum HmiState_States : int {
  HmiState_States_SETUP_APP_PULSE = 0,
  HmiState_States_REACTION_TEST_WAIT = 1,
  HmiState_States_REACTION_TEST_GO = 2,
  HmiState_States_SENSOR_SYSTEM_ERROR = 3,
  HmiState_States_NOMINAL_OFF = 4,
  HmiState_States_SENSOR_SYSTEM_OVERRIDE = 5,
  HmiState_States_LUCI_LOADING = 6,
  HmiState_States_SENSOR_BLOCKED = 9,
  HmiState_States_SYSTEM_OK = 10,
  HmiState_States_STABILITY_WARNING = 11,
  HmiState_States_STABILITY_DANGER = 12,
  HmiState_States_STABILITY_TIPPED = 13,
  HmiState_States_SENDING_LOGS = 14,
  HmiState_States_WIFI_SENDING = 15,
  HmiState_States_WIFI_AVAILABLE = 16,
  HmiState_States_CELL_SENDING = 17,
  HmiState_States_CELL_AVAILABLE = 18,
  HmiState_States_USER_KEY_LOW = 19,
  HmiState_States_USER_KEY_PRESENT = 20,
  HmiState_States_NO_ACTION = 21,
  HmiState_States_BUTTON_PRESSED = 22,
  HmiState_States_UPDATE_IN_PROGRESS = 23,
  HmiState_States_ALL_OFF = 24,
  HmiState_States_FLASH_LEDS = 25,
  HmiState_States_CHASE_LEDS = 26,
  HmiState_States_TEST_USER_KEY = 27,
  HmiState_States_TEST_WIFI = 28,
  HmiState_States_TEST_CELL = 29,
  HmiState_States_TEST_SENSOR_OK = 30,
  HmiState_States_TEST_SENSOR_WARNING = 31,
  HmiState_States_TEST_SENSOR_ERROR = 32,
  HmiState_States_TEST_LUCI_BUTTON = 33,
  HmiState_States_HmiState_States_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HmiState_States_HmiState_States_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HmiState_States_IsValid(int value);
constexpr HmiState_States HmiState_States_States_MIN = HmiState_States_SETUP_APP_PULSE;
constexpr HmiState_States HmiState_States_States_MAX = HmiState_States_TEST_LUCI_BUTTON;
constexpr int HmiState_States_States_ARRAYSIZE = HmiState_States_States_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HmiState_States_descriptor();
template<typename T>
inline const std::string& HmiState_States_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HmiState_States>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HmiState_States_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HmiState_States_descriptor(), enum_t_value);
}
inline bool HmiState_States_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HmiState_States* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HmiState_States>(
    HmiState_States_descriptor(), name, value);
}
enum HmiStreamData_ButtonState : int {
  HmiStreamData_ButtonState_PRESSED = 0,
  HmiStreamData_ButtonState_RELEASED = 1,
  HmiStreamData_ButtonState_HmiStreamData_ButtonState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HmiStreamData_ButtonState_HmiStreamData_ButtonState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HmiStreamData_ButtonState_IsValid(int value);
constexpr HmiStreamData_ButtonState HmiStreamData_ButtonState_ButtonState_MIN = HmiStreamData_ButtonState_PRESSED;
constexpr HmiStreamData_ButtonState HmiStreamData_ButtonState_ButtonState_MAX = HmiStreamData_ButtonState_RELEASED;
constexpr int HmiStreamData_ButtonState_ButtonState_ARRAYSIZE = HmiStreamData_ButtonState_ButtonState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HmiStreamData_ButtonState_descriptor();
template<typename T>
inline const std::string& HmiStreamData_ButtonState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HmiStreamData_ButtonState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HmiStreamData_ButtonState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HmiStreamData_ButtonState_descriptor(), enum_t_value);
}
inline bool HmiStreamData_ButtonState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HmiStreamData_ButtonState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HmiStreamData_ButtonState>(
    HmiStreamData_ButtonState_descriptor(), name, value);
}
enum UltrasonicCtrl_Board : int {
  UltrasonicCtrl_Board_UNKNOWN = 0,
  UltrasonicCtrl_Board_MPU = 1,
  UltrasonicCtrl_Board_IO_B_LEFT = 2,
  UltrasonicCtrl_Board_IO_B_RIGHT = 3,
  UltrasonicCtrl_Board_UltrasonicCtrl_Board_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UltrasonicCtrl_Board_UltrasonicCtrl_Board_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UltrasonicCtrl_Board_IsValid(int value);
constexpr UltrasonicCtrl_Board UltrasonicCtrl_Board_Board_MIN = UltrasonicCtrl_Board_UNKNOWN;
constexpr UltrasonicCtrl_Board UltrasonicCtrl_Board_Board_MAX = UltrasonicCtrl_Board_IO_B_RIGHT;
constexpr int UltrasonicCtrl_Board_Board_ARRAYSIZE = UltrasonicCtrl_Board_Board_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UltrasonicCtrl_Board_descriptor();
template<typename T>
inline const std::string& UltrasonicCtrl_Board_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UltrasonicCtrl_Board>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UltrasonicCtrl_Board_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UltrasonicCtrl_Board_descriptor(), enum_t_value);
}
inline bool UltrasonicCtrl_Board_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UltrasonicCtrl_Board* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UltrasonicCtrl_Board>(
    UltrasonicCtrl_Board_descriptor(), name, value);
}
enum UltrasonicDistance_Board : int {
  UltrasonicDistance_Board_UNKNOWN = 0,
  UltrasonicDistance_Board_MPU = 1,
  UltrasonicDistance_Board_IO_B_LEFT = 2,
  UltrasonicDistance_Board_IO_B_RIGHT = 3,
  UltrasonicDistance_Board_UltrasonicDistance_Board_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UltrasonicDistance_Board_UltrasonicDistance_Board_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UltrasonicDistance_Board_IsValid(int value);
constexpr UltrasonicDistance_Board UltrasonicDistance_Board_Board_MIN = UltrasonicDistance_Board_UNKNOWN;
constexpr UltrasonicDistance_Board UltrasonicDistance_Board_Board_MAX = UltrasonicDistance_Board_IO_B_RIGHT;
constexpr int UltrasonicDistance_Board_Board_ARRAYSIZE = UltrasonicDistance_Board_Board_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UltrasonicDistance_Board_descriptor();
template<typename T>
inline const std::string& UltrasonicDistance_Board_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UltrasonicDistance_Board>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UltrasonicDistance_Board_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UltrasonicDistance_Board_descriptor(), enum_t_value);
}
inline bool UltrasonicDistance_Board_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UltrasonicDistance_Board* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UltrasonicDistance_Board>(
    UltrasonicDistance_Board_descriptor(), name, value);
}
enum UltrasonicCurve_Board : int {
  UltrasonicCurve_Board_UNKNOWN = 0,
  UltrasonicCurve_Board_MPU = 1,
  UltrasonicCurve_Board_IO_B_LEFT = 2,
  UltrasonicCurve_Board_IO_B_RIGHT = 3,
  UltrasonicCurve_Board_UltrasonicCurve_Board_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UltrasonicCurve_Board_UltrasonicCurve_Board_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UltrasonicCurve_Board_IsValid(int value);
constexpr UltrasonicCurve_Board UltrasonicCurve_Board_Board_MIN = UltrasonicCurve_Board_UNKNOWN;
constexpr UltrasonicCurve_Board UltrasonicCurve_Board_Board_MAX = UltrasonicCurve_Board_IO_B_RIGHT;
constexpr int UltrasonicCurve_Board_Board_ARRAYSIZE = UltrasonicCurve_Board_Board_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UltrasonicCurve_Board_descriptor();
template<typename T>
inline const std::string& UltrasonicCurve_Board_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UltrasonicCurve_Board>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UltrasonicCurve_Board_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UltrasonicCurve_Board_descriptor(), enum_t_value);
}
inline bool UltrasonicCurve_Board_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UltrasonicCurve_Board* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UltrasonicCurve_Board>(
    UltrasonicCurve_Board_descriptor(), name, value);
}
enum RadarFilter_Filter : int {
  RadarFilter_Filter_RANGE_CHOP = 0,
  RadarFilter_Filter_ORIGIN = 1,
  RadarFilter_Filter_FOV = 2,
  RadarFilter_Filter_PEAK = 3,
  RadarFilter_Filter_STICKY = 4,
  RadarFilter_Filter_EXTRA_STICKY = 5,
  RadarFilter_Filter_TRANSFORMS = 6,
  RadarFilter_Filter_ADAM = 7,
  RadarFilter_Filter_RadarFilter_Filter_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RadarFilter_Filter_RadarFilter_Filter_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RadarFilter_Filter_IsValid(int value);
constexpr RadarFilter_Filter RadarFilter_Filter_Filter_MIN = RadarFilter_Filter_RANGE_CHOP;
constexpr RadarFilter_Filter RadarFilter_Filter_Filter_MAX = RadarFilter_Filter_ADAM;
constexpr int RadarFilter_Filter_Filter_ARRAYSIZE = RadarFilter_Filter_Filter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadarFilter_Filter_descriptor();
template<typename T>
inline const std::string& RadarFilter_Filter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RadarFilter_Filter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RadarFilter_Filter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RadarFilter_Filter_descriptor(), enum_t_value);
}
inline bool RadarFilter_Filter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RadarFilter_Filter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RadarFilter_Filter>(
    RadarFilter_Filter_descriptor(), name, value);
}
enum RadarCtrl_Radar : int {
  RadarCtrl_Radar_UNKNOWN = 0,
  RadarCtrl_Radar_LEFT = 1,
  RadarCtrl_Radar_RIGHT = 2,
  RadarCtrl_Radar_FRONT = 3,
  RadarCtrl_Radar_RadarCtrl_Radar_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RadarCtrl_Radar_RadarCtrl_Radar_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RadarCtrl_Radar_IsValid(int value);
constexpr RadarCtrl_Radar RadarCtrl_Radar_Radar_MIN = RadarCtrl_Radar_UNKNOWN;
constexpr RadarCtrl_Radar RadarCtrl_Radar_Radar_MAX = RadarCtrl_Radar_FRONT;
constexpr int RadarCtrl_Radar_Radar_ARRAYSIZE = RadarCtrl_Radar_Radar_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadarCtrl_Radar_descriptor();
template<typename T>
inline const std::string& RadarCtrl_Radar_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RadarCtrl_Radar>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RadarCtrl_Radar_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RadarCtrl_Radar_descriptor(), enum_t_value);
}
inline bool RadarCtrl_Radar_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RadarCtrl_Radar* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RadarCtrl_Radar>(
    RadarCtrl_Radar_descriptor(), name, value);
}
enum RadarPoints_Radar : int {
  RadarPoints_Radar_UNKNOWN = 0,
  RadarPoints_Radar_LEFT = 1,
  RadarPoints_Radar_RIGHT = 2,
  RadarPoints_Radar_FRONT = 3,
  RadarPoints_Radar_RadarPoints_Radar_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RadarPoints_Radar_RadarPoints_Radar_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RadarPoints_Radar_IsValid(int value);
constexpr RadarPoints_Radar RadarPoints_Radar_Radar_MIN = RadarPoints_Radar_UNKNOWN;
constexpr RadarPoints_Radar RadarPoints_Radar_Radar_MAX = RadarPoints_Radar_FRONT;
constexpr int RadarPoints_Radar_Radar_ARRAYSIZE = RadarPoints_Radar_Radar_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadarPoints_Radar_descriptor();
template<typename T>
inline const std::string& RadarPoints_Radar_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RadarPoints_Radar>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RadarPoints_Radar_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RadarPoints_Radar_descriptor(), enum_t_value);
}
inline bool RadarPoints_Radar_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RadarPoints_Radar* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RadarPoints_Radar>(
    RadarPoints_Radar_descriptor(), name, value);
}
enum ImuData_CalibrationStatus : int {
  ImuData_CalibrationStatus_NOT_CALIBRATED = 0,
  ImuData_CalibrationStatus_IN_PROGRESS = 1,
  ImuData_CalibrationStatus_USABLE = 2,
  ImuData_CalibrationStatus_COMPLETE = 3,
  ImuData_CalibrationStatus_ImuData_CalibrationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImuData_CalibrationStatus_ImuData_CalibrationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImuData_CalibrationStatus_IsValid(int value);
constexpr ImuData_CalibrationStatus ImuData_CalibrationStatus_CalibrationStatus_MIN = ImuData_CalibrationStatus_NOT_CALIBRATED;
constexpr ImuData_CalibrationStatus ImuData_CalibrationStatus_CalibrationStatus_MAX = ImuData_CalibrationStatus_COMPLETE;
constexpr int ImuData_CalibrationStatus_CalibrationStatus_ARRAYSIZE = ImuData_CalibrationStatus_CalibrationStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImuData_CalibrationStatus_descriptor();
template<typename T>
inline const std::string& ImuData_CalibrationStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImuData_CalibrationStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImuData_CalibrationStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImuData_CalibrationStatus_descriptor(), enum_t_value);
}
inline bool ImuData_CalibrationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImuData_CalibrationStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImuData_CalibrationStatus>(
    ImuData_CalibrationStatus_descriptor(), name, value);
}
enum GPSData_quality_t : int {
  GPSData_quality_t_no_fix = 0,
  GPSData_quality_t_standard_gps_2d_3d = 1,
  GPSData_quality_t_differential_gps = 2,
  GPSData_quality_t_rtk_fixed_solution = 4,
  GPSData_quality_t_rtk_float_solution = 5,
  GPSData_quality_t_estimated_dr = 6,
  GPSData_quality_t_GPSData_quality_t_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GPSData_quality_t_GPSData_quality_t_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GPSData_quality_t_IsValid(int value);
constexpr GPSData_quality_t GPSData_quality_t_quality_t_MIN = GPSData_quality_t_no_fix;
constexpr GPSData_quality_t GPSData_quality_t_quality_t_MAX = GPSData_quality_t_estimated_dr;
constexpr int GPSData_quality_t_quality_t_ARRAYSIZE = GPSData_quality_t_quality_t_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GPSData_quality_t_descriptor();
template<typename T>
inline const std::string& GPSData_quality_t_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GPSData_quality_t>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GPSData_quality_t_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GPSData_quality_t_descriptor(), enum_t_value);
}
inline bool GPSData_quality_t_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPSData_quality_t* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GPSData_quality_t>(
    GPSData_quality_t_descriptor(), name, value);
}
enum Imu : int {
  UNKNOWN = 0,
  FOOTPLATE = 1,
  MPU = 2,
  ALL = 3,
  Imu_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Imu_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Imu_IsValid(int value);
constexpr Imu Imu_MIN = UNKNOWN;
constexpr Imu Imu_MAX = ALL;
constexpr int Imu_ARRAYSIZE = Imu_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Imu_descriptor();
template<typename T>
inline const std::string& Imu_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Imu>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Imu_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Imu_descriptor(), enum_t_value);
}
inline bool Imu_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Imu* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Imu>(
    Imu_descriptor(), name, value);
}
enum DriveMode : int {
  USER = 0,
  ENGAGED = 1,
  AUTONOMOUS = 2,
  DriveMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriveMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriveMode_IsValid(int value);
constexpr DriveMode DriveMode_MIN = USER;
constexpr DriveMode DriveMode_MAX = AUTONOMOUS;
constexpr int DriveMode_ARRAYSIZE = DriveMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DriveMode_descriptor();
template<typename T>
inline const std::string& DriveMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriveMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriveMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DriveMode_descriptor(), enum_t_value);
}
inline bool DriveMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriveMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DriveMode>(
    DriveMode_descriptor(), name, value);
}
// ===================================================================

class AudioPlaybackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.AudioPlaybackRequest) */ {
 public:
  inline AudioPlaybackRequest() : AudioPlaybackRequest(nullptr) {}
  ~AudioPlaybackRequest() override;
  explicit constexpr AudioPlaybackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioPlaybackRequest(const AudioPlaybackRequest& from);
  AudioPlaybackRequest(AudioPlaybackRequest&& from) noexcept
    : AudioPlaybackRequest() {
    *this = ::std::move(from);
  }

  inline AudioPlaybackRequest& operator=(const AudioPlaybackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioPlaybackRequest& operator=(AudioPlaybackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioPlaybackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioPlaybackRequest* internal_default_instance() {
    return reinterpret_cast<const AudioPlaybackRequest*>(
               &_AudioPlaybackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AudioPlaybackRequest& a, AudioPlaybackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioPlaybackRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioPlaybackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioPlaybackRequest* New() const final {
    return new AudioPlaybackRequest();
  }

  AudioPlaybackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioPlaybackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioPlaybackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioPlaybackRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioPlaybackRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.AudioPlaybackRequest";
  }
  protected:
  explicit AudioPlaybackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AudioPlaybackRequest_RequestedPlayback RequestedPlayback;
  static constexpr RequestedPlayback ERROR_DISABLE =
    AudioPlaybackRequest_RequestedPlayback_ERROR_DISABLE;
  static inline bool RequestedPlayback_IsValid(int value) {
    return AudioPlaybackRequest_RequestedPlayback_IsValid(value);
  }
  static constexpr RequestedPlayback RequestedPlayback_MIN =
    AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_MIN;
  static constexpr RequestedPlayback RequestedPlayback_MAX =
    AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_MAX;
  static constexpr int RequestedPlayback_ARRAYSIZE =
    AudioPlaybackRequest_RequestedPlayback_RequestedPlayback_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RequestedPlayback_descriptor() {
    return AudioPlaybackRequest_RequestedPlayback_descriptor();
  }
  template<typename T>
  static inline const std::string& RequestedPlayback_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RequestedPlayback>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RequestedPlayback_Name.");
    return AudioPlaybackRequest_RequestedPlayback_Name(enum_t_value);
  }
  static inline bool RequestedPlayback_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RequestedPlayback* value) {
    return AudioPlaybackRequest_RequestedPlayback_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestedPlaybackFieldNumber = 1,
  };
  // .sensors.AudioPlaybackRequest.RequestedPlayback requested_playback = 1;
  void clear_requested_playback();
  ::sensors::AudioPlaybackRequest_RequestedPlayback requested_playback() const;
  void set_requested_playback(::sensors::AudioPlaybackRequest_RequestedPlayback value);
  private:
  ::sensors::AudioPlaybackRequest_RequestedPlayback _internal_requested_playback() const;
  void _internal_set_requested_playback(::sensors::AudioPlaybackRequest_RequestedPlayback value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.AudioPlaybackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int requested_playback_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class PressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.PressRequest) */ {
 public:
  inline PressRequest() : PressRequest(nullptr) {}
  ~PressRequest() override;
  explicit constexpr PressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PressRequest(const PressRequest& from);
  PressRequest(PressRequest&& from) noexcept
    : PressRequest() {
    *this = ::std::move(from);
  }

  inline PressRequest& operator=(const PressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PressRequest& operator=(PressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PressRequest* internal_default_instance() {
    return reinterpret_cast<const PressRequest*>(
               &_PressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PressRequest& a, PressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PressRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PressRequest* New() const final {
    return new PressRequest();
  }

  PressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PressRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PressRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.PressRequest";
  }
  protected:
  explicit PressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRampAssistFieldNumber = 1,
  };
  // bool ramp_assist = 1;
  void clear_ramp_assist();
  bool ramp_assist() const;
  void set_ramp_assist(bool value);
  private:
  bool _internal_ramp_assist() const;
  void _internal_set_ramp_assist(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.PressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ramp_assist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ZoneBoundary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ZoneBoundary) */ {
 public:
  inline ZoneBoundary() : ZoneBoundary(nullptr) {}
  ~ZoneBoundary() override;
  explicit constexpr ZoneBoundary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZoneBoundary(const ZoneBoundary& from);
  ZoneBoundary(ZoneBoundary&& from) noexcept
    : ZoneBoundary() {
    *this = ::std::move(from);
  }

  inline ZoneBoundary& operator=(const ZoneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneBoundary& operator=(ZoneBoundary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneBoundary& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneBoundary* internal_default_instance() {
    return reinterpret_cast<const ZoneBoundary*>(
               &_ZoneBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ZoneBoundary& a, ZoneBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneBoundary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneBoundary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ZoneBoundary* New() const final {
    return new ZoneBoundary();
  }

  ZoneBoundary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ZoneBoundary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZoneBoundary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ZoneBoundary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoneBoundary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ZoneBoundary";
  }
  protected:
  explicit ZoneBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 1,
    kCriticalPointFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // repeated .sensors.Point2D polygon = 1;
  int polygon_size() const;
  private:
  int _internal_polygon_size() const;
  public:
  void clear_polygon();
  ::sensors::Point2D* mutable_polygon(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
      mutable_polygon();
  private:
  const ::sensors::Point2D& _internal_polygon(int index) const;
  ::sensors::Point2D* _internal_add_polygon();
  public:
  const ::sensors::Point2D& polygon(int index) const;
  ::sensors::Point2D* add_polygon();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
      polygon() const;

  // repeated .sensors.Point2D critical_point = 2;
  int critical_point_size() const;
  private:
  int _internal_critical_point_size() const;
  public:
  void clear_critical_point();
  ::sensors::Point2D* mutable_critical_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
      mutable_critical_point();
  private:
  const ::sensors::Point2D& _internal_critical_point(int index) const;
  ::sensors::Point2D* _internal_add_critical_point();
  public:
  const ::sensors::Point2D& critical_point(int index) const;
  ::sensors::Point2D* add_critical_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
      critical_point() const;

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:sensors.ZoneBoundary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D > polygon_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D > critical_point_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ZoneBoundaries final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ZoneBoundaries) */ {
 public:
  inline ZoneBoundaries() : ZoneBoundaries(nullptr) {}
  ~ZoneBoundaries() override;
  explicit constexpr ZoneBoundaries(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZoneBoundaries(const ZoneBoundaries& from);
  ZoneBoundaries(ZoneBoundaries&& from) noexcept
    : ZoneBoundaries() {
    *this = ::std::move(from);
  }

  inline ZoneBoundaries& operator=(const ZoneBoundaries& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneBoundaries& operator=(ZoneBoundaries&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneBoundaries& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneBoundaries* internal_default_instance() {
    return reinterpret_cast<const ZoneBoundaries*>(
               &_ZoneBoundaries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ZoneBoundaries& a, ZoneBoundaries& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneBoundaries* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneBoundaries* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ZoneBoundaries* New() const final {
    return new ZoneBoundaries();
  }

  ZoneBoundaries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ZoneBoundaries>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZoneBoundaries& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ZoneBoundaries& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoneBoundaries* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ZoneBoundaries";
  }
  protected:
  explicit ZoneBoundaries(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoneBoundaryFieldNumber = 1,
  };
  // repeated .sensors.ZoneBoundary zone_boundary = 1;
  int zone_boundary_size() const;
  private:
  int _internal_zone_boundary_size() const;
  public:
  void clear_zone_boundary();
  ::sensors::ZoneBoundary* mutable_zone_boundary(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::ZoneBoundary >*
      mutable_zone_boundary();
  private:
  const ::sensors::ZoneBoundary& _internal_zone_boundary(int index) const;
  ::sensors::ZoneBoundary* _internal_add_zone_boundary();
  public:
  const ::sensors::ZoneBoundary& zone_boundary(int index) const;
  ::sensors::ZoneBoundary* add_zone_boundary();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::ZoneBoundary >&
      zone_boundary() const;

  // @@protoc_insertion_point(class_scope:sensors.ZoneBoundaries)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::ZoneBoundary > zone_boundary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class BlockedZone final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.BlockedZone) */ {
 public:
  inline BlockedZone() : BlockedZone(nullptr) {}
  ~BlockedZone() override;
  explicit constexpr BlockedZone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockedZone(const BlockedZone& from);
  BlockedZone(BlockedZone&& from) noexcept
    : BlockedZone() {
    *this = ::std::move(from);
  }

  inline BlockedZone& operator=(const BlockedZone& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockedZone& operator=(BlockedZone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockedZone& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockedZone* internal_default_instance() {
    return reinterpret_cast<const BlockedZone*>(
               &_BlockedZone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlockedZone& a, BlockedZone& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockedZone* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockedZone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockedZone* New() const final {
    return new BlockedZone();
  }

  BlockedZone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockedZone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockedZone& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockedZone& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockedZone* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.BlockedZone";
  }
  protected:
  explicit BlockedZone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kSensorFieldNumber = 2,
  };
  // repeated .sensors.Point2D points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::sensors::Point2D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
      mutable_points();
  private:
  const ::sensors::Point2D& _internal_points(int index) const;
  ::sensors::Point2D* _internal_add_points();
  public:
  const ::sensors::Point2D& points(int index) const;
  ::sensors::Point2D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
      points() const;

  // string sensor = 2;
  void clear_sensor();
  const std::string& sensor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor();
  PROTOBUF_MUST_USE_RESULT std::string* release_sensor();
  void set_allocated_sensor(std::string* sensor);
  private:
  const std::string& _internal_sensor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor(const std::string& value);
  std::string* _internal_mutable_sensor();
  public:

  // @@protoc_insertion_point(class_scope:sensors.BlockedZone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D > points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class BlockedZones final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.BlockedZones) */ {
 public:
  inline BlockedZones() : BlockedZones(nullptr) {}
  ~BlockedZones() override;
  explicit constexpr BlockedZones(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockedZones(const BlockedZones& from);
  BlockedZones(BlockedZones&& from) noexcept
    : BlockedZones() {
    *this = ::std::move(from);
  }

  inline BlockedZones& operator=(const BlockedZones& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockedZones& operator=(BlockedZones&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockedZones& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockedZones* internal_default_instance() {
    return reinterpret_cast<const BlockedZones*>(
               &_BlockedZones_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlockedZones& a, BlockedZones& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockedZones* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockedZones* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockedZones* New() const final {
    return new BlockedZones();
  }

  BlockedZones* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockedZones>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockedZones& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockedZones& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockedZones* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.BlockedZones";
  }
  protected:
  explicit BlockedZones(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockedZonesFieldNumber = 1,
  };
  // repeated .sensors.BlockedZone blocked_zones = 1;
  int blocked_zones_size() const;
  private:
  int _internal_blocked_zones_size() const;
  public:
  void clear_blocked_zones();
  ::sensors::BlockedZone* mutable_blocked_zones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::BlockedZone >*
      mutable_blocked_zones();
  private:
  const ::sensors::BlockedZone& _internal_blocked_zones(int index) const;
  ::sensors::BlockedZone* _internal_add_blocked_zones();
  public:
  const ::sensors::BlockedZone& blocked_zones(int index) const;
  ::sensors::BlockedZone* add_blocked_zones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::BlockedZone >&
      blocked_zones() const;

  // @@protoc_insertion_point(class_scope:sensors.BlockedZones)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::BlockedZone > blocked_zones_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class JoystickRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.JoystickRange) */ {
 public:
  inline JoystickRange() : JoystickRange(nullptr) {}
  ~JoystickRange() override;
  explicit constexpr JoystickRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoystickRange(const JoystickRange& from);
  JoystickRange(JoystickRange&& from) noexcept
    : JoystickRange() {
    *this = ::std::move(from);
  }

  inline JoystickRange& operator=(const JoystickRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoystickRange& operator=(JoystickRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoystickRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoystickRange* internal_default_instance() {
    return reinterpret_cast<const JoystickRange*>(
               &_JoystickRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JoystickRange& a, JoystickRange& b) {
    a.Swap(&b);
  }
  inline void Swap(JoystickRange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoystickRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoystickRange* New() const final {
    return new JoystickRange();
  }

  JoystickRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoystickRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoystickRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoystickRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoystickRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.JoystickRange";
  }
  protected:
  explicit JoystickRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // float begin = 1;
  void clear_begin();
  float begin() const;
  void set_begin(float value);
  private:
  float _internal_begin() const;
  void _internal_set_begin(float value);
  public:

  // float end = 2;
  void clear_end();
  float end() const;
  void set_end(float value);
  private:
  float _internal_end() const;
  void _internal_set_end(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.JoystickRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float begin_;
  float end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class JoystickRanges final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.JoystickRanges) */ {
 public:
  inline JoystickRanges() : JoystickRanges(nullptr) {}
  ~JoystickRanges() override;
  explicit constexpr JoystickRanges(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoystickRanges(const JoystickRanges& from);
  JoystickRanges(JoystickRanges&& from) noexcept
    : JoystickRanges() {
    *this = ::std::move(from);
  }

  inline JoystickRanges& operator=(const JoystickRanges& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoystickRanges& operator=(JoystickRanges&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoystickRanges& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoystickRanges* internal_default_instance() {
    return reinterpret_cast<const JoystickRanges*>(
               &_JoystickRanges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(JoystickRanges& a, JoystickRanges& b) {
    a.Swap(&b);
  }
  inline void Swap(JoystickRanges* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoystickRanges* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoystickRanges* New() const final {
    return new JoystickRanges();
  }

  JoystickRanges* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoystickRanges>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoystickRanges& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoystickRanges& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoystickRanges* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.JoystickRanges";
  }
  protected:
  explicit JoystickRanges(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoystickRangesFieldNumber = 1,
  };
  // repeated .sensors.JoystickRange joystick_ranges = 1;
  int joystick_ranges_size() const;
  private:
  int _internal_joystick_ranges_size() const;
  public:
  void clear_joystick_ranges();
  ::sensors::JoystickRange* mutable_joystick_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::JoystickRange >*
      mutable_joystick_ranges();
  private:
  const ::sensors::JoystickRange& _internal_joystick_ranges(int index) const;
  ::sensors::JoystickRange* _internal_add_joystick_ranges();
  public:
  const ::sensors::JoystickRange& joystick_ranges(int index) const;
  ::sensors::JoystickRange* add_joystick_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::JoystickRange >&
      joystick_ranges() const;

  // @@protoc_insertion_point(class_scope:sensors.JoystickRanges)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::JoystickRange > joystick_ranges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class StartModeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.StartModeData) */ {
 public:
  inline StartModeData() : StartModeData(nullptr) {}
  ~StartModeData() override;
  explicit constexpr StartModeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartModeData(const StartModeData& from);
  StartModeData(StartModeData&& from) noexcept
    : StartModeData() {
    *this = ::std::move(from);
  }

  inline StartModeData& operator=(const StartModeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartModeData& operator=(StartModeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartModeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartModeData* internal_default_instance() {
    return reinterpret_cast<const StartModeData*>(
               &_StartModeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StartModeData& a, StartModeData& b) {
    a.Swap(&b);
  }
  inline void Swap(StartModeData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartModeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartModeData* New() const final {
    return new StartModeData();
  }

  StartModeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartModeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartModeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartModeData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartModeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.StartModeData";
  }
  protected:
  explicit StartModeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StartModeData_StartModes StartModes;
  static constexpr StartModes UNKNOWN =
    StartModeData_StartModes_UNKNOWN;
  static constexpr StartModes NORMAL =
    StartModeData_StartModes_NORMAL;
  static constexpr StartModes AUTO =
    StartModeData_StartModes_AUTO;
  static constexpr StartModes DISABLED =
    StartModeData_StartModes_DISABLED;
  static inline bool StartModes_IsValid(int value) {
    return StartModeData_StartModes_IsValid(value);
  }
  static constexpr StartModes StartModes_MIN =
    StartModeData_StartModes_StartModes_MIN;
  static constexpr StartModes StartModes_MAX =
    StartModeData_StartModes_StartModes_MAX;
  static constexpr int StartModes_ARRAYSIZE =
    StartModeData_StartModes_StartModes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StartModes_descriptor() {
    return StartModeData_StartModes_descriptor();
  }
  template<typename T>
  static inline const std::string& StartModes_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StartModes>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StartModes_Name.");
    return StartModeData_StartModes_Name(enum_t_value);
  }
  static inline bool StartModes_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StartModes* value) {
    return StartModeData_StartModes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMissingDevicesFieldNumber = 2,
    kModeFieldNumber = 1,
  };
  // repeated string missing_devices = 2;
  int missing_devices_size() const;
  private:
  int _internal_missing_devices_size() const;
  public:
  void clear_missing_devices();
  const std::string& missing_devices(int index) const;
  std::string* mutable_missing_devices(int index);
  void set_missing_devices(int index, const std::string& value);
  void set_missing_devices(int index, std::string&& value);
  void set_missing_devices(int index, const char* value);
  void set_missing_devices(int index, const char* value, size_t size);
  std::string* add_missing_devices();
  void add_missing_devices(const std::string& value);
  void add_missing_devices(std::string&& value);
  void add_missing_devices(const char* value);
  void add_missing_devices(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& missing_devices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_missing_devices();
  private:
  const std::string& _internal_missing_devices(int index) const;
  std::string* _internal_add_missing_devices();
  public:

  // .sensors.StartModeData.StartModes mode = 1;
  void clear_mode();
  ::sensors::StartModeData_StartModes mode() const;
  void set_mode(::sensors::StartModeData_StartModes value);
  private:
  ::sensors::StartModeData_StartModes _internal_mode() const;
  void _internal_set_mode(::sensors::StartModeData_StartModes value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.StartModeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> missing_devices_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return new Response();
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 1,
    kReturnCodeFieldNumber = 2,
  };
  // string reply = 1;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_MUST_USE_RESULT std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // int32 return_code = 2;
  void clear_return_code();
  ::PROTOBUF_NAMESPACE_ID::int32 return_code() const;
  void set_return_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_return_code() const;
  void _internal_set_return_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
  ::PROTOBUF_NAMESPACE_ID::int32 return_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class DFParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.DFParameters) */ {
 public:
  inline DFParameters() : DFParameters(nullptr) {}
  ~DFParameters() override;
  explicit constexpr DFParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DFParameters(const DFParameters& from);
  DFParameters(DFParameters&& from) noexcept
    : DFParameters() {
    *this = ::std::move(from);
  }

  inline DFParameters& operator=(const DFParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline DFParameters& operator=(DFParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DFParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const DFParameters* internal_default_instance() {
    return reinterpret_cast<const DFParameters*>(
               &_DFParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DFParameters& a, DFParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(DFParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DFParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DFParameters* New() const final {
    return new DFParameters();
  }

  DFParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DFParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DFParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DFParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DFParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.DFParameters";
  }
  protected:
  explicit DFParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDfTimestampFieldNumber = 1,
    kTargetPressureFieldNumber = 2,
    kHighPressureFieldNumber = 3,
    kLowPressureFieldNumber = 4,
    kInSeatPressureFieldNumber = 5,
    kOffLoadPressureFieldNumber = 6,
    kUsbUpdatePeriodFieldNumber = 7,
    kCapUpdatePeriodFieldNumber = 8,
  };
  // uint32 df_timestamp = 1;
  void clear_df_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 df_timestamp() const;
  void set_df_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_df_timestamp() const;
  void _internal_set_df_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float target_pressure = 2;
  void clear_target_pressure();
  float target_pressure() const;
  void set_target_pressure(float value);
  private:
  float _internal_target_pressure() const;
  void _internal_set_target_pressure(float value);
  public:

  // float high_pressure = 3;
  void clear_high_pressure();
  float high_pressure() const;
  void set_high_pressure(float value);
  private:
  float _internal_high_pressure() const;
  void _internal_set_high_pressure(float value);
  public:

  // float low_pressure = 4;
  void clear_low_pressure();
  float low_pressure() const;
  void set_low_pressure(float value);
  private:
  float _internal_low_pressure() const;
  void _internal_set_low_pressure(float value);
  public:

  // float in_seat_pressure = 5;
  void clear_in_seat_pressure();
  float in_seat_pressure() const;
  void set_in_seat_pressure(float value);
  private:
  float _internal_in_seat_pressure() const;
  void _internal_set_in_seat_pressure(float value);
  public:

  // float off_load_pressure = 6;
  void clear_off_load_pressure();
  float off_load_pressure() const;
  void set_off_load_pressure(float value);
  private:
  float _internal_off_load_pressure() const;
  void _internal_set_off_load_pressure(float value);
  public:

  // int32 usb_update_period = 7;
  void clear_usb_update_period();
  ::PROTOBUF_NAMESPACE_ID::int32 usb_update_period() const;
  void set_usb_update_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usb_update_period() const;
  void _internal_set_usb_update_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cap_update_period = 8;
  void clear_cap_update_period();
  ::PROTOBUF_NAMESPACE_ID::int32 cap_update_period() const;
  void set_cap_update_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cap_update_period() const;
  void _internal_set_cap_update_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.DFParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 df_timestamp_;
  float target_pressure_;
  float high_pressure_;
  float low_pressure_;
  float in_seat_pressure_;
  float off_load_pressure_;
  ::PROTOBUF_NAMESPACE_ID::int32 usb_update_period_;
  ::PROTOBUF_NAMESPACE_ID::int32 cap_update_period_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class DFSeatEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.DFSeatEvent) */ {
 public:
  inline DFSeatEvent() : DFSeatEvent(nullptr) {}
  ~DFSeatEvent() override;
  explicit constexpr DFSeatEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DFSeatEvent(const DFSeatEvent& from);
  DFSeatEvent(DFSeatEvent&& from) noexcept
    : DFSeatEvent() {
    *this = ::std::move(from);
  }

  inline DFSeatEvent& operator=(const DFSeatEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DFSeatEvent& operator=(DFSeatEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DFSeatEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DFSeatEvent* internal_default_instance() {
    return reinterpret_cast<const DFSeatEvent*>(
               &_DFSeatEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DFSeatEvent& a, DFSeatEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DFSeatEvent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DFSeatEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DFSeatEvent* New() const final {
    return new DFSeatEvent();
  }

  DFSeatEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DFSeatEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DFSeatEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DFSeatEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DFSeatEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.DFSeatEvent";
  }
  protected:
  explicit DFSeatEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DFSeatEvent_EventGroup EventGroup;
  static constexpr EventGroup UNKNOWN_EVENT_GROUP =
    DFSeatEvent_EventGroup_UNKNOWN_EVENT_GROUP;
  static constexpr EventGroup PRESSURE =
    DFSeatEvent_EventGroup_PRESSURE;
  static constexpr EventGroup WETNESS =
    DFSeatEvent_EventGroup_WETNESS;
  static constexpr EventGroup INFLATION =
    DFSeatEvent_EventGroup_INFLATION;
  static inline bool EventGroup_IsValid(int value) {
    return DFSeatEvent_EventGroup_IsValid(value);
  }
  static constexpr EventGroup EventGroup_MIN =
    DFSeatEvent_EventGroup_EventGroup_MIN;
  static constexpr EventGroup EventGroup_MAX =
    DFSeatEvent_EventGroup_EventGroup_MAX;
  static constexpr int EventGroup_ARRAYSIZE =
    DFSeatEvent_EventGroup_EventGroup_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EventGroup_descriptor() {
    return DFSeatEvent_EventGroup_descriptor();
  }
  template<typename T>
  static inline const std::string& EventGroup_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventGroup>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventGroup_Name.");
    return DFSeatEvent_EventGroup_Name(enum_t_value);
  }
  static inline bool EventGroup_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventGroup* value) {
    return DFSeatEvent_EventGroup_Parse(name, value);
  }

  typedef DFSeatEvent_EventType EventType;
  static constexpr EventType UNKNOWN_PRESSURE_EVENT_TYPE =
    DFSeatEvent_EventType_UNKNOWN_PRESSURE_EVENT_TYPE;
  static constexpr EventType OUT_OF_SEAT =
    DFSeatEvent_EventType_OUT_OF_SEAT;
  static constexpr EventType PRESSURE_HIGH =
    DFSeatEvent_EventType_PRESSURE_HIGH;
  static constexpr EventType PRESSURE_LOW =
    DFSeatEvent_EventType_PRESSURE_LOW;
  static constexpr EventType OFFLOAD =
    DFSeatEvent_EventType_OFFLOAD;
  static constexpr EventType PRESSURE_OK =
    DFSeatEvent_EventType_PRESSURE_OK;
  static inline bool EventType_IsValid(int value) {
    return DFSeatEvent_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    DFSeatEvent_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    DFSeatEvent_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    DFSeatEvent_EventType_EventType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EventType_descriptor() {
    return DFSeatEvent_EventType_descriptor();
  }
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return DFSeatEvent_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return DFSeatEvent_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentTimestampFieldNumber = 1,
    kEventTimestampFieldNumber = 2,
    kGroupFieldNumber = 3,
    kEventTypeFieldNumber = 4,
  };
  // uint32 current_timestamp = 1;
  void clear_current_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 current_timestamp() const;
  void set_current_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_current_timestamp() const;
  void _internal_set_current_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 event_timestamp = 2;
  void clear_event_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 event_timestamp() const;
  void set_event_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_event_timestamp() const;
  void _internal_set_event_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .sensors.DFSeatEvent.EventGroup group = 3;
  void clear_group();
  ::sensors::DFSeatEvent_EventGroup group() const;
  void set_group(::sensors::DFSeatEvent_EventGroup value);
  private:
  ::sensors::DFSeatEvent_EventGroup _internal_group() const;
  void _internal_set_group(::sensors::DFSeatEvent_EventGroup value);
  public:

  // .sensors.DFSeatEvent.EventType event_type = 4;
  void clear_event_type();
  ::sensors::DFSeatEvent_EventType event_type() const;
  void set_event_type(::sensors::DFSeatEvent_EventType value);
  private:
  ::sensors::DFSeatEvent_EventType _internal_event_type() const;
  void _internal_set_event_type(::sensors::DFSeatEvent_EventType value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.DFSeatEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 current_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 event_timestamp_;
  int group_;
  int event_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class DistanceData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.DistanceData) */ {
 public:
  inline DistanceData() : DistanceData(nullptr) {}
  ~DistanceData() override;
  explicit constexpr DistanceData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistanceData(const DistanceData& from);
  DistanceData(DistanceData&& from) noexcept
    : DistanceData() {
    *this = ::std::move(from);
  }

  inline DistanceData& operator=(const DistanceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistanceData& operator=(DistanceData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistanceData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistanceData* internal_default_instance() {
    return reinterpret_cast<const DistanceData*>(
               &_DistanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DistanceData& a, DistanceData& b) {
    a.Swap(&b);
  }
  inline void Swap(DistanceData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistanceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DistanceData* New() const final {
    return new DistanceData();
  }

  DistanceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DistanceData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DistanceData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DistanceData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistanceData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.DistanceData";
  }
  protected:
  explicit DistanceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
  };
  // int32 distance = 1;
  void clear_distance();
  ::PROTOBUF_NAMESPACE_ID::int32 distance() const;
  void set_distance(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_distance() const;
  void _internal_set_distance(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.DistanceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class SeatPressure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.SeatPressure) */ {
 public:
  inline SeatPressure() : SeatPressure(nullptr) {}
  ~SeatPressure() override;
  explicit constexpr SeatPressure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeatPressure(const SeatPressure& from);
  SeatPressure(SeatPressure&& from) noexcept
    : SeatPressure() {
    *this = ::std::move(from);
  }

  inline SeatPressure& operator=(const SeatPressure& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeatPressure& operator=(SeatPressure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeatPressure& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeatPressure* internal_default_instance() {
    return reinterpret_cast<const SeatPressure*>(
               &_SeatPressure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SeatPressure& a, SeatPressure& b) {
    a.Swap(&b);
  }
  inline void Swap(SeatPressure* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeatPressure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SeatPressure* New() const final {
    return new SeatPressure();
  }

  SeatPressure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SeatPressure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeatPressure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SeatPressure& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatPressure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.SeatPressure";
  }
  protected:
  explicit SeatPressure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPressureFieldNumber = 1,
  };
  // float pressure = 1;
  void clear_pressure();
  float pressure() const;
  void set_pressure(float value);
  private:
  float _internal_pressure() const;
  void _internal_set_pressure(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.SeatPressure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float pressure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ObstacleValue_Linear final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ObstacleValue.Linear) */ {
 public:
  inline ObstacleValue_Linear() : ObstacleValue_Linear(nullptr) {}
  ~ObstacleValue_Linear() override;
  explicit constexpr ObstacleValue_Linear(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleValue_Linear(const ObstacleValue_Linear& from);
  ObstacleValue_Linear(ObstacleValue_Linear&& from) noexcept
    : ObstacleValue_Linear() {
    *this = ::std::move(from);
  }

  inline ObstacleValue_Linear& operator=(const ObstacleValue_Linear& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleValue_Linear& operator=(ObstacleValue_Linear&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleValue_Linear& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleValue_Linear* internal_default_instance() {
    return reinterpret_cast<const ObstacleValue_Linear*>(
               &_ObstacleValue_Linear_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ObstacleValue_Linear& a, ObstacleValue_Linear& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleValue_Linear* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleValue_Linear* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObstacleValue_Linear* New() const final {
    return new ObstacleValue_Linear();
  }

  ObstacleValue_Linear* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleValue_Linear>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleValue_Linear& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleValue_Linear& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleValue_Linear* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ObstacleValue.Linear";
  }
  protected:
  explicit ObstacleValue_Linear(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
  };
  // float distance = 1;
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ObstacleValue.Linear)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ObstacleValue_Angular final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ObstacleValue.Angular) */ {
 public:
  inline ObstacleValue_Angular() : ObstacleValue_Angular(nullptr) {}
  ~ObstacleValue_Angular() override;
  explicit constexpr ObstacleValue_Angular(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleValue_Angular(const ObstacleValue_Angular& from);
  ObstacleValue_Angular(ObstacleValue_Angular&& from) noexcept
    : ObstacleValue_Angular() {
    *this = ::std::move(from);
  }

  inline ObstacleValue_Angular& operator=(const ObstacleValue_Angular& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleValue_Angular& operator=(ObstacleValue_Angular&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleValue_Angular& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleValue_Angular* internal_default_instance() {
    return reinterpret_cast<const ObstacleValue_Angular*>(
               &_ObstacleValue_Angular_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ObstacleValue_Angular& a, ObstacleValue_Angular& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleValue_Angular* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleValue_Angular* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObstacleValue_Angular* New() const final {
    return new ObstacleValue_Angular();
  }

  ObstacleValue_Angular* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleValue_Angular>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleValue_Angular& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleValue_Angular& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleValue_Angular* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ObstacleValue.Angular";
  }
  protected:
  explicit ObstacleValue_Angular(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // float angle = 1;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ObstacleValue.Angular)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ObstacleValue_Combo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ObstacleValue.Combo) */ {
 public:
  inline ObstacleValue_Combo() : ObstacleValue_Combo(nullptr) {}
  ~ObstacleValue_Combo() override;
  explicit constexpr ObstacleValue_Combo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleValue_Combo(const ObstacleValue_Combo& from);
  ObstacleValue_Combo(ObstacleValue_Combo&& from) noexcept
    : ObstacleValue_Combo() {
    *this = ::std::move(from);
  }

  inline ObstacleValue_Combo& operator=(const ObstacleValue_Combo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleValue_Combo& operator=(ObstacleValue_Combo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleValue_Combo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleValue_Combo* internal_default_instance() {
    return reinterpret_cast<const ObstacleValue_Combo*>(
               &_ObstacleValue_Combo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ObstacleValue_Combo& a, ObstacleValue_Combo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleValue_Combo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleValue_Combo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObstacleValue_Combo* New() const final {
    return new ObstacleValue_Combo();
  }

  ObstacleValue_Combo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleValue_Combo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleValue_Combo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleValue_Combo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleValue_Combo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ObstacleValue.Combo";
  }
  protected:
  explicit ObstacleValue_Combo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // float distance = 1;
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // float angle = 2;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ObstacleValue.Combo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float distance_;
  float angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ObstacleValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ObstacleValue) */ {
 public:
  inline ObstacleValue() : ObstacleValue(nullptr) {}
  ~ObstacleValue() override;
  explicit constexpr ObstacleValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleValue(const ObstacleValue& from);
  ObstacleValue(ObstacleValue&& from) noexcept
    : ObstacleValue() {
    *this = ::std::move(from);
  }

  inline ObstacleValue& operator=(const ObstacleValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleValue& operator=(ObstacleValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kLinear = 1,
    kAngular = 2,
    kCombo = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const ObstacleValue* internal_default_instance() {
    return reinterpret_cast<const ObstacleValue*>(
               &_ObstacleValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ObstacleValue& a, ObstacleValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObstacleValue* New() const final {
    return new ObstacleValue();
  }

  ObstacleValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ObstacleValue";
  }
  protected:
  explicit ObstacleValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObstacleValue_Linear Linear;
  typedef ObstacleValue_Angular Angular;
  typedef ObstacleValue_Combo Combo;

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
    kComboFieldNumber = 3,
  };
  // .sensors.ObstacleValue.Linear linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::sensors::ObstacleValue_Linear& linear() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue_Linear* release_linear();
  ::sensors::ObstacleValue_Linear* mutable_linear();
  void set_allocated_linear(::sensors::ObstacleValue_Linear* linear);
  private:
  const ::sensors::ObstacleValue_Linear& _internal_linear() const;
  ::sensors::ObstacleValue_Linear* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::sensors::ObstacleValue_Linear* linear);
  ::sensors::ObstacleValue_Linear* unsafe_arena_release_linear();

  // .sensors.ObstacleValue.Angular angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::sensors::ObstacleValue_Angular& angular() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue_Angular* release_angular();
  ::sensors::ObstacleValue_Angular* mutable_angular();
  void set_allocated_angular(::sensors::ObstacleValue_Angular* angular);
  private:
  const ::sensors::ObstacleValue_Angular& _internal_angular() const;
  ::sensors::ObstacleValue_Angular* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::sensors::ObstacleValue_Angular* angular);
  ::sensors::ObstacleValue_Angular* unsafe_arena_release_angular();

  // .sensors.ObstacleValue.Combo combo = 3;
  bool has_combo() const;
  private:
  bool _internal_has_combo() const;
  public:
  void clear_combo();
  const ::sensors::ObstacleValue_Combo& combo() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue_Combo* release_combo();
  ::sensors::ObstacleValue_Combo* mutable_combo();
  void set_allocated_combo(::sensors::ObstacleValue_Combo* combo);
  private:
  const ::sensors::ObstacleValue_Combo& _internal_combo() const;
  ::sensors::ObstacleValue_Combo* _internal_mutable_combo();
  public:
  void unsafe_arena_set_allocated_combo(
      ::sensors::ObstacleValue_Combo* combo);
  ::sensors::ObstacleValue_Combo* unsafe_arena_release_combo();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:sensors.ObstacleValue)
 private:
  class _Internal;
  void set_has_linear();
  void set_has_angular();
  void set_has_combo();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensors::ObstacleValue_Linear* linear_;
    ::sensors::ObstacleValue_Angular* angular_;
    ::sensors::ObstacleValue_Combo* combo_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ClosestObstacles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ClosestObstacles) */ {
 public:
  inline ClosestObstacles() : ClosestObstacles(nullptr) {}
  ~ClosestObstacles() override;
  explicit constexpr ClosestObstacles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClosestObstacles(const ClosestObstacles& from);
  ClosestObstacles(ClosestObstacles&& from) noexcept
    : ClosestObstacles() {
    *this = ::std::move(from);
  }

  inline ClosestObstacles& operator=(const ClosestObstacles& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClosestObstacles& operator=(ClosestObstacles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClosestObstacles& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClosestObstacles* internal_default_instance() {
    return reinterpret_cast<const ClosestObstacles*>(
               &_ClosestObstacles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ClosestObstacles& a, ClosestObstacles& b) {
    a.Swap(&b);
  }
  inline void Swap(ClosestObstacles* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClosestObstacles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClosestObstacles* New() const final {
    return new ClosestObstacles();
  }

  ClosestObstacles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClosestObstacles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClosestObstacles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClosestObstacles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClosestObstacles* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ClosestObstacles";
  }
  protected:
  explicit ClosestObstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrontFieldNumber = 1,
    kFrontLeftFieldNumber = 2,
    kFrontRightFieldNumber = 3,
    kLeftFieldNumber = 4,
    kRightFieldNumber = 5,
    kBackLeftFieldNumber = 6,
    kBackRightFieldNumber = 7,
    kBackFieldNumber = 8,
    kTimestampFieldNumber = 9,
  };
  // .sensors.ObstacleValue front = 1;
  bool has_front() const;
  private:
  bool _internal_has_front() const;
  public:
  void clear_front();
  const ::sensors::ObstacleValue& front() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_front();
  ::sensors::ObstacleValue* mutable_front();
  void set_allocated_front(::sensors::ObstacleValue* front);
  private:
  const ::sensors::ObstacleValue& _internal_front() const;
  ::sensors::ObstacleValue* _internal_mutable_front();
  public:
  void unsafe_arena_set_allocated_front(
      ::sensors::ObstacleValue* front);
  ::sensors::ObstacleValue* unsafe_arena_release_front();

  // .sensors.ObstacleValue front_left = 2;
  bool has_front_left() const;
  private:
  bool _internal_has_front_left() const;
  public:
  void clear_front_left();
  const ::sensors::ObstacleValue& front_left() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_front_left();
  ::sensors::ObstacleValue* mutable_front_left();
  void set_allocated_front_left(::sensors::ObstacleValue* front_left);
  private:
  const ::sensors::ObstacleValue& _internal_front_left() const;
  ::sensors::ObstacleValue* _internal_mutable_front_left();
  public:
  void unsafe_arena_set_allocated_front_left(
      ::sensors::ObstacleValue* front_left);
  ::sensors::ObstacleValue* unsafe_arena_release_front_left();

  // .sensors.ObstacleValue front_right = 3;
  bool has_front_right() const;
  private:
  bool _internal_has_front_right() const;
  public:
  void clear_front_right();
  const ::sensors::ObstacleValue& front_right() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_front_right();
  ::sensors::ObstacleValue* mutable_front_right();
  void set_allocated_front_right(::sensors::ObstacleValue* front_right);
  private:
  const ::sensors::ObstacleValue& _internal_front_right() const;
  ::sensors::ObstacleValue* _internal_mutable_front_right();
  public:
  void unsafe_arena_set_allocated_front_right(
      ::sensors::ObstacleValue* front_right);
  ::sensors::ObstacleValue* unsafe_arena_release_front_right();

  // .sensors.ObstacleValue left = 4;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  const ::sensors::ObstacleValue& left() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_left();
  ::sensors::ObstacleValue* mutable_left();
  void set_allocated_left(::sensors::ObstacleValue* left);
  private:
  const ::sensors::ObstacleValue& _internal_left() const;
  ::sensors::ObstacleValue* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::sensors::ObstacleValue* left);
  ::sensors::ObstacleValue* unsafe_arena_release_left();

  // .sensors.ObstacleValue right = 5;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  const ::sensors::ObstacleValue& right() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_right();
  ::sensors::ObstacleValue* mutable_right();
  void set_allocated_right(::sensors::ObstacleValue* right);
  private:
  const ::sensors::ObstacleValue& _internal_right() const;
  ::sensors::ObstacleValue* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::sensors::ObstacleValue* right);
  ::sensors::ObstacleValue* unsafe_arena_release_right();

  // .sensors.ObstacleValue back_left = 6;
  bool has_back_left() const;
  private:
  bool _internal_has_back_left() const;
  public:
  void clear_back_left();
  const ::sensors::ObstacleValue& back_left() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_back_left();
  ::sensors::ObstacleValue* mutable_back_left();
  void set_allocated_back_left(::sensors::ObstacleValue* back_left);
  private:
  const ::sensors::ObstacleValue& _internal_back_left() const;
  ::sensors::ObstacleValue* _internal_mutable_back_left();
  public:
  void unsafe_arena_set_allocated_back_left(
      ::sensors::ObstacleValue* back_left);
  ::sensors::ObstacleValue* unsafe_arena_release_back_left();

  // .sensors.ObstacleValue back_right = 7;
  bool has_back_right() const;
  private:
  bool _internal_has_back_right() const;
  public:
  void clear_back_right();
  const ::sensors::ObstacleValue& back_right() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_back_right();
  ::sensors::ObstacleValue* mutable_back_right();
  void set_allocated_back_right(::sensors::ObstacleValue* back_right);
  private:
  const ::sensors::ObstacleValue& _internal_back_right() const;
  ::sensors::ObstacleValue* _internal_mutable_back_right();
  public:
  void unsafe_arena_set_allocated_back_right(
      ::sensors::ObstacleValue* back_right);
  ::sensors::ObstacleValue* unsafe_arena_release_back_right();

  // .sensors.ObstacleValue back = 8;
  bool has_back() const;
  private:
  bool _internal_has_back() const;
  public:
  void clear_back();
  const ::sensors::ObstacleValue& back() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::ObstacleValue* release_back();
  ::sensors::ObstacleValue* mutable_back();
  void set_allocated_back(::sensors::ObstacleValue* back);
  private:
  const ::sensors::ObstacleValue& _internal_back() const;
  ::sensors::ObstacleValue* _internal_mutable_back();
  public:
  void unsafe_arena_set_allocated_back(
      ::sensors::ObstacleValue* back);
  ::sensors::ObstacleValue* unsafe_arena_release_back();

  // .google.protobuf.Timestamp timestamp = 9;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.ClosestObstacles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensors::ObstacleValue* front_;
  ::sensors::ObstacleValue* front_left_;
  ::sensors::ObstacleValue* front_right_;
  ::sensors::ObstacleValue* left_;
  ::sensors::ObstacleValue* right_;
  ::sensors::ObstacleValue* back_left_;
  ::sensors::ObstacleValue* back_right_;
  ::sensors::ObstacleValue* back_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class CameraPoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.CameraPoints) */ {
 public:
  inline CameraPoints() : CameraPoints(nullptr) {}
  ~CameraPoints() override;
  explicit constexpr CameraPoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraPoints(const CameraPoints& from);
  CameraPoints(CameraPoints&& from) noexcept
    : CameraPoints() {
    *this = ::std::move(from);
  }

  inline CameraPoints& operator=(const CameraPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraPoints& operator=(CameraPoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraPoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraPoints* internal_default_instance() {
    return reinterpret_cast<const CameraPoints*>(
               &_CameraPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CameraPoints& a, CameraPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraPoints* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraPoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraPoints* New() const final {
    return new CameraPoints();
  }

  CameraPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraPoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraPoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CameraPoints& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraPoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.CameraPoints";
  }
  protected:
  explicit CameraPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated .sensors.Point3D points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::sensors::Point3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >*
      mutable_points();
  private:
  const ::sensors::Point3D& _internal_points(int index) const;
  ::sensors::Point3D* _internal_add_points();
  public:
  const ::sensors::Point3D& points(int index) const;
  ::sensors::Point3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >&
      points() const;

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.CameraPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D > points_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Point3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Point3D) */ {
 public:
  inline Point3D() : Point3D(nullptr) {}
  ~Point3D() override;
  explicit constexpr Point3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point3D(const Point3D& from);
  Point3D(Point3D&& from) noexcept
    : Point3D() {
    *this = ::std::move(from);
  }

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point3D& operator=(Point3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point3D* internal_default_instance() {
    return reinterpret_cast<const Point3D*>(
               &_Point3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Point3D& a, Point3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point3D* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point3D* New() const final {
    return new Point3D();
  }

  Point3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point3D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Point3D";
  }
  protected:
  explicit Point3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Point3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class CameraPoints2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.CameraPoints2D) */ {
 public:
  inline CameraPoints2D() : CameraPoints2D(nullptr) {}
  ~CameraPoints2D() override;
  explicit constexpr CameraPoints2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraPoints2D(const CameraPoints2D& from);
  CameraPoints2D(CameraPoints2D&& from) noexcept
    : CameraPoints2D() {
    *this = ::std::move(from);
  }

  inline CameraPoints2D& operator=(const CameraPoints2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraPoints2D& operator=(CameraPoints2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraPoints2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraPoints2D* internal_default_instance() {
    return reinterpret_cast<const CameraPoints2D*>(
               &_CameraPoints2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CameraPoints2D& a, CameraPoints2D& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraPoints2D* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraPoints2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraPoints2D* New() const final {
    return new CameraPoints2D();
  }

  CameraPoints2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraPoints2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraPoints2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CameraPoints2D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraPoints2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.CameraPoints2D";
  }
  protected:
  explicit CameraPoints2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated .sensors.Point2D points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::sensors::Point2D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
      mutable_points();
  private:
  const ::sensors::Point2D& _internal_points(int index) const;
  ::sensors::Point2D* _internal_add_points();
  public:
  const ::sensors::Point2D& points(int index) const;
  ::sensors::Point2D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
      points() const;

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.CameraPoints2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D > points_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Point2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Point2D) */ {
 public:
  inline Point2D() : Point2D(nullptr) {}
  ~Point2D() override;
  explicit constexpr Point2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2D(const Point2D& from);
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2D& operator=(Point2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2D* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point2D* New() const final {
    return new Point2D();
  }

  Point2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point2D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Point2D";
  }
  protected:
  explicit Point2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Point2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class LoggingData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.LoggingData) */ {
 public:
  inline LoggingData() : LoggingData(nullptr) {}
  ~LoggingData() override;
  explicit constexpr LoggingData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoggingData(const LoggingData& from);
  LoggingData(LoggingData&& from) noexcept
    : LoggingData() {
    *this = ::std::move(from);
  }

  inline LoggingData& operator=(const LoggingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingData& operator=(LoggingData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoggingData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoggingData* internal_default_instance() {
    return reinterpret_cast<const LoggingData*>(
               &_LoggingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoggingData& a, LoggingData& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggingData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggingData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoggingData* New() const final {
    return new LoggingData();
  }

  LoggingData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoggingData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoggingData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoggingData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggingData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.LoggingData";
  }
  protected:
  explicit LoggingData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // repeated .sensors.Point3D points = 4;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::sensors::Point3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >*
      mutable_points();
  private:
  const ::sensors::Point3D& _internal_points(int index) const;
  ::sensors::Point3D* _internal_add_points();
  public:
  const ::sensors::Point3D& points(int index) const;
  ::sensors::Point3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >&
      points() const;

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // int32 timestamp = 3;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.LoggingData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D > points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  double value_;
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Led final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Led) */ {
 public:
  inline Led() : Led(nullptr) {}
  ~Led() override;
  explicit constexpr Led(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Led(const Led& from);
  Led(Led&& from) noexcept
    : Led() {
    *this = ::std::move(from);
  }

  inline Led& operator=(const Led& from) {
    CopyFrom(from);
    return *this;
  }
  inline Led& operator=(Led&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Led& default_instance() {
    return *internal_default_instance();
  }
  static inline const Led* internal_default_instance() {
    return reinterpret_cast<const Led*>(
               &_Led_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Led& a, Led& b) {
    a.Swap(&b);
  }
  inline void Swap(Led* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Led* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Led* New() const final {
    return new Led();
  }

  Led* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Led>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Led& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Led& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Led* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Led";
  }
  protected:
  explicit Led(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Led_Leds Leds;
  static constexpr Leds UNKNOWN =
    Led_Leds_UNKNOWN;
  static constexpr Leds SYSTEM_STATUS =
    Led_Leds_SYSTEM_STATUS;
  static constexpr Leds SENSOR_OK =
    Led_Leds_SENSOR_OK;
  static constexpr Leds SENSOR_BLOCKED =
    Led_Leds_SENSOR_BLOCKED;
  static constexpr Leds SENSOR_ERROR =
    Led_Leds_SENSOR_ERROR;
  static constexpr Leds WIFI_CONNECTED =
    Led_Leds_WIFI_CONNECTED;
  static constexpr Leds CELL_CONNECTED =
    Led_Leds_CELL_CONNECTED;
  static constexpr Leds BLUETOOTH_CONNECTED =
    Led_Leds_BLUETOOTH_CONNECTED;
  static inline bool Leds_IsValid(int value) {
    return Led_Leds_IsValid(value);
  }
  static constexpr Leds Leds_MIN =
    Led_Leds_Leds_MIN;
  static constexpr Leds Leds_MAX =
    Led_Leds_Leds_MAX;
  static constexpr int Leds_ARRAYSIZE =
    Led_Leds_Leds_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Leds_descriptor() {
    return Led_Leds_descriptor();
  }
  template<typename T>
  static inline const std::string& Leds_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Leds>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Leds_Name.");
    return Led_Leds_Name(enum_t_value);
  }
  static inline bool Leds_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Leds* value) {
    return Led_Leds_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLedFieldNumber = 1,
  };
  // .sensors.Led.Leds led = 1;
  void clear_led();
  ::sensors::Led_Leds led() const;
  void set_led(::sensors::Led_Leds value);
  private:
  ::sensors::Led_Leds _internal_led() const;
  void _internal_set_led(::sensors::Led_Leds value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Led)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int led_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class HmiState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.HmiState) */ {
 public:
  inline HmiState() : HmiState(nullptr) {}
  ~HmiState() override;
  explicit constexpr HmiState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HmiState(const HmiState& from);
  HmiState(HmiState&& from) noexcept
    : HmiState() {
    *this = ::std::move(from);
  }

  inline HmiState& operator=(const HmiState& from) {
    CopyFrom(from);
    return *this;
  }
  inline HmiState& operator=(HmiState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HmiState& default_instance() {
    return *internal_default_instance();
  }
  static inline const HmiState* internal_default_instance() {
    return reinterpret_cast<const HmiState*>(
               &_HmiState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(HmiState& a, HmiState& b) {
    a.Swap(&b);
  }
  inline void Swap(HmiState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HmiState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HmiState* New() const final {
    return new HmiState();
  }

  HmiState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HmiState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HmiState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HmiState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HmiState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.HmiState";
  }
  protected:
  explicit HmiState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HmiState_States States;
  static constexpr States SETUP_APP_PULSE =
    HmiState_States_SETUP_APP_PULSE;
  static constexpr States REACTION_TEST_WAIT =
    HmiState_States_REACTION_TEST_WAIT;
  static constexpr States REACTION_TEST_GO =
    HmiState_States_REACTION_TEST_GO;
  static constexpr States SENSOR_SYSTEM_ERROR =
    HmiState_States_SENSOR_SYSTEM_ERROR;
  static constexpr States NOMINAL_OFF =
    HmiState_States_NOMINAL_OFF;
  static constexpr States SENSOR_SYSTEM_OVERRIDE =
    HmiState_States_SENSOR_SYSTEM_OVERRIDE;
  static constexpr States LUCI_LOADING =
    HmiState_States_LUCI_LOADING;
  static constexpr States SENSOR_BLOCKED =
    HmiState_States_SENSOR_BLOCKED;
  static constexpr States SYSTEM_OK =
    HmiState_States_SYSTEM_OK;
  static constexpr States STABILITY_WARNING =
    HmiState_States_STABILITY_WARNING;
  static constexpr States STABILITY_DANGER =
    HmiState_States_STABILITY_DANGER;
  static constexpr States STABILITY_TIPPED =
    HmiState_States_STABILITY_TIPPED;
  static constexpr States SENDING_LOGS =
    HmiState_States_SENDING_LOGS;
  static constexpr States WIFI_SENDING =
    HmiState_States_WIFI_SENDING;
  static constexpr States WIFI_AVAILABLE =
    HmiState_States_WIFI_AVAILABLE;
  static constexpr States CELL_SENDING =
    HmiState_States_CELL_SENDING;
  static constexpr States CELL_AVAILABLE =
    HmiState_States_CELL_AVAILABLE;
  static constexpr States USER_KEY_LOW =
    HmiState_States_USER_KEY_LOW;
  static constexpr States USER_KEY_PRESENT =
    HmiState_States_USER_KEY_PRESENT;
  static constexpr States NO_ACTION =
    HmiState_States_NO_ACTION;
  static constexpr States BUTTON_PRESSED =
    HmiState_States_BUTTON_PRESSED;
  static constexpr States UPDATE_IN_PROGRESS =
    HmiState_States_UPDATE_IN_PROGRESS;
  static constexpr States ALL_OFF =
    HmiState_States_ALL_OFF;
  static constexpr States FLASH_LEDS =
    HmiState_States_FLASH_LEDS;
  static constexpr States CHASE_LEDS =
    HmiState_States_CHASE_LEDS;
  static constexpr States TEST_USER_KEY =
    HmiState_States_TEST_USER_KEY;
  static constexpr States TEST_WIFI =
    HmiState_States_TEST_WIFI;
  static constexpr States TEST_CELL =
    HmiState_States_TEST_CELL;
  static constexpr States TEST_SENSOR_OK =
    HmiState_States_TEST_SENSOR_OK;
  static constexpr States TEST_SENSOR_WARNING =
    HmiState_States_TEST_SENSOR_WARNING;
  static constexpr States TEST_SENSOR_ERROR =
    HmiState_States_TEST_SENSOR_ERROR;
  static constexpr States TEST_LUCI_BUTTON =
    HmiState_States_TEST_LUCI_BUTTON;
  static inline bool States_IsValid(int value) {
    return HmiState_States_IsValid(value);
  }
  static constexpr States States_MIN =
    HmiState_States_States_MIN;
  static constexpr States States_MAX =
    HmiState_States_States_MAX;
  static constexpr int States_ARRAYSIZE =
    HmiState_States_States_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  States_descriptor() {
    return HmiState_States_descriptor();
  }
  template<typename T>
  static inline const std::string& States_Name(T enum_t_value) {
    static_assert(::std::is_same<T, States>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function States_Name.");
    return HmiState_States_Name(enum_t_value);
  }
  static inline bool States_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      States* value) {
    return HmiState_States_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .sensors.HmiState.States state = 1;
  void clear_state();
  ::sensors::HmiState_States state() const;
  void set_state(::sensors::HmiState_States value);
  private:
  ::sensors::HmiState_States _internal_state() const;
  void _internal_set_state(::sensors::HmiState_States value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.HmiState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class HmiStreamData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.HmiStreamData) */ {
 public:
  inline HmiStreamData() : HmiStreamData(nullptr) {}
  ~HmiStreamData() override;
  explicit constexpr HmiStreamData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HmiStreamData(const HmiStreamData& from);
  HmiStreamData(HmiStreamData&& from) noexcept
    : HmiStreamData() {
    *this = ::std::move(from);
  }

  inline HmiStreamData& operator=(const HmiStreamData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HmiStreamData& operator=(HmiStreamData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HmiStreamData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HmiStreamData* internal_default_instance() {
    return reinterpret_cast<const HmiStreamData*>(
               &_HmiStreamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(HmiStreamData& a, HmiStreamData& b) {
    a.Swap(&b);
  }
  inline void Swap(HmiStreamData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HmiStreamData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HmiStreamData* New() const final {
    return new HmiStreamData();
  }

  HmiStreamData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HmiStreamData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HmiStreamData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HmiStreamData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HmiStreamData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.HmiStreamData";
  }
  protected:
  explicit HmiStreamData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HmiStreamData_ButtonState ButtonState;
  static constexpr ButtonState PRESSED =
    HmiStreamData_ButtonState_PRESSED;
  static constexpr ButtonState RELEASED =
    HmiStreamData_ButtonState_RELEASED;
  static inline bool ButtonState_IsValid(int value) {
    return HmiStreamData_ButtonState_IsValid(value);
  }
  static constexpr ButtonState ButtonState_MIN =
    HmiStreamData_ButtonState_ButtonState_MIN;
  static constexpr ButtonState ButtonState_MAX =
    HmiStreamData_ButtonState_ButtonState_MAX;
  static constexpr int ButtonState_ARRAYSIZE =
    HmiStreamData_ButtonState_ButtonState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ButtonState_descriptor() {
    return HmiStreamData_ButtonState_descriptor();
  }
  template<typename T>
  static inline const std::string& ButtonState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ButtonState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ButtonState_Name.");
    return HmiStreamData_ButtonState_Name(enum_t_value);
  }
  static inline bool ButtonState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ButtonState* value) {
    return HmiStreamData_ButtonState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIsAltOverrideFieldNumber = 1,
    kButtonStateFieldNumber = 2,
  };
  // bool is_alt_override = 1;
  void clear_is_alt_override();
  bool is_alt_override() const;
  void set_is_alt_override(bool value);
  private:
  bool _internal_is_alt_override() const;
  void _internal_set_is_alt_override(bool value);
  public:

  // .sensors.HmiStreamData.ButtonState button_state = 2;
  void clear_button_state();
  ::sensors::HmiStreamData_ButtonState button_state() const;
  void set_button_state(::sensors::HmiStreamData_ButtonState value);
  private:
  ::sensors::HmiStreamData_ButtonState _internal_button_state() const;
  void _internal_set_button_state(::sensors::HmiStreamData_ButtonState value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.HmiStreamData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_alt_override_;
  int button_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class PressCountStreamData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.PressCountStreamData) */ {
 public:
  inline PressCountStreamData() : PressCountStreamData(nullptr) {}
  ~PressCountStreamData() override;
  explicit constexpr PressCountStreamData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PressCountStreamData(const PressCountStreamData& from);
  PressCountStreamData(PressCountStreamData&& from) noexcept
    : PressCountStreamData() {
    *this = ::std::move(from);
  }

  inline PressCountStreamData& operator=(const PressCountStreamData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PressCountStreamData& operator=(PressCountStreamData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PressCountStreamData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PressCountStreamData* internal_default_instance() {
    return reinterpret_cast<const PressCountStreamData*>(
               &_PressCountStreamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PressCountStreamData& a, PressCountStreamData& b) {
    a.Swap(&b);
  }
  inline void Swap(PressCountStreamData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PressCountStreamData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PressCountStreamData* New() const final {
    return new PressCountStreamData();
  }

  PressCountStreamData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PressCountStreamData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PressCountStreamData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PressCountStreamData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PressCountStreamData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.PressCountStreamData";
  }
  protected:
  explicit PressCountStreamData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPressCountFieldNumber = 1,
  };
  // int32 press_count = 1;
  void clear_press_count();
  ::PROTOBUF_NAMESPACE_ID::int32 press_count() const;
  void set_press_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_press_count() const;
  void _internal_set_press_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.PressCountStreamData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 press_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class NavigationScaling final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.NavigationScaling) */ {
 public:
  inline NavigationScaling() : NavigationScaling(nullptr) {}
  ~NavigationScaling() override;
  explicit constexpr NavigationScaling(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationScaling(const NavigationScaling& from);
  NavigationScaling(NavigationScaling&& from) noexcept
    : NavigationScaling() {
    *this = ::std::move(from);
  }

  inline NavigationScaling& operator=(const NavigationScaling& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationScaling& operator=(NavigationScaling&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationScaling& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationScaling* internal_default_instance() {
    return reinterpret_cast<const NavigationScaling*>(
               &_NavigationScaling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NavigationScaling& a, NavigationScaling& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationScaling* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationScaling* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationScaling* New() const final {
    return new NavigationScaling();
  }

  NavigationScaling* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationScaling>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigationScaling& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NavigationScaling& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationScaling* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.NavigationScaling";
  }
  protected:
  explicit NavigationScaling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrontFbFieldNumber = 1,
    kFrontRlFieldNumber = 2,
    kFrontRightFbFieldNumber = 3,
    kFrontRightRlFieldNumber = 4,
    kFrontLeftFbFieldNumber = 5,
    kFrontLeftRlFieldNumber = 6,
    kRightFbFieldNumber = 7,
    kRightRlFieldNumber = 8,
    kLeftFbFieldNumber = 9,
    kLeftRlFieldNumber = 10,
    kBackRightFbFieldNumber = 11,
    kBackRightRlFieldNumber = 12,
    kBackLeftFbFieldNumber = 13,
    kBackLeftRlFieldNumber = 14,
    kBackFbFieldNumber = 15,
    kBackRlFieldNumber = 16,
    kMaxJsScaleIncreaseFieldNumber = 17,
    kMaxJsScaleDecreaseFieldNumber = 18,
    kLuciActiveFieldNumber = 19,
  };
  // float front_fb = 1;
  void clear_front_fb();
  float front_fb() const;
  void set_front_fb(float value);
  private:
  float _internal_front_fb() const;
  void _internal_set_front_fb(float value);
  public:

  // float front_rl = 2;
  void clear_front_rl();
  float front_rl() const;
  void set_front_rl(float value);
  private:
  float _internal_front_rl() const;
  void _internal_set_front_rl(float value);
  public:

  // float front_right_fb = 3;
  void clear_front_right_fb();
  float front_right_fb() const;
  void set_front_right_fb(float value);
  private:
  float _internal_front_right_fb() const;
  void _internal_set_front_right_fb(float value);
  public:

  // float front_right_rl = 4;
  void clear_front_right_rl();
  float front_right_rl() const;
  void set_front_right_rl(float value);
  private:
  float _internal_front_right_rl() const;
  void _internal_set_front_right_rl(float value);
  public:

  // float front_left_fb = 5;
  void clear_front_left_fb();
  float front_left_fb() const;
  void set_front_left_fb(float value);
  private:
  float _internal_front_left_fb() const;
  void _internal_set_front_left_fb(float value);
  public:

  // float front_left_rl = 6;
  void clear_front_left_rl();
  float front_left_rl() const;
  void set_front_left_rl(float value);
  private:
  float _internal_front_left_rl() const;
  void _internal_set_front_left_rl(float value);
  public:

  // float right_fb = 7;
  void clear_right_fb();
  float right_fb() const;
  void set_right_fb(float value);
  private:
  float _internal_right_fb() const;
  void _internal_set_right_fb(float value);
  public:

  // float right_rl = 8;
  void clear_right_rl();
  float right_rl() const;
  void set_right_rl(float value);
  private:
  float _internal_right_rl() const;
  void _internal_set_right_rl(float value);
  public:

  // float left_fb = 9;
  void clear_left_fb();
  float left_fb() const;
  void set_left_fb(float value);
  private:
  float _internal_left_fb() const;
  void _internal_set_left_fb(float value);
  public:

  // float left_rl = 10;
  void clear_left_rl();
  float left_rl() const;
  void set_left_rl(float value);
  private:
  float _internal_left_rl() const;
  void _internal_set_left_rl(float value);
  public:

  // float back_right_fb = 11;
  void clear_back_right_fb();
  float back_right_fb() const;
  void set_back_right_fb(float value);
  private:
  float _internal_back_right_fb() const;
  void _internal_set_back_right_fb(float value);
  public:

  // float back_right_rl = 12;
  void clear_back_right_rl();
  float back_right_rl() const;
  void set_back_right_rl(float value);
  private:
  float _internal_back_right_rl() const;
  void _internal_set_back_right_rl(float value);
  public:

  // float back_left_fb = 13;
  void clear_back_left_fb();
  float back_left_fb() const;
  void set_back_left_fb(float value);
  private:
  float _internal_back_left_fb() const;
  void _internal_set_back_left_fb(float value);
  public:

  // float back_left_rl = 14;
  void clear_back_left_rl();
  float back_left_rl() const;
  void set_back_left_rl(float value);
  private:
  float _internal_back_left_rl() const;
  void _internal_set_back_left_rl(float value);
  public:

  // float back_fb = 15;
  void clear_back_fb();
  float back_fb() const;
  void set_back_fb(float value);
  private:
  float _internal_back_fb() const;
  void _internal_set_back_fb(float value);
  public:

  // float back_rl = 16;
  void clear_back_rl();
  float back_rl() const;
  void set_back_rl(float value);
  private:
  float _internal_back_rl() const;
  void _internal_set_back_rl(float value);
  public:

  // uint32 max_js_scale_increase = 17;
  void clear_max_js_scale_increase();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_js_scale_increase() const;
  void set_max_js_scale_increase(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_js_scale_increase() const;
  void _internal_set_max_js_scale_increase(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 max_js_scale_decrease = 18;
  void clear_max_js_scale_decrease();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_js_scale_decrease() const;
  void set_max_js_scale_decrease(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_js_scale_decrease() const;
  void _internal_set_max_js_scale_decrease(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool luci_active = 19;
  void clear_luci_active();
  bool luci_active() const;
  void set_luci_active(bool value);
  private:
  bool _internal_luci_active() const;
  void _internal_set_luci_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.NavigationScaling)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float front_fb_;
  float front_rl_;
  float front_right_fb_;
  float front_right_rl_;
  float front_left_fb_;
  float front_left_rl_;
  float right_fb_;
  float right_rl_;
  float left_fb_;
  float left_rl_;
  float back_right_fb_;
  float back_right_rl_;
  float back_left_fb_;
  float back_left_rl_;
  float back_fb_;
  float back_rl_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_js_scale_increase_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_js_scale_decrease_;
  bool luci_active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicCtrl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.UltrasonicCtrl) */ {
 public:
  inline UltrasonicCtrl() : UltrasonicCtrl(nullptr) {}
  ~UltrasonicCtrl() override;
  explicit constexpr UltrasonicCtrl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UltrasonicCtrl(const UltrasonicCtrl& from);
  UltrasonicCtrl(UltrasonicCtrl&& from) noexcept
    : UltrasonicCtrl() {
    *this = ::std::move(from);
  }

  inline UltrasonicCtrl& operator=(const UltrasonicCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicCtrl& operator=(UltrasonicCtrl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicCtrl& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicCtrl* internal_default_instance() {
    return reinterpret_cast<const UltrasonicCtrl*>(
               &_UltrasonicCtrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UltrasonicCtrl& a, UltrasonicCtrl& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicCtrl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicCtrl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicCtrl* New() const final {
    return new UltrasonicCtrl();
  }

  UltrasonicCtrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicCtrl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UltrasonicCtrl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UltrasonicCtrl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicCtrl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.UltrasonicCtrl";
  }
  protected:
  explicit UltrasonicCtrl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UltrasonicCtrl_Board Board;
  static constexpr Board UNKNOWN =
    UltrasonicCtrl_Board_UNKNOWN;
  static constexpr Board MPU =
    UltrasonicCtrl_Board_MPU;
  static constexpr Board IO_B_LEFT =
    UltrasonicCtrl_Board_IO_B_LEFT;
  static constexpr Board IO_B_RIGHT =
    UltrasonicCtrl_Board_IO_B_RIGHT;
  static inline bool Board_IsValid(int value) {
    return UltrasonicCtrl_Board_IsValid(value);
  }
  static constexpr Board Board_MIN =
    UltrasonicCtrl_Board_Board_MIN;
  static constexpr Board Board_MAX =
    UltrasonicCtrl_Board_Board_MAX;
  static constexpr int Board_ARRAYSIZE =
    UltrasonicCtrl_Board_Board_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Board_descriptor() {
    return UltrasonicCtrl_Board_descriptor();
  }
  template<typename T>
  static inline const std::string& Board_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Board>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Board_Name.");
    return UltrasonicCtrl_Board_Name(enum_t_value);
  }
  static inline bool Board_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Board* value) {
    return UltrasonicCtrl_Board_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBoardFieldNumber = 1,
    kSpiIdFieldNumber = 2,
    kAddressFieldNumber = 3,
  };
  // .sensors.UltrasonicCtrl.Board board = 1;
  void clear_board();
  ::sensors::UltrasonicCtrl_Board board() const;
  void set_board(::sensors::UltrasonicCtrl_Board value);
  private:
  ::sensors::UltrasonicCtrl_Board _internal_board() const;
  void _internal_set_board(::sensors::UltrasonicCtrl_Board value);
  public:

  // int32 spi_id = 2;
  void clear_spi_id();
  ::PROTOBUF_NAMESPACE_ID::int32 spi_id() const;
  void set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_spi_id() const;
  void _internal_set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 address = 3;
  void clear_address();
  ::PROTOBUF_NAMESPACE_ID::int32 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_address() const;
  void _internal_set_address(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.UltrasonicCtrl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int board_;
  ::PROTOBUF_NAMESPACE_ID::int32 spi_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDistance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.UltrasonicDistance) */ {
 public:
  inline UltrasonicDistance() : UltrasonicDistance(nullptr) {}
  ~UltrasonicDistance() override;
  explicit constexpr UltrasonicDistance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UltrasonicDistance(const UltrasonicDistance& from);
  UltrasonicDistance(UltrasonicDistance&& from) noexcept
    : UltrasonicDistance() {
    *this = ::std::move(from);
  }

  inline UltrasonicDistance& operator=(const UltrasonicDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDistance& operator=(UltrasonicDistance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicDistance& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicDistance* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDistance*>(
               &_UltrasonicDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UltrasonicDistance& a, UltrasonicDistance& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicDistance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicDistance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDistance* New() const final {
    return new UltrasonicDistance();
  }

  UltrasonicDistance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicDistance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UltrasonicDistance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UltrasonicDistance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicDistance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.UltrasonicDistance";
  }
  protected:
  explicit UltrasonicDistance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UltrasonicDistance_Board Board;
  static constexpr Board UNKNOWN =
    UltrasonicDistance_Board_UNKNOWN;
  static constexpr Board MPU =
    UltrasonicDistance_Board_MPU;
  static constexpr Board IO_B_LEFT =
    UltrasonicDistance_Board_IO_B_LEFT;
  static constexpr Board IO_B_RIGHT =
    UltrasonicDistance_Board_IO_B_RIGHT;
  static inline bool Board_IsValid(int value) {
    return UltrasonicDistance_Board_IsValid(value);
  }
  static constexpr Board Board_MIN =
    UltrasonicDistance_Board_Board_MIN;
  static constexpr Board Board_MAX =
    UltrasonicDistance_Board_Board_MAX;
  static constexpr int Board_ARRAYSIZE =
    UltrasonicDistance_Board_Board_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Board_descriptor() {
    return UltrasonicDistance_Board_descriptor();
  }
  template<typename T>
  static inline const std::string& Board_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Board>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Board_Name.");
    return UltrasonicDistance_Board_Name(enum_t_value);
  }
  static inline bool Board_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Board* value) {
    return UltrasonicDistance_Board_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kArcPointsFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kDistanceFieldNumber = 1,
    kBoardFieldNumber = 2,
    kSpiIdFieldNumber = 3,
    kAddressFieldNumber = 4,
  };
  // repeated .sensors.Point3D arc_points = 6;
  int arc_points_size() const;
  private:
  int _internal_arc_points_size() const;
  public:
  void clear_arc_points();
  ::sensors::Point3D* mutable_arc_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >*
      mutable_arc_points();
  private:
  const ::sensors::Point3D& _internal_arc_points(int index) const;
  ::sensors::Point3D* _internal_add_arc_points();
  public:
  const ::sensors::Point3D& arc_points(int index) const;
  ::sensors::Point3D* add_arc_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >&
      arc_points() const;

  // .google.protobuf.Timestamp timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double distance = 1;
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // .sensors.UltrasonicDistance.Board board = 2;
  void clear_board();
  ::sensors::UltrasonicDistance_Board board() const;
  void set_board(::sensors::UltrasonicDistance_Board value);
  private:
  ::sensors::UltrasonicDistance_Board _internal_board() const;
  void _internal_set_board(::sensors::UltrasonicDistance_Board value);
  public:

  // int32 spi_id = 3;
  void clear_spi_id();
  ::PROTOBUF_NAMESPACE_ID::int32 spi_id() const;
  void set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_spi_id() const;
  void _internal_set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 address = 4;
  void clear_address();
  ::PROTOBUF_NAMESPACE_ID::int32 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_address() const;
  void _internal_set_address(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.UltrasonicDistance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D > arc_points_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  double distance_;
  int board_;
  ::PROTOBUF_NAMESPACE_ID::int32 spi_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDistances final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.UltrasonicDistances) */ {
 public:
  inline UltrasonicDistances() : UltrasonicDistances(nullptr) {}
  ~UltrasonicDistances() override;
  explicit constexpr UltrasonicDistances(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UltrasonicDistances(const UltrasonicDistances& from);
  UltrasonicDistances(UltrasonicDistances&& from) noexcept
    : UltrasonicDistances() {
    *this = ::std::move(from);
  }

  inline UltrasonicDistances& operator=(const UltrasonicDistances& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDistances& operator=(UltrasonicDistances&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicDistances& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicDistances* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDistances*>(
               &_UltrasonicDistances_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UltrasonicDistances& a, UltrasonicDistances& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicDistances* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicDistances* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDistances* New() const final {
    return new UltrasonicDistances();
  }

  UltrasonicDistances* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicDistances>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UltrasonicDistances& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UltrasonicDistances& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicDistances* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.UltrasonicDistances";
  }
  protected:
  explicit UltrasonicDistances(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistancesFieldNumber = 1,
  };
  // repeated .sensors.UltrasonicDistance distances = 1;
  int distances_size() const;
  private:
  int _internal_distances_size() const;
  public:
  void clear_distances();
  ::sensors::UltrasonicDistance* mutable_distances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::UltrasonicDistance >*
      mutable_distances();
  private:
  const ::sensors::UltrasonicDistance& _internal_distances(int index) const;
  ::sensors::UltrasonicDistance* _internal_add_distances();
  public:
  const ::sensors::UltrasonicDistance& distances(int index) const;
  ::sensors::UltrasonicDistance* add_distances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::UltrasonicDistance >&
      distances() const;

  // @@protoc_insertion_point(class_scope:sensors.UltrasonicDistances)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::UltrasonicDistance > distances_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicCurve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.UltrasonicCurve) */ {
 public:
  inline UltrasonicCurve() : UltrasonicCurve(nullptr) {}
  ~UltrasonicCurve() override;
  explicit constexpr UltrasonicCurve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UltrasonicCurve(const UltrasonicCurve& from);
  UltrasonicCurve(UltrasonicCurve&& from) noexcept
    : UltrasonicCurve() {
    *this = ::std::move(from);
  }

  inline UltrasonicCurve& operator=(const UltrasonicCurve& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicCurve& operator=(UltrasonicCurve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicCurve& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicCurve* internal_default_instance() {
    return reinterpret_cast<const UltrasonicCurve*>(
               &_UltrasonicCurve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UltrasonicCurve& a, UltrasonicCurve& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicCurve* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicCurve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicCurve* New() const final {
    return new UltrasonicCurve();
  }

  UltrasonicCurve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicCurve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UltrasonicCurve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UltrasonicCurve& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicCurve* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.UltrasonicCurve";
  }
  protected:
  explicit UltrasonicCurve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UltrasonicCurve_Board Board;
  static constexpr Board UNKNOWN =
    UltrasonicCurve_Board_UNKNOWN;
  static constexpr Board MPU =
    UltrasonicCurve_Board_MPU;
  static constexpr Board IO_B_LEFT =
    UltrasonicCurve_Board_IO_B_LEFT;
  static constexpr Board IO_B_RIGHT =
    UltrasonicCurve_Board_IO_B_RIGHT;
  static inline bool Board_IsValid(int value) {
    return UltrasonicCurve_Board_IsValid(value);
  }
  static constexpr Board Board_MIN =
    UltrasonicCurve_Board_Board_MIN;
  static constexpr Board Board_MAX =
    UltrasonicCurve_Board_Board_MAX;
  static constexpr int Board_ARRAYSIZE =
    UltrasonicCurve_Board_Board_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Board_descriptor() {
    return UltrasonicCurve_Board_descriptor();
  }
  template<typename T>
  static inline const std::string& Board_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Board>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Board_Name.");
    return UltrasonicCurve_Board_Name(enum_t_value);
  }
  static inline bool Board_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Board* value) {
    return UltrasonicCurve_Board_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurveFieldNumber = 1,
    kBoardFieldNumber = 2,
    kSpiIdFieldNumber = 3,
    kAddressFieldNumber = 4,
  };
  // repeated int32 curve = 1;
  int curve_size() const;
  private:
  int _internal_curve_size() const;
  public:
  void clear_curve();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curve(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_curve() const;
  void _internal_add_curve(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_curve();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 curve(int index) const;
  void set_curve(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_curve(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      curve() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_curve();

  // .sensors.UltrasonicCurve.Board board = 2;
  void clear_board();
  ::sensors::UltrasonicCurve_Board board() const;
  void set_board(::sensors::UltrasonicCurve_Board value);
  private:
  ::sensors::UltrasonicCurve_Board _internal_board() const;
  void _internal_set_board(::sensors::UltrasonicCurve_Board value);
  public:

  // int32 spi_id = 3;
  void clear_spi_id();
  ::PROTOBUF_NAMESPACE_ID::int32 spi_id() const;
  void set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_spi_id() const;
  void _internal_set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 address = 4;
  void clear_address();
  ::PROTOBUF_NAMESPACE_ID::int32 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_address() const;
  void _internal_set_address(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.UltrasonicCurve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > curve_;
  mutable std::atomic<int> _curve_cached_byte_size_;
  int board_;
  ::PROTOBUF_NAMESPACE_ID::int32 spi_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RadarFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RadarFilter) */ {
 public:
  inline RadarFilter() : RadarFilter(nullptr) {}
  ~RadarFilter() override;
  explicit constexpr RadarFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarFilter(const RadarFilter& from);
  RadarFilter(RadarFilter&& from) noexcept
    : RadarFilter() {
    *this = ::std::move(from);
  }

  inline RadarFilter& operator=(const RadarFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarFilter& operator=(RadarFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarFilter* internal_default_instance() {
    return reinterpret_cast<const RadarFilter*>(
               &_RadarFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RadarFilter& a, RadarFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarFilter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadarFilter* New() const final {
    return new RadarFilter();
  }

  RadarFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadarFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RadarFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RadarFilter";
  }
  protected:
  explicit RadarFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RadarFilter_Filter Filter;
  static constexpr Filter RANGE_CHOP =
    RadarFilter_Filter_RANGE_CHOP;
  static constexpr Filter ORIGIN =
    RadarFilter_Filter_ORIGIN;
  static constexpr Filter FOV =
    RadarFilter_Filter_FOV;
  static constexpr Filter PEAK =
    RadarFilter_Filter_PEAK;
  static constexpr Filter STICKY =
    RadarFilter_Filter_STICKY;
  static constexpr Filter EXTRA_STICKY =
    RadarFilter_Filter_EXTRA_STICKY;
  static constexpr Filter TRANSFORMS =
    RadarFilter_Filter_TRANSFORMS;
  static constexpr Filter ADAM =
    RadarFilter_Filter_ADAM;
  static inline bool Filter_IsValid(int value) {
    return RadarFilter_Filter_IsValid(value);
  }
  static constexpr Filter Filter_MIN =
    RadarFilter_Filter_Filter_MIN;
  static constexpr Filter Filter_MAX =
    RadarFilter_Filter_Filter_MAX;
  static constexpr int Filter_ARRAYSIZE =
    RadarFilter_Filter_Filter_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Filter_descriptor() {
    return RadarFilter_Filter_descriptor();
  }
  template<typename T>
  static inline const std::string& Filter_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Filter>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Filter_Name.");
    return RadarFilter_Filter_Name(enum_t_value);
  }
  static inline bool Filter_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Filter* value) {
    return RadarFilter_Filter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .sensors.RadarFilter.Filter filter = 1;
  void clear_filter();
  ::sensors::RadarFilter_Filter filter() const;
  void set_filter(::sensors::RadarFilter_Filter value);
  private:
  ::sensors::RadarFilter_Filter _internal_filter() const;
  void _internal_set_filter(::sensors::RadarFilter_Filter value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RadarFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RadarCtrl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RadarCtrl) */ {
 public:
  inline RadarCtrl() : RadarCtrl(nullptr) {}
  ~RadarCtrl() override;
  explicit constexpr RadarCtrl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarCtrl(const RadarCtrl& from);
  RadarCtrl(RadarCtrl&& from) noexcept
    : RadarCtrl() {
    *this = ::std::move(from);
  }

  inline RadarCtrl& operator=(const RadarCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarCtrl& operator=(RadarCtrl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarCtrl& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarCtrl* internal_default_instance() {
    return reinterpret_cast<const RadarCtrl*>(
               &_RadarCtrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RadarCtrl& a, RadarCtrl& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarCtrl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarCtrl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadarCtrl* New() const final {
    return new RadarCtrl();
  }

  RadarCtrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadarCtrl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarCtrl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RadarCtrl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarCtrl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RadarCtrl";
  }
  protected:
  explicit RadarCtrl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RadarCtrl_Radar Radar;
  static constexpr Radar UNKNOWN =
    RadarCtrl_Radar_UNKNOWN;
  static constexpr Radar LEFT =
    RadarCtrl_Radar_LEFT;
  static constexpr Radar RIGHT =
    RadarCtrl_Radar_RIGHT;
  static constexpr Radar FRONT =
    RadarCtrl_Radar_FRONT;
  static inline bool Radar_IsValid(int value) {
    return RadarCtrl_Radar_IsValid(value);
  }
  static constexpr Radar Radar_MIN =
    RadarCtrl_Radar_Radar_MIN;
  static constexpr Radar Radar_MAX =
    RadarCtrl_Radar_Radar_MAX;
  static constexpr int Radar_ARRAYSIZE =
    RadarCtrl_Radar_Radar_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Radar_descriptor() {
    return RadarCtrl_Radar_descriptor();
  }
  template<typename T>
  static inline const std::string& Radar_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Radar>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Radar_Name.");
    return RadarCtrl_Radar_Name(enum_t_value);
  }
  static inline bool Radar_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Radar* value) {
    return RadarCtrl_Radar_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRadarFieldNumber = 1,
  };
  // .sensors.RadarCtrl.Radar radar = 1;
  void clear_radar();
  ::sensors::RadarCtrl_Radar radar() const;
  void set_radar(::sensors::RadarCtrl_Radar value);
  private:
  ::sensors::RadarCtrl_Radar _internal_radar() const;
  void _internal_set_radar(::sensors::RadarCtrl_Radar value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RadarCtrl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int radar_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RadarPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RadarPoint) */ {
 public:
  inline RadarPoint() : RadarPoint(nullptr) {}
  ~RadarPoint() override;
  explicit constexpr RadarPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarPoint(const RadarPoint& from);
  RadarPoint(RadarPoint&& from) noexcept
    : RadarPoint() {
    *this = ::std::move(from);
  }

  inline RadarPoint& operator=(const RadarPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarPoint& operator=(RadarPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarPoint* internal_default_instance() {
    return reinterpret_cast<const RadarPoint*>(
               &_RadarPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RadarPoint& a, RadarPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarPoint* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadarPoint* New() const final {
    return new RadarPoint();
  }

  RadarPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadarPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RadarPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RadarPoint";
  }
  protected:
  explicit RadarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kDopplerFieldNumber = 4,
    kCrossSectionFieldNumber = 5,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double doppler = 4;
  void clear_doppler();
  double doppler() const;
  void set_doppler(double value);
  private:
  double _internal_doppler() const;
  void _internal_set_doppler(double value);
  public:

  // double cross_section = 5;
  void clear_cross_section();
  double cross_section() const;
  void set_cross_section(double value);
  private:
  double _internal_cross_section() const;
  void _internal_set_cross_section(double value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RadarPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  double doppler_;
  double cross_section_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RadarPoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RadarPoints) */ {
 public:
  inline RadarPoints() : RadarPoints(nullptr) {}
  ~RadarPoints() override;
  explicit constexpr RadarPoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarPoints(const RadarPoints& from);
  RadarPoints(RadarPoints&& from) noexcept
    : RadarPoints() {
    *this = ::std::move(from);
  }

  inline RadarPoints& operator=(const RadarPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarPoints& operator=(RadarPoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarPoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarPoints* internal_default_instance() {
    return reinterpret_cast<const RadarPoints*>(
               &_RadarPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RadarPoints& a, RadarPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarPoints* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarPoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadarPoints* New() const final {
    return new RadarPoints();
  }

  RadarPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadarPoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarPoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RadarPoints& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarPoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RadarPoints";
  }
  protected:
  explicit RadarPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RadarPoints_Radar Radar;
  static constexpr Radar UNKNOWN =
    RadarPoints_Radar_UNKNOWN;
  static constexpr Radar LEFT =
    RadarPoints_Radar_LEFT;
  static constexpr Radar RIGHT =
    RadarPoints_Radar_RIGHT;
  static constexpr Radar FRONT =
    RadarPoints_Radar_FRONT;
  static inline bool Radar_IsValid(int value) {
    return RadarPoints_Radar_IsValid(value);
  }
  static constexpr Radar Radar_MIN =
    RadarPoints_Radar_Radar_MIN;
  static constexpr Radar Radar_MAX =
    RadarPoints_Radar_Radar_MAX;
  static constexpr int Radar_ARRAYSIZE =
    RadarPoints_Radar_Radar_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Radar_descriptor() {
    return RadarPoints_Radar_descriptor();
  }
  template<typename T>
  static inline const std::string& Radar_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Radar>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Radar_Name.");
    return RadarPoints_Radar_Name(enum_t_value);
  }
  static inline bool Radar_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Radar* value) {
    return RadarPoints_Radar_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kSourceFieldNumber = 2,
  };
  // repeated .sensors.RadarPoint points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::sensors::RadarPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::RadarPoint >*
      mutable_points();
  private:
  const ::sensors::RadarPoint& _internal_points(int index) const;
  ::sensors::RadarPoint* _internal_add_points();
  public:
  const ::sensors::RadarPoint& points(int index) const;
  ::sensors::RadarPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::RadarPoint >&
      points() const;

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .sensors.RadarPoints.Radar source = 2;
  void clear_source();
  ::sensors::RadarPoints_Radar source() const;
  void set_source(::sensors::RadarPoints_Radar value);
  private:
  ::sensors::RadarPoints_Radar _internal_source() const;
  void _internal_set_source(::sensors::RadarPoints_Radar value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RadarPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::RadarPoint > points_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  int source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ChairSpeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ChairSpeed) */ {
 public:
  inline ChairSpeed() : ChairSpeed(nullptr) {}
  ~ChairSpeed() override;
  explicit constexpr ChairSpeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChairSpeed(const ChairSpeed& from);
  ChairSpeed(ChairSpeed&& from) noexcept
    : ChairSpeed() {
    *this = ::std::move(from);
  }

  inline ChairSpeed& operator=(const ChairSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChairSpeed& operator=(ChairSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChairSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChairSpeed* internal_default_instance() {
    return reinterpret_cast<const ChairSpeed*>(
               &_ChairSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ChairSpeed& a, ChairSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(ChairSpeed* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChairSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChairSpeed* New() const final {
    return new ChairSpeed();
  }

  ChairSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChairSpeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChairSpeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChairSpeed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChairSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ChairSpeed";
  }
  protected:
  explicit ChairSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kSpeedMPSFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double speed_m_p_s = 1;
  void clear_speed_m_p_s();
  double speed_m_p_s() const;
  void set_speed_m_p_s(double value);
  private:
  double _internal_speed_m_p_s() const;
  void _internal_set_speed_m_p_s(double value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ChairSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  double speed_m_p_s_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ImuCtrl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ImuCtrl) */ {
 public:
  inline ImuCtrl() : ImuCtrl(nullptr) {}
  ~ImuCtrl() override;
  explicit constexpr ImuCtrl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuCtrl(const ImuCtrl& from);
  ImuCtrl(ImuCtrl&& from) noexcept
    : ImuCtrl() {
    *this = ::std::move(from);
  }

  inline ImuCtrl& operator=(const ImuCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuCtrl& operator=(ImuCtrl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImuCtrl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuCtrl* internal_default_instance() {
    return reinterpret_cast<const ImuCtrl*>(
               &_ImuCtrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ImuCtrl& a, ImuCtrl& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuCtrl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuCtrl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImuCtrl* New() const final {
    return new ImuCtrl();
  }

  ImuCtrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImuCtrl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImuCtrl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImuCtrl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuCtrl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ImuCtrl";
  }
  protected:
  explicit ImuCtrl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImuFieldNumber = 1,
  };
  // .sensors.Imu imu = 1;
  void clear_imu();
  ::sensors::Imu imu() const;
  void set_imu(::sensors::Imu value);
  private:
  ::sensors::Imu _internal_imu() const;
  void _internal_set_imu(::sensors::Imu value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ImuCtrl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int imu_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ImuData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ImuData) */ {
 public:
  inline ImuData() : ImuData(nullptr) {}
  ~ImuData() override;
  explicit constexpr ImuData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuData(const ImuData& from);
  ImuData(ImuData&& from) noexcept
    : ImuData() {
    *this = ::std::move(from);
  }

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuData& operator=(ImuData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImuData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuData* internal_default_instance() {
    return reinterpret_cast<const ImuData*>(
               &_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ImuData& a, ImuData& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImuData* New() const final {
    return new ImuData();
  }

  ImuData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImuData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImuData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImuData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ImuData";
  }
  protected:
  explicit ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImuData_CalibrationStatus CalibrationStatus;
  static constexpr CalibrationStatus NOT_CALIBRATED =
    ImuData_CalibrationStatus_NOT_CALIBRATED;
  static constexpr CalibrationStatus IN_PROGRESS =
    ImuData_CalibrationStatus_IN_PROGRESS;
  static constexpr CalibrationStatus USABLE =
    ImuData_CalibrationStatus_USABLE;
  static constexpr CalibrationStatus COMPLETE =
    ImuData_CalibrationStatus_COMPLETE;
  static inline bool CalibrationStatus_IsValid(int value) {
    return ImuData_CalibrationStatus_IsValid(value);
  }
  static constexpr CalibrationStatus CalibrationStatus_MIN =
    ImuData_CalibrationStatus_CalibrationStatus_MIN;
  static constexpr CalibrationStatus CalibrationStatus_MAX =
    ImuData_CalibrationStatus_CalibrationStatus_MAX;
  static constexpr int CalibrationStatus_ARRAYSIZE =
    ImuData_CalibrationStatus_CalibrationStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CalibrationStatus_descriptor() {
    return ImuData_CalibrationStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& CalibrationStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CalibrationStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CalibrationStatus_Name.");
    return ImuData_CalibrationStatus_Name(enum_t_value);
  }
  static inline bool CalibrationStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CalibrationStatus* value) {
    return ImuData_CalibrationStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 27,
    kQuaternionXFieldNumber = 1,
    kQuaternionYFieldNumber = 2,
    kQuaternionZFieldNumber = 3,
    kQuaternionWFieldNumber = 4,
    kAccelerationXFieldNumber = 5,
    kAccelerationYFieldNumber = 6,
    kAccelerationZFieldNumber = 7,
    kGyroXFieldNumber = 8,
    kGyroYFieldNumber = 9,
    kGyroZFieldNumber = 10,
    kEulerXFieldNumber = 11,
    kEulerYFieldNumber = 12,
    kEulerZFieldNumber = 13,
    kAccelerometerXFieldNumber = 14,
    kAccelerometerYFieldNumber = 15,
    kAccelerometerZFieldNumber = 16,
    kMagnetometerXFieldNumber = 17,
    kMagnetometerYFieldNumber = 18,
    kMagnetometerZFieldNumber = 19,
    kGravityXFieldNumber = 20,
    kGravityYFieldNumber = 21,
    kGravityZFieldNumber = 22,
    kCalSystemFieldNumber = 23,
    kCalGyroscopeFieldNumber = 24,
    kCalAccelerometerFieldNumber = 25,
    kCalMagnetometerFieldNumber = 26,
    kSourceFieldNumber = 28,
  };
  // .google.protobuf.Timestamp timestamp = 27;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double quaternion_x = 1;
  void clear_quaternion_x();
  double quaternion_x() const;
  void set_quaternion_x(double value);
  private:
  double _internal_quaternion_x() const;
  void _internal_set_quaternion_x(double value);
  public:

  // double quaternion_y = 2;
  void clear_quaternion_y();
  double quaternion_y() const;
  void set_quaternion_y(double value);
  private:
  double _internal_quaternion_y() const;
  void _internal_set_quaternion_y(double value);
  public:

  // double quaternion_z = 3;
  void clear_quaternion_z();
  double quaternion_z() const;
  void set_quaternion_z(double value);
  private:
  double _internal_quaternion_z() const;
  void _internal_set_quaternion_z(double value);
  public:

  // double quaternion_w = 4;
  void clear_quaternion_w();
  double quaternion_w() const;
  void set_quaternion_w(double value);
  private:
  double _internal_quaternion_w() const;
  void _internal_set_quaternion_w(double value);
  public:

  // double acceleration_x = 5;
  void clear_acceleration_x();
  double acceleration_x() const;
  void set_acceleration_x(double value);
  private:
  double _internal_acceleration_x() const;
  void _internal_set_acceleration_x(double value);
  public:

  // double acceleration_y = 6;
  void clear_acceleration_y();
  double acceleration_y() const;
  void set_acceleration_y(double value);
  private:
  double _internal_acceleration_y() const;
  void _internal_set_acceleration_y(double value);
  public:

  // double acceleration_z = 7;
  void clear_acceleration_z();
  double acceleration_z() const;
  void set_acceleration_z(double value);
  private:
  double _internal_acceleration_z() const;
  void _internal_set_acceleration_z(double value);
  public:

  // double gyro_x = 8;
  void clear_gyro_x();
  double gyro_x() const;
  void set_gyro_x(double value);
  private:
  double _internal_gyro_x() const;
  void _internal_set_gyro_x(double value);
  public:

  // double gyro_y = 9;
  void clear_gyro_y();
  double gyro_y() const;
  void set_gyro_y(double value);
  private:
  double _internal_gyro_y() const;
  void _internal_set_gyro_y(double value);
  public:

  // double gyro_z = 10;
  void clear_gyro_z();
  double gyro_z() const;
  void set_gyro_z(double value);
  private:
  double _internal_gyro_z() const;
  void _internal_set_gyro_z(double value);
  public:

  // double euler_x = 11;
  void clear_euler_x();
  double euler_x() const;
  void set_euler_x(double value);
  private:
  double _internal_euler_x() const;
  void _internal_set_euler_x(double value);
  public:

  // double euler_y = 12;
  void clear_euler_y();
  double euler_y() const;
  void set_euler_y(double value);
  private:
  double _internal_euler_y() const;
  void _internal_set_euler_y(double value);
  public:

  // double euler_z = 13;
  void clear_euler_z();
  double euler_z() const;
  void set_euler_z(double value);
  private:
  double _internal_euler_z() const;
  void _internal_set_euler_z(double value);
  public:

  // double accelerometer_x = 14;
  void clear_accelerometer_x();
  double accelerometer_x() const;
  void set_accelerometer_x(double value);
  private:
  double _internal_accelerometer_x() const;
  void _internal_set_accelerometer_x(double value);
  public:

  // double accelerometer_y = 15;
  void clear_accelerometer_y();
  double accelerometer_y() const;
  void set_accelerometer_y(double value);
  private:
  double _internal_accelerometer_y() const;
  void _internal_set_accelerometer_y(double value);
  public:

  // double accelerometer_z = 16;
  void clear_accelerometer_z();
  double accelerometer_z() const;
  void set_accelerometer_z(double value);
  private:
  double _internal_accelerometer_z() const;
  void _internal_set_accelerometer_z(double value);
  public:

  // double magnetometer_x = 17;
  void clear_magnetometer_x();
  double magnetometer_x() const;
  void set_magnetometer_x(double value);
  private:
  double _internal_magnetometer_x() const;
  void _internal_set_magnetometer_x(double value);
  public:

  // double magnetometer_y = 18;
  void clear_magnetometer_y();
  double magnetometer_y() const;
  void set_magnetometer_y(double value);
  private:
  double _internal_magnetometer_y() const;
  void _internal_set_magnetometer_y(double value);
  public:

  // double magnetometer_z = 19;
  void clear_magnetometer_z();
  double magnetometer_z() const;
  void set_magnetometer_z(double value);
  private:
  double _internal_magnetometer_z() const;
  void _internal_set_magnetometer_z(double value);
  public:

  // double gravity_x = 20;
  void clear_gravity_x();
  double gravity_x() const;
  void set_gravity_x(double value);
  private:
  double _internal_gravity_x() const;
  void _internal_set_gravity_x(double value);
  public:

  // double gravity_y = 21;
  void clear_gravity_y();
  double gravity_y() const;
  void set_gravity_y(double value);
  private:
  double _internal_gravity_y() const;
  void _internal_set_gravity_y(double value);
  public:

  // double gravity_z = 22;
  void clear_gravity_z();
  double gravity_z() const;
  void set_gravity_z(double value);
  private:
  double _internal_gravity_z() const;
  void _internal_set_gravity_z(double value);
  public:

  // .sensors.ImuData.CalibrationStatus cal_system = 23;
  void clear_cal_system();
  ::sensors::ImuData_CalibrationStatus cal_system() const;
  void set_cal_system(::sensors::ImuData_CalibrationStatus value);
  private:
  ::sensors::ImuData_CalibrationStatus _internal_cal_system() const;
  void _internal_set_cal_system(::sensors::ImuData_CalibrationStatus value);
  public:

  // .sensors.ImuData.CalibrationStatus cal_gyroscope = 24;
  void clear_cal_gyroscope();
  ::sensors::ImuData_CalibrationStatus cal_gyroscope() const;
  void set_cal_gyroscope(::sensors::ImuData_CalibrationStatus value);
  private:
  ::sensors::ImuData_CalibrationStatus _internal_cal_gyroscope() const;
  void _internal_set_cal_gyroscope(::sensors::ImuData_CalibrationStatus value);
  public:

  // .sensors.ImuData.CalibrationStatus cal_accelerometer = 25;
  void clear_cal_accelerometer();
  ::sensors::ImuData_CalibrationStatus cal_accelerometer() const;
  void set_cal_accelerometer(::sensors::ImuData_CalibrationStatus value);
  private:
  ::sensors::ImuData_CalibrationStatus _internal_cal_accelerometer() const;
  void _internal_set_cal_accelerometer(::sensors::ImuData_CalibrationStatus value);
  public:

  // .sensors.ImuData.CalibrationStatus cal_magnetometer = 26;
  void clear_cal_magnetometer();
  ::sensors::ImuData_CalibrationStatus cal_magnetometer() const;
  void set_cal_magnetometer(::sensors::ImuData_CalibrationStatus value);
  private:
  ::sensors::ImuData_CalibrationStatus _internal_cal_magnetometer() const;
  void _internal_set_cal_magnetometer(::sensors::ImuData_CalibrationStatus value);
  public:

  // .sensors.Imu source = 28;
  void clear_source();
  ::sensors::Imu source() const;
  void set_source(::sensors::Imu value);
  private:
  ::sensors::Imu _internal_source() const;
  void _internal_set_source(::sensors::Imu value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ImuData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  double quaternion_x_;
  double quaternion_y_;
  double quaternion_z_;
  double quaternion_w_;
  double acceleration_x_;
  double acceleration_y_;
  double acceleration_z_;
  double gyro_x_;
  double gyro_y_;
  double gyro_z_;
  double euler_x_;
  double euler_y_;
  double euler_z_;
  double accelerometer_x_;
  double accelerometer_y_;
  double accelerometer_z_;
  double magnetometer_x_;
  double magnetometer_y_;
  double magnetometer_z_;
  double gravity_x_;
  double gravity_y_;
  double gravity_z_;
  int cal_system_;
  int cal_gyroscope_;
  int cal_accelerometer_;
  int cal_magnetometer_;
  int source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ChairMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ChairMode) */ {
 public:
  inline ChairMode() : ChairMode(nullptr) {}
  ~ChairMode() override;
  explicit constexpr ChairMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChairMode(const ChairMode& from);
  ChairMode(ChairMode&& from) noexcept
    : ChairMode() {
    *this = ::std::move(from);
  }

  inline ChairMode& operator=(const ChairMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChairMode& operator=(ChairMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChairMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChairMode* internal_default_instance() {
    return reinterpret_cast<const ChairMode*>(
               &_ChairMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ChairMode& a, ChairMode& b) {
    a.Swap(&b);
  }
  inline void Swap(ChairMode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChairMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChairMode* New() const final {
    return new ChairMode();
  }

  ChairMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChairMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChairMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChairMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChairMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ChairMode";
  }
  protected:
  explicit ChairMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsDriveModeFieldNumber = 1,
  };
  // bool is_drive_mode = 1;
  void clear_is_drive_mode();
  bool is_drive_mode() const;
  void set_is_drive_mode(bool value);
  private:
  bool _internal_is_drive_mode() const;
  void _internal_set_is_drive_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ChairMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_drive_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ChairProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ChairProfile) */ {
 public:
  inline ChairProfile() : ChairProfile(nullptr) {}
  ~ChairProfile() override;
  explicit constexpr ChairProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChairProfile(const ChairProfile& from);
  ChairProfile(ChairProfile&& from) noexcept
    : ChairProfile() {
    *this = ::std::move(from);
  }

  inline ChairProfile& operator=(const ChairProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChairProfile& operator=(ChairProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChairProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChairProfile* internal_default_instance() {
    return reinterpret_cast<const ChairProfile*>(
               &_ChairProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ChairProfile& a, ChairProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ChairProfile* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChairProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChairProfile* New() const final {
    return new ChairProfile();
  }

  ChairProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChairProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChairProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChairProfile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChairProfile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ChairProfile";
  }
  protected:
  explicit ChairProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileFieldNumber = 1,
  };
  // int32 profile = 1;
  void clear_profile();
  ::PROTOBUF_NAMESPACE_ID::int32 profile() const;
  void set_profile(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_profile() const;
  void _internal_set_profile(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ChairProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 profile_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class SpeedSetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.SpeedSetting) */ {
 public:
  inline SpeedSetting() : SpeedSetting(nullptr) {}
  ~SpeedSetting() override;
  explicit constexpr SpeedSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeedSetting(const SpeedSetting& from);
  SpeedSetting(SpeedSetting&& from) noexcept
    : SpeedSetting() {
    *this = ::std::move(from);
  }

  inline SpeedSetting& operator=(const SpeedSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedSetting& operator=(SpeedSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeedSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeedSetting* internal_default_instance() {
    return reinterpret_cast<const SpeedSetting*>(
               &_SpeedSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SpeedSetting& a, SpeedSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedSetting* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedSetting* New() const final {
    return new SpeedSetting();
  }

  SpeedSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedSetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeedSetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpeedSetting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedSetting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.SpeedSetting";
  }
  protected:
  explicit SpeedSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedSettingFieldNumber = 1,
  };
  // int32 speed_setting = 1;
  void clear_speed_setting();
  ::PROTOBUF_NAMESPACE_ID::int32 speed_setting() const;
  void set_speed_setting(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_speed_setting() const;
  void _internal_set_speed_setting(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.SpeedSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 speed_setting_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class JoystickData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.JoystickData) */ {
 public:
  inline JoystickData() : JoystickData(nullptr) {}
  ~JoystickData() override;
  explicit constexpr JoystickData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoystickData(const JoystickData& from);
  JoystickData(JoystickData&& from) noexcept
    : JoystickData() {
    *this = ::std::move(from);
  }

  inline JoystickData& operator=(const JoystickData& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoystickData& operator=(JoystickData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoystickData& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoystickData* internal_default_instance() {
    return reinterpret_cast<const JoystickData*>(
               &_JoystickData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(JoystickData& a, JoystickData& b) {
    a.Swap(&b);
  }
  inline void Swap(JoystickData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoystickData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoystickData* New() const final {
    return new JoystickData();
  }

  JoystickData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoystickData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoystickData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoystickData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoystickData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.JoystickData";
  }
  protected:
  explicit JoystickData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoystickZoneFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kForwardBackFieldNumber = 1,
    kLeftRightFieldNumber = 2,
  };
  // string joystick_zone = 3;
  void clear_joystick_zone();
  const std::string& joystick_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_joystick_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_joystick_zone();
  PROTOBUF_MUST_USE_RESULT std::string* release_joystick_zone();
  void set_allocated_joystick_zone(std::string* joystick_zone);
  private:
  const std::string& _internal_joystick_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_joystick_zone(const std::string& value);
  std::string* _internal_mutable_joystick_zone();
  public:

  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int32 forward_back = 1;
  void clear_forward_back();
  ::PROTOBUF_NAMESPACE_ID::int32 forward_back() const;
  void set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_forward_back() const;
  void _internal_set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 left_right = 2;
  void clear_left_right();
  ::PROTOBUF_NAMESPACE_ID::int32 left_right() const;
  void set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_right() const;
  void _internal_set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.JoystickData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joystick_zone_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 forward_back_;
  ::PROTOBUF_NAMESPACE_ID::int32 left_right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Joystick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Joystick) */ {
 public:
  inline Joystick() : Joystick(nullptr) {}
  ~Joystick() override;
  explicit constexpr Joystick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Joystick(const Joystick& from);
  Joystick(Joystick&& from) noexcept
    : Joystick() {
    *this = ::std::move(from);
  }

  inline Joystick& operator=(const Joystick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joystick& operator=(Joystick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joystick& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joystick* internal_default_instance() {
    return reinterpret_cast<const Joystick*>(
               &_Joystick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Joystick& a, Joystick& b) {
    a.Swap(&b);
  }
  inline void Swap(Joystick* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joystick* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Joystick* New() const final {
    return new Joystick();
  }

  Joystick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Joystick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Joystick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Joystick& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joystick* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Joystick";
  }
  protected:
  explicit Joystick(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForwardBackFieldNumber = 1,
    kLeftRightFieldNumber = 2,
  };
  // int32 forward_back = 1;
  void clear_forward_back();
  ::PROTOBUF_NAMESPACE_ID::int32 forward_back() const;
  void set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_forward_back() const;
  void _internal_set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 left_right = 2;
  void clear_left_right();
  ::PROTOBUF_NAMESPACE_ID::int32 left_right() const;
  void set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_right() const;
  void _internal_set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Joystick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 forward_back_;
  ::PROTOBUF_NAMESPACE_ID::int32 left_right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class BatteryVoltage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.BatteryVoltage) */ {
 public:
  inline BatteryVoltage() : BatteryVoltage(nullptr) {}
  ~BatteryVoltage() override;
  explicit constexpr BatteryVoltage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryVoltage(const BatteryVoltage& from);
  BatteryVoltage(BatteryVoltage&& from) noexcept
    : BatteryVoltage() {
    *this = ::std::move(from);
  }

  inline BatteryVoltage& operator=(const BatteryVoltage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryVoltage& operator=(BatteryVoltage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryVoltage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryVoltage* internal_default_instance() {
    return reinterpret_cast<const BatteryVoltage*>(
               &_BatteryVoltage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(BatteryVoltage& a, BatteryVoltage& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryVoltage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryVoltage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatteryVoltage* New() const final {
    return new BatteryVoltage();
  }

  BatteryVoltage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatteryVoltage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryVoltage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatteryVoltage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryVoltage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.BatteryVoltage";
  }
  protected:
  explicit BatteryVoltage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryVoltageFieldNumber = 1,
  };
  // double battery_voltage = 1;
  void clear_battery_voltage();
  double battery_voltage() const;
  void set_battery_voltage(double value);
  private:
  double _internal_battery_voltage() const;
  void _internal_set_battery_voltage(double value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.BatteryVoltage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double battery_voltage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class BatteryPercent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.BatteryPercent) */ {
 public:
  inline BatteryPercent() : BatteryPercent(nullptr) {}
  ~BatteryPercent() override;
  explicit constexpr BatteryPercent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryPercent(const BatteryPercent& from);
  BatteryPercent(BatteryPercent&& from) noexcept
    : BatteryPercent() {
    *this = ::std::move(from);
  }

  inline BatteryPercent& operator=(const BatteryPercent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryPercent& operator=(BatteryPercent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryPercent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryPercent* internal_default_instance() {
    return reinterpret_cast<const BatteryPercent*>(
               &_BatteryPercent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(BatteryPercent& a, BatteryPercent& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryPercent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryPercent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatteryPercent* New() const final {
    return new BatteryPercent();
  }

  BatteryPercent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatteryPercent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryPercent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatteryPercent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryPercent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.BatteryPercent";
  }
  protected:
  explicit BatteryPercent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryPercentageFieldNumber = 1,
  };
  // int32 battery_percentage = 1;
  void clear_battery_percentage();
  ::PROTOBUF_NAMESPACE_ID::int32 battery_percentage() const;
  void set_battery_percentage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_battery_percentage() const;
  void _internal_set_battery_percentage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.BatteryPercent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 battery_percentage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class GPSData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.GPSData) */ {
 public:
  inline GPSData() : GPSData(nullptr) {}
  ~GPSData() override;
  explicit constexpr GPSData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPSData(const GPSData& from);
  GPSData(GPSData&& from) noexcept
    : GPSData() {
    *this = ::std::move(from);
  }

  inline GPSData& operator=(const GPSData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPSData& operator=(GPSData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPSData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPSData* internal_default_instance() {
    return reinterpret_cast<const GPSData*>(
               &_GPSData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(GPSData& a, GPSData& b) {
    a.Swap(&b);
  }
  inline void Swap(GPSData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPSData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GPSData* New() const final {
    return new GPSData();
  }

  GPSData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GPSData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GPSData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GPSData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPSData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.GPSData";
  }
  protected:
  explicit GPSData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GPSData_quality_t quality_t;
  static constexpr quality_t no_fix =
    GPSData_quality_t_no_fix;
  static constexpr quality_t standard_gps_2d_3d =
    GPSData_quality_t_standard_gps_2d_3d;
  static constexpr quality_t differential_gps =
    GPSData_quality_t_differential_gps;
  static constexpr quality_t rtk_fixed_solution =
    GPSData_quality_t_rtk_fixed_solution;
  static constexpr quality_t rtk_float_solution =
    GPSData_quality_t_rtk_float_solution;
  static constexpr quality_t estimated_dr =
    GPSData_quality_t_estimated_dr;
  static inline bool quality_t_IsValid(int value) {
    return GPSData_quality_t_IsValid(value);
  }
  static constexpr quality_t quality_t_MIN =
    GPSData_quality_t_quality_t_MIN;
  static constexpr quality_t quality_t_MAX =
    GPSData_quality_t_quality_t_MAX;
  static constexpr int quality_t_ARRAYSIZE =
    GPSData_quality_t_quality_t_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  quality_t_descriptor() {
    return GPSData_quality_t_descriptor();
  }
  template<typename T>
  static inline const std::string& quality_t_Name(T enum_t_value) {
    static_assert(::std::is_same<T, quality_t>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function quality_t_Name.");
    return GPSData_quality_t_Name(enum_t_value);
  }
  static inline bool quality_t_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      quality_t* value) {
    return GPSData_quality_t_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kHeadingOfMotionFieldNumber = 3,
    kNumberOfSvFieldNumber = 4,
    kHDOPFieldNumber = 5,
    kHeightAboveSeaFieldNumber = 6,
    kGroundSpeedFieldNumber = 7,
    kQualityFieldNumber = 8,
    kYearFieldNumber = 9,
    kMonthFieldNumber = 10,
    kDayFieldNumber = 11,
    kHourFieldNumber = 12,
    kMinuteFieldNumber = 13,
    kSecondFieldNumber = 14,
  };
  // int32 latitude = 1;
  void clear_latitude();
  ::PROTOBUF_NAMESPACE_ID::int32 latitude() const;
  void set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latitude() const;
  void _internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 longitude = 2;
  void clear_longitude();
  ::PROTOBUF_NAMESPACE_ID::int32 longitude() const;
  void set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_longitude() const;
  void _internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 heading_of_motion = 3;
  void clear_heading_of_motion();
  ::PROTOBUF_NAMESPACE_ID::int32 heading_of_motion() const;
  void set_heading_of_motion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_heading_of_motion() const;
  void _internal_set_heading_of_motion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 number_of_sv = 4;
  void clear_number_of_sv();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_sv() const;
  void set_number_of_sv(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number_of_sv() const;
  void _internal_set_number_of_sv(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 hDOP = 5;
  void clear_hdop();
  ::PROTOBUF_NAMESPACE_ID::uint32 hdop() const;
  void set_hdop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hdop() const;
  void _internal_set_hdop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 height_above_sea = 6;
  void clear_height_above_sea();
  ::PROTOBUF_NAMESPACE_ID::int32 height_above_sea() const;
  void set_height_above_sea(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height_above_sea() const;
  void _internal_set_height_above_sea(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ground_speed = 7;
  void clear_ground_speed();
  ::PROTOBUF_NAMESPACE_ID::int32 ground_speed() const;
  void set_ground_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ground_speed() const;
  void _internal_set_ground_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .sensors.GPSData.quality_t quality = 8;
  void clear_quality();
  ::sensors::GPSData_quality_t quality() const;
  void set_quality(::sensors::GPSData_quality_t value);
  private:
  ::sensors::GPSData_quality_t _internal_quality() const;
  void _internal_set_quality(::sensors::GPSData_quality_t value);
  public:

  // int32 year = 9;
  void clear_year();
  ::PROTOBUF_NAMESPACE_ID::int32 year() const;
  void set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_year() const;
  void _internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 month = 10;
  void clear_month();
  ::PROTOBUF_NAMESPACE_ID::int32 month() const;
  void set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_month() const;
  void _internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 day = 11;
  void clear_day();
  ::PROTOBUF_NAMESPACE_ID::int32 day() const;
  void set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_day() const;
  void _internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hour = 12;
  void clear_hour();
  ::PROTOBUF_NAMESPACE_ID::int32 hour() const;
  void set_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hour() const;
  void _internal_set_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 minute = 13;
  void clear_minute();
  ::PROTOBUF_NAMESPACE_ID::int32 minute() const;
  void set_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minute() const;
  void _internal_set_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 second = 14;
  void clear_second();
  ::PROTOBUF_NAMESPACE_ID::int32 second() const;
  void set_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_second() const;
  void _internal_set_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.GPSData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 heading_of_motion_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_sv_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hdop_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_above_sea_;
  ::PROTOBUF_NAMESPACE_ID::int32 ground_speed_;
  int quality_;
  ::PROTOBUF_NAMESPACE_ID::int32 year_;
  ::PROTOBUF_NAMESPACE_ID::int32 month_;
  ::PROTOBUF_NAMESPACE_ID::int32 day_;
  ::PROTOBUF_NAMESPACE_ID::int32 hour_;
  ::PROTOBUF_NAMESPACE_ID::int32 minute_;
  ::PROTOBUF_NAMESPACE_ID::int32 second_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class EncoderData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.EncoderData) */ {
 public:
  inline EncoderData() : EncoderData(nullptr) {}
  ~EncoderData() override;
  explicit constexpr EncoderData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncoderData(const EncoderData& from);
  EncoderData(EncoderData&& from) noexcept
    : EncoderData() {
    *this = ::std::move(from);
  }

  inline EncoderData& operator=(const EncoderData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncoderData& operator=(EncoderData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncoderData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncoderData* internal_default_instance() {
    return reinterpret_cast<const EncoderData*>(
               &_EncoderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(EncoderData& a, EncoderData& b) {
    a.Swap(&b);
  }
  inline void Swap(EncoderData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncoderData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncoderData* New() const final {
    return new EncoderData();
  }

  EncoderData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncoderData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncoderData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EncoderData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncoderData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.EncoderData";
  }
  protected:
  explicit EncoderData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 7,
    kLeftAngleFieldNumber = 1,
    kRightAngleFieldNumber = 2,
    kFlCasterDegreesFieldNumber = 3,
    kBlCasterDegreesFieldNumber = 4,
    kFrCasterDegreesFieldNumber = 5,
    kBrCasterDegreesFieldNumber = 6,
  };
  // .google.protobuf.Timestamp timestamp = 7;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // float left_angle = 1;
  void clear_left_angle();
  float left_angle() const;
  void set_left_angle(float value);
  private:
  float _internal_left_angle() const;
  void _internal_set_left_angle(float value);
  public:

  // float right_angle = 2;
  void clear_right_angle();
  float right_angle() const;
  void set_right_angle(float value);
  private:
  float _internal_right_angle() const;
  void _internal_set_right_angle(float value);
  public:

  // float fl_caster_degrees = 3;
  void clear_fl_caster_degrees();
  float fl_caster_degrees() const;
  void set_fl_caster_degrees(float value);
  private:
  float _internal_fl_caster_degrees() const;
  void _internal_set_fl_caster_degrees(float value);
  public:

  // float bl_caster_degrees = 4;
  void clear_bl_caster_degrees();
  float bl_caster_degrees() const;
  void set_bl_caster_degrees(float value);
  private:
  float _internal_bl_caster_degrees() const;
  void _internal_set_bl_caster_degrees(float value);
  public:

  // float fr_caster_degrees = 5;
  void clear_fr_caster_degrees();
  float fr_caster_degrees() const;
  void set_fr_caster_degrees(float value);
  private:
  float _internal_fr_caster_degrees() const;
  void _internal_set_fr_caster_degrees(float value);
  public:

  // float br_caster_degrees = 6;
  void clear_br_caster_degrees();
  float br_caster_degrees() const;
  void set_br_caster_degrees(float value);
  private:
  float _internal_br_caster_degrees() const;
  void _internal_set_br_caster_degrees(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.EncoderData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  float left_angle_;
  float right_angle_;
  float fl_caster_degrees_;
  float bl_caster_degrees_;
  float fr_caster_degrees_;
  float br_caster_degrees_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  explicit constexpr Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const final {
    return new Vec3();
  }

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Vec3";
  }
  protected:
  explicit Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class Vec4 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Vec4) */ {
 public:
  inline Vec4() : Vec4(nullptr) {}
  ~Vec4() override;
  explicit constexpr Vec4(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec4(const Vec4& from);
  Vec4(Vec4&& from) noexcept
    : Vec4() {
    *this = ::std::move(from);
  }

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec4& operator=(Vec4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec4* internal_default_instance() {
    return reinterpret_cast<const Vec4*>(
               &_Vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Vec4& a, Vec4& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec4* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec4* New() const final {
    return new Vec4();
  }

  Vec4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec4>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec4& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec4& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Vec4";
  }
  protected:
  explicit Vec4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // float w = 1;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Vec4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float w_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class IrFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.IrFrame) */ {
 public:
  inline IrFrame() : IrFrame(nullptr) {}
  ~IrFrame() override;
  explicit constexpr IrFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IrFrame(const IrFrame& from);
  IrFrame(IrFrame&& from) noexcept
    : IrFrame() {
    *this = ::std::move(from);
  }

  inline IrFrame& operator=(const IrFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline IrFrame& operator=(IrFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IrFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const IrFrame* internal_default_instance() {
    return reinterpret_cast<const IrFrame*>(
               &_IrFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(IrFrame& a, IrFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(IrFrame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IrFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IrFrame* New() const final {
    return new IrFrame();
  }

  IrFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IrFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IrFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IrFrame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IrFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.IrFrame";
  }
  protected:
  explicit IrFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
    kCameraFieldNumber = 4,
    kTimestampFieldNumber = 6,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kSizeFieldNumber = 5,
  };
  // bytes frame = 1;
  void clear_frame();
  const std::string& frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame();
  PROTOBUF_MUST_USE_RESULT std::string* release_frame();
  void set_allocated_frame(std::string* frame);
  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
  std::string* _internal_mutable_frame();
  public:

  // string camera = 4;
  void clear_camera();
  const std::string& camera() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera();
  PROTOBUF_MUST_USE_RESULT std::string* release_camera();
  void set_allocated_camera(std::string* camera);
  private:
  const std::string& _internal_camera() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera(const std::string& value);
  std::string* _internal_mutable_camera();
  public:

  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int32 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 size = 5;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.IrFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class AhrsData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.AhrsData) */ {
 public:
  inline AhrsData() : AhrsData(nullptr) {}
  ~AhrsData() override;
  explicit constexpr AhrsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AhrsData(const AhrsData& from);
  AhrsData(AhrsData&& from) noexcept
    : AhrsData() {
    *this = ::std::move(from);
  }

  inline AhrsData& operator=(const AhrsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AhrsData& operator=(AhrsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AhrsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AhrsData* internal_default_instance() {
    return reinterpret_cast<const AhrsData*>(
               &_AhrsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(AhrsData& a, AhrsData& b) {
    a.Swap(&b);
  }
  inline void Swap(AhrsData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AhrsData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AhrsData* New() const final {
    return new AhrsData();
  }

  AhrsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AhrsData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AhrsData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AhrsData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AhrsData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.AhrsData";
  }
  protected:
  explicit AhrsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearVelocityFieldNumber = 1,
    kLinearAccelerationFieldNumber = 2,
    kAngularVelocityFieldNumber = 3,
    kAngularAccelerationFieldNumber = 4,
    kOrientationFieldNumber = 5,
    kTimestampFieldNumber = 6,
  };
  // .sensors.Vec3 linear_velocity = 1;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::sensors::Vec3& linear_velocity() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::Vec3* release_linear_velocity();
  ::sensors::Vec3* mutable_linear_velocity();
  void set_allocated_linear_velocity(::sensors::Vec3* linear_velocity);
  private:
  const ::sensors::Vec3& _internal_linear_velocity() const;
  ::sensors::Vec3* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::sensors::Vec3* linear_velocity);
  ::sensors::Vec3* unsafe_arena_release_linear_velocity();

  // .sensors.Vec3 linear_acceleration = 2;
  bool has_linear_acceleration() const;
  private:
  bool _internal_has_linear_acceleration() const;
  public:
  void clear_linear_acceleration();
  const ::sensors::Vec3& linear_acceleration() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::Vec3* release_linear_acceleration();
  ::sensors::Vec3* mutable_linear_acceleration();
  void set_allocated_linear_acceleration(::sensors::Vec3* linear_acceleration);
  private:
  const ::sensors::Vec3& _internal_linear_acceleration() const;
  ::sensors::Vec3* _internal_mutable_linear_acceleration();
  public:
  void unsafe_arena_set_allocated_linear_acceleration(
      ::sensors::Vec3* linear_acceleration);
  ::sensors::Vec3* unsafe_arena_release_linear_acceleration();

  // .sensors.Vec3 angular_velocity = 3;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::sensors::Vec3& angular_velocity() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::Vec3* release_angular_velocity();
  ::sensors::Vec3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::sensors::Vec3* angular_velocity);
  private:
  const ::sensors::Vec3& _internal_angular_velocity() const;
  ::sensors::Vec3* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::sensors::Vec3* angular_velocity);
  ::sensors::Vec3* unsafe_arena_release_angular_velocity();

  // .sensors.Vec3 angular_acceleration = 4;
  bool has_angular_acceleration() const;
  private:
  bool _internal_has_angular_acceleration() const;
  public:
  void clear_angular_acceleration();
  const ::sensors::Vec3& angular_acceleration() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::Vec3* release_angular_acceleration();
  ::sensors::Vec3* mutable_angular_acceleration();
  void set_allocated_angular_acceleration(::sensors::Vec3* angular_acceleration);
  private:
  const ::sensors::Vec3& _internal_angular_acceleration() const;
  ::sensors::Vec3* _internal_mutable_angular_acceleration();
  public:
  void unsafe_arena_set_allocated_angular_acceleration(
      ::sensors::Vec3* angular_acceleration);
  ::sensors::Vec3* unsafe_arena_release_angular_acceleration();

  // .sensors.Vec4 orientation = 5;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::sensors::Vec4& orientation() const;
  PROTOBUF_MUST_USE_RESULT ::sensors::Vec4* release_orientation();
  ::sensors::Vec4* mutable_orientation();
  void set_allocated_orientation(::sensors::Vec4* orientation);
  private:
  const ::sensors::Vec4& _internal_orientation() const;
  ::sensors::Vec4* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::sensors::Vec4* orientation);
  ::sensors::Vec4* unsafe_arena_release_orientation();

  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sensors.AhrsData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensors::Vec3* linear_velocity_;
  ::sensors::Vec3* linear_acceleration_;
  ::sensors::Vec3* angular_velocity_;
  ::sensors::Vec3* angular_acceleration_;
  ::sensors::Vec4* orientation_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RemoteJsValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RemoteJsValues) */ {
 public:
  inline RemoteJsValues() : RemoteJsValues(nullptr) {}
  ~RemoteJsValues() override;
  explicit constexpr RemoteJsValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteJsValues(const RemoteJsValues& from);
  RemoteJsValues(RemoteJsValues&& from) noexcept
    : RemoteJsValues() {
    *this = ::std::move(from);
  }

  inline RemoteJsValues& operator=(const RemoteJsValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteJsValues& operator=(RemoteJsValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteJsValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteJsValues* internal_default_instance() {
    return reinterpret_cast<const RemoteJsValues*>(
               &_RemoteJsValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(RemoteJsValues& a, RemoteJsValues& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteJsValues* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteJsValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteJsValues* New() const final {
    return new RemoteJsValues();
  }

  RemoteJsValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteJsValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteJsValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteJsValues& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteJsValues* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RemoteJsValues";
  }
  protected:
  explicit RemoteJsValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForwardBackFieldNumber = 1,
    kLeftRightFieldNumber = 2,
  };
  // int32 forward_back = 1;
  void clear_forward_back();
  ::PROTOBUF_NAMESPACE_ID::int32 forward_back() const;
  void set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_forward_back() const;
  void _internal_set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 left_right = 2;
  void clear_left_right();
  ::PROTOBUF_NAMESPACE_ID::int32 left_right() const;
  void set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_right() const;
  void _internal_set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RemoteJsValues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 forward_back_;
  ::PROTOBUF_NAMESPACE_ID::int32 left_right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class ModeCtrl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.ModeCtrl) */ {
 public:
  inline ModeCtrl() : ModeCtrl(nullptr) {}
  ~ModeCtrl() override;
  explicit constexpr ModeCtrl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModeCtrl(const ModeCtrl& from);
  ModeCtrl(ModeCtrl&& from) noexcept
    : ModeCtrl() {
    *this = ::std::move(from);
  }

  inline ModeCtrl& operator=(const ModeCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModeCtrl& operator=(ModeCtrl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModeCtrl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModeCtrl* internal_default_instance() {
    return reinterpret_cast<const ModeCtrl*>(
               &_ModeCtrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ModeCtrl& a, ModeCtrl& b) {
    a.Swap(&b);
  }
  inline void Swap(ModeCtrl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModeCtrl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModeCtrl* New() const final {
    return new ModeCtrl();
  }

  ModeCtrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModeCtrl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModeCtrl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModeCtrl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModeCtrl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.ModeCtrl";
  }
  protected:
  explicit ModeCtrl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .sensors.DriveMode mode = 1;
  void clear_mode();
  ::sensors::DriveMode mode() const;
  void set_mode(::sensors::DriveMode value);
  private:
  ::sensors::DriveMode _internal_mode() const;
  void _internal_set_mode(::sensors::DriveMode value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.ModeCtrl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RampMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RampMode) */ {
 public:
  inline RampMode() : RampMode(nullptr) {}
  ~RampMode() override;
  explicit constexpr RampMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RampMode(const RampMode& from);
  RampMode(RampMode&& from) noexcept
    : RampMode() {
    *this = ::std::move(from);
  }

  inline RampMode& operator=(const RampMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RampMode& operator=(RampMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RampMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RampMode* internal_default_instance() {
    return reinterpret_cast<const RampMode*>(
               &_RampMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(RampMode& a, RampMode& b) {
    a.Swap(&b);
  }
  inline void Swap(RampMode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RampMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RampMode* New() const final {
    return new RampMode();
  }

  RampMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RampMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RampMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RampMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RampMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RampMode";
  }
  protected:
  explicit RampMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRampModeFieldNumber = 1,
    kRampApproachFieldNumber = 2,
  };
  // bool ramp_mode = 1;
  void clear_ramp_mode();
  bool ramp_mode() const;
  void set_ramp_mode(bool value);
  private:
  bool _internal_ramp_mode() const;
  void _internal_set_ramp_mode(bool value);
  public:

  // bool ramp_approach = 2;
  void clear_ramp_approach();
  bool ramp_approach() const;
  void set_ramp_approach(bool value);
  private:
  bool _internal_ramp_approach() const;
  void _internal_set_ramp_approach(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RampMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ramp_mode_;
  bool ramp_approach_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// -------------------------------------------------------------------

class RampAssistStates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.RampAssistStates) */ {
 public:
  inline RampAssistStates() : RampAssistStates(nullptr) {}
  ~RampAssistStates() override;
  explicit constexpr RampAssistStates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RampAssistStates(const RampAssistStates& from);
  RampAssistStates(RampAssistStates&& from) noexcept
    : RampAssistStates() {
    *this = ::std::move(from);
  }

  inline RampAssistStates& operator=(const RampAssistStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline RampAssistStates& operator=(RampAssistStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RampAssistStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const RampAssistStates* internal_default_instance() {
    return reinterpret_cast<const RampAssistStates*>(
               &_RampAssistStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(RampAssistStates& a, RampAssistStates& b) {
    a.Swap(&b);
  }
  inline void Swap(RampAssistStates* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RampAssistStates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RampAssistStates* New() const final {
    return new RampAssistStates();
  }

  RampAssistStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RampAssistStates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RampAssistStates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RampAssistStates& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RampAssistStates* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.RampAssistStates";
  }
  protected:
  explicit RampAssistStates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 3,
    kStateFieldNumber = 1,
    kApproachFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // bool state = 1;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // bool approach = 2;
  void clear_approach();
  bool approach() const;
  void set_approach(bool value);
  private:
  bool _internal_approach() const;
  void _internal_set_approach(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.RampAssistStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  bool state_;
  bool approach_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ptolemy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AudioPlaybackRequest

// .sensors.AudioPlaybackRequest.RequestedPlayback requested_playback = 1;
inline void AudioPlaybackRequest::clear_requested_playback() {
  requested_playback_ = 0;
}
inline ::sensors::AudioPlaybackRequest_RequestedPlayback AudioPlaybackRequest::_internal_requested_playback() const {
  return static_cast< ::sensors::AudioPlaybackRequest_RequestedPlayback >(requested_playback_);
}
inline ::sensors::AudioPlaybackRequest_RequestedPlayback AudioPlaybackRequest::requested_playback() const {
  // @@protoc_insertion_point(field_get:sensors.AudioPlaybackRequest.requested_playback)
  return _internal_requested_playback();
}
inline void AudioPlaybackRequest::_internal_set_requested_playback(::sensors::AudioPlaybackRequest_RequestedPlayback value) {
  
  requested_playback_ = value;
}
inline void AudioPlaybackRequest::set_requested_playback(::sensors::AudioPlaybackRequest_RequestedPlayback value) {
  _internal_set_requested_playback(value);
  // @@protoc_insertion_point(field_set:sensors.AudioPlaybackRequest.requested_playback)
}

// -------------------------------------------------------------------

// PressRequest

// bool ramp_assist = 1;
inline void PressRequest::clear_ramp_assist() {
  ramp_assist_ = false;
}
inline bool PressRequest::_internal_ramp_assist() const {
  return ramp_assist_;
}
inline bool PressRequest::ramp_assist() const {
  // @@protoc_insertion_point(field_get:sensors.PressRequest.ramp_assist)
  return _internal_ramp_assist();
}
inline void PressRequest::_internal_set_ramp_assist(bool value) {
  
  ramp_assist_ = value;
}
inline void PressRequest::set_ramp_assist(bool value) {
  _internal_set_ramp_assist(value);
  // @@protoc_insertion_point(field_set:sensors.PressRequest.ramp_assist)
}

// -------------------------------------------------------------------

// ZoneBoundary

// repeated .sensors.Point2D polygon = 1;
inline int ZoneBoundary::_internal_polygon_size() const {
  return polygon_.size();
}
inline int ZoneBoundary::polygon_size() const {
  return _internal_polygon_size();
}
inline void ZoneBoundary::clear_polygon() {
  polygon_.Clear();
}
inline ::sensors::Point2D* ZoneBoundary::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.ZoneBoundary.polygon)
  return polygon_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
ZoneBoundary::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:sensors.ZoneBoundary.polygon)
  return &polygon_;
}
inline const ::sensors::Point2D& ZoneBoundary::_internal_polygon(int index) const {
  return polygon_.Get(index);
}
inline const ::sensors::Point2D& ZoneBoundary::polygon(int index) const {
  // @@protoc_insertion_point(field_get:sensors.ZoneBoundary.polygon)
  return _internal_polygon(index);
}
inline ::sensors::Point2D* ZoneBoundary::_internal_add_polygon() {
  return polygon_.Add();
}
inline ::sensors::Point2D* ZoneBoundary::add_polygon() {
  ::sensors::Point2D* _add = _internal_add_polygon();
  // @@protoc_insertion_point(field_add:sensors.ZoneBoundary.polygon)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
ZoneBoundary::polygon() const {
  // @@protoc_insertion_point(field_list:sensors.ZoneBoundary.polygon)
  return polygon_;
}

// repeated .sensors.Point2D critical_point = 2;
inline int ZoneBoundary::_internal_critical_point_size() const {
  return critical_point_.size();
}
inline int ZoneBoundary::critical_point_size() const {
  return _internal_critical_point_size();
}
inline void ZoneBoundary::clear_critical_point() {
  critical_point_.Clear();
}
inline ::sensors::Point2D* ZoneBoundary::mutable_critical_point(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.ZoneBoundary.critical_point)
  return critical_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
ZoneBoundary::mutable_critical_point() {
  // @@protoc_insertion_point(field_mutable_list:sensors.ZoneBoundary.critical_point)
  return &critical_point_;
}
inline const ::sensors::Point2D& ZoneBoundary::_internal_critical_point(int index) const {
  return critical_point_.Get(index);
}
inline const ::sensors::Point2D& ZoneBoundary::critical_point(int index) const {
  // @@protoc_insertion_point(field_get:sensors.ZoneBoundary.critical_point)
  return _internal_critical_point(index);
}
inline ::sensors::Point2D* ZoneBoundary::_internal_add_critical_point() {
  return critical_point_.Add();
}
inline ::sensors::Point2D* ZoneBoundary::add_critical_point() {
  ::sensors::Point2D* _add = _internal_add_critical_point();
  // @@protoc_insertion_point(field_add:sensors.ZoneBoundary.critical_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
ZoneBoundary::critical_point() const {
  // @@protoc_insertion_point(field_list:sensors.ZoneBoundary.critical_point)
  return critical_point_;
}

// string name = 3;
inline void ZoneBoundary::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ZoneBoundary::name() const {
  // @@protoc_insertion_point(field_get:sensors.ZoneBoundary.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ZoneBoundary::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.ZoneBoundary.name)
}
inline std::string* ZoneBoundary::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensors.ZoneBoundary.name)
  return _s;
}
inline const std::string& ZoneBoundary::_internal_name() const {
  return name_.Get();
}
inline void ZoneBoundary::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ZoneBoundary::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ZoneBoundary::release_name() {
  // @@protoc_insertion_point(field_release:sensors.ZoneBoundary.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ZoneBoundary::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.ZoneBoundary.name)
}

// -------------------------------------------------------------------

// ZoneBoundaries

// repeated .sensors.ZoneBoundary zone_boundary = 1;
inline int ZoneBoundaries::_internal_zone_boundary_size() const {
  return zone_boundary_.size();
}
inline int ZoneBoundaries::zone_boundary_size() const {
  return _internal_zone_boundary_size();
}
inline void ZoneBoundaries::clear_zone_boundary() {
  zone_boundary_.Clear();
}
inline ::sensors::ZoneBoundary* ZoneBoundaries::mutable_zone_boundary(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.ZoneBoundaries.zone_boundary)
  return zone_boundary_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::ZoneBoundary >*
ZoneBoundaries::mutable_zone_boundary() {
  // @@protoc_insertion_point(field_mutable_list:sensors.ZoneBoundaries.zone_boundary)
  return &zone_boundary_;
}
inline const ::sensors::ZoneBoundary& ZoneBoundaries::_internal_zone_boundary(int index) const {
  return zone_boundary_.Get(index);
}
inline const ::sensors::ZoneBoundary& ZoneBoundaries::zone_boundary(int index) const {
  // @@protoc_insertion_point(field_get:sensors.ZoneBoundaries.zone_boundary)
  return _internal_zone_boundary(index);
}
inline ::sensors::ZoneBoundary* ZoneBoundaries::_internal_add_zone_boundary() {
  return zone_boundary_.Add();
}
inline ::sensors::ZoneBoundary* ZoneBoundaries::add_zone_boundary() {
  ::sensors::ZoneBoundary* _add = _internal_add_zone_boundary();
  // @@protoc_insertion_point(field_add:sensors.ZoneBoundaries.zone_boundary)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::ZoneBoundary >&
ZoneBoundaries::zone_boundary() const {
  // @@protoc_insertion_point(field_list:sensors.ZoneBoundaries.zone_boundary)
  return zone_boundary_;
}

// -------------------------------------------------------------------

// BlockedZone

// repeated .sensors.Point2D points = 1;
inline int BlockedZone::_internal_points_size() const {
  return points_.size();
}
inline int BlockedZone::points_size() const {
  return _internal_points_size();
}
inline void BlockedZone::clear_points() {
  points_.Clear();
}
inline ::sensors::Point2D* BlockedZone::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.BlockedZone.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
BlockedZone::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:sensors.BlockedZone.points)
  return &points_;
}
inline const ::sensors::Point2D& BlockedZone::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::sensors::Point2D& BlockedZone::points(int index) const {
  // @@protoc_insertion_point(field_get:sensors.BlockedZone.points)
  return _internal_points(index);
}
inline ::sensors::Point2D* BlockedZone::_internal_add_points() {
  return points_.Add();
}
inline ::sensors::Point2D* BlockedZone::add_points() {
  ::sensors::Point2D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:sensors.BlockedZone.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
BlockedZone::points() const {
  // @@protoc_insertion_point(field_list:sensors.BlockedZone.points)
  return points_;
}

// string sensor = 2;
inline void BlockedZone::clear_sensor() {
  sensor_.ClearToEmpty();
}
inline const std::string& BlockedZone::sensor() const {
  // @@protoc_insertion_point(field_get:sensors.BlockedZone.sensor)
  return _internal_sensor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockedZone::set_sensor(ArgT0&& arg0, ArgT... args) {
 
 sensor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.BlockedZone.sensor)
}
inline std::string* BlockedZone::mutable_sensor() {
  std::string* _s = _internal_mutable_sensor();
  // @@protoc_insertion_point(field_mutable:sensors.BlockedZone.sensor)
  return _s;
}
inline const std::string& BlockedZone::_internal_sensor() const {
  return sensor_.Get();
}
inline void BlockedZone::_internal_set_sensor(const std::string& value) {
  
  sensor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockedZone::_internal_mutable_sensor() {
  
  return sensor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockedZone::release_sensor() {
  // @@protoc_insertion_point(field_release:sensors.BlockedZone.sensor)
  return sensor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockedZone::set_allocated_sensor(std::string* sensor) {
  if (sensor != nullptr) {
    
  } else {
    
  }
  sensor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.BlockedZone.sensor)
}

// -------------------------------------------------------------------

// BlockedZones

// repeated .sensors.BlockedZone blocked_zones = 1;
inline int BlockedZones::_internal_blocked_zones_size() const {
  return blocked_zones_.size();
}
inline int BlockedZones::blocked_zones_size() const {
  return _internal_blocked_zones_size();
}
inline void BlockedZones::clear_blocked_zones() {
  blocked_zones_.Clear();
}
inline ::sensors::BlockedZone* BlockedZones::mutable_blocked_zones(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.BlockedZones.blocked_zones)
  return blocked_zones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::BlockedZone >*
BlockedZones::mutable_blocked_zones() {
  // @@protoc_insertion_point(field_mutable_list:sensors.BlockedZones.blocked_zones)
  return &blocked_zones_;
}
inline const ::sensors::BlockedZone& BlockedZones::_internal_blocked_zones(int index) const {
  return blocked_zones_.Get(index);
}
inline const ::sensors::BlockedZone& BlockedZones::blocked_zones(int index) const {
  // @@protoc_insertion_point(field_get:sensors.BlockedZones.blocked_zones)
  return _internal_blocked_zones(index);
}
inline ::sensors::BlockedZone* BlockedZones::_internal_add_blocked_zones() {
  return blocked_zones_.Add();
}
inline ::sensors::BlockedZone* BlockedZones::add_blocked_zones() {
  ::sensors::BlockedZone* _add = _internal_add_blocked_zones();
  // @@protoc_insertion_point(field_add:sensors.BlockedZones.blocked_zones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::BlockedZone >&
BlockedZones::blocked_zones() const {
  // @@protoc_insertion_point(field_list:sensors.BlockedZones.blocked_zones)
  return blocked_zones_;
}

// -------------------------------------------------------------------

// JoystickRange

// float begin = 1;
inline void JoystickRange::clear_begin() {
  begin_ = 0;
}
inline float JoystickRange::_internal_begin() const {
  return begin_;
}
inline float JoystickRange::begin() const {
  // @@protoc_insertion_point(field_get:sensors.JoystickRange.begin)
  return _internal_begin();
}
inline void JoystickRange::_internal_set_begin(float value) {
  
  begin_ = value;
}
inline void JoystickRange::set_begin(float value) {
  _internal_set_begin(value);
  // @@protoc_insertion_point(field_set:sensors.JoystickRange.begin)
}

// float end = 2;
inline void JoystickRange::clear_end() {
  end_ = 0;
}
inline float JoystickRange::_internal_end() const {
  return end_;
}
inline float JoystickRange::end() const {
  // @@protoc_insertion_point(field_get:sensors.JoystickRange.end)
  return _internal_end();
}
inline void JoystickRange::_internal_set_end(float value) {
  
  end_ = value;
}
inline void JoystickRange::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:sensors.JoystickRange.end)
}

// -------------------------------------------------------------------

// JoystickRanges

// repeated .sensors.JoystickRange joystick_ranges = 1;
inline int JoystickRanges::_internal_joystick_ranges_size() const {
  return joystick_ranges_.size();
}
inline int JoystickRanges::joystick_ranges_size() const {
  return _internal_joystick_ranges_size();
}
inline void JoystickRanges::clear_joystick_ranges() {
  joystick_ranges_.Clear();
}
inline ::sensors::JoystickRange* JoystickRanges::mutable_joystick_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.JoystickRanges.joystick_ranges)
  return joystick_ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::JoystickRange >*
JoystickRanges::mutable_joystick_ranges() {
  // @@protoc_insertion_point(field_mutable_list:sensors.JoystickRanges.joystick_ranges)
  return &joystick_ranges_;
}
inline const ::sensors::JoystickRange& JoystickRanges::_internal_joystick_ranges(int index) const {
  return joystick_ranges_.Get(index);
}
inline const ::sensors::JoystickRange& JoystickRanges::joystick_ranges(int index) const {
  // @@protoc_insertion_point(field_get:sensors.JoystickRanges.joystick_ranges)
  return _internal_joystick_ranges(index);
}
inline ::sensors::JoystickRange* JoystickRanges::_internal_add_joystick_ranges() {
  return joystick_ranges_.Add();
}
inline ::sensors::JoystickRange* JoystickRanges::add_joystick_ranges() {
  ::sensors::JoystickRange* _add = _internal_add_joystick_ranges();
  // @@protoc_insertion_point(field_add:sensors.JoystickRanges.joystick_ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::JoystickRange >&
JoystickRanges::joystick_ranges() const {
  // @@protoc_insertion_point(field_list:sensors.JoystickRanges.joystick_ranges)
  return joystick_ranges_;
}

// -------------------------------------------------------------------

// StartModeData

// .sensors.StartModeData.StartModes mode = 1;
inline void StartModeData::clear_mode() {
  mode_ = 0;
}
inline ::sensors::StartModeData_StartModes StartModeData::_internal_mode() const {
  return static_cast< ::sensors::StartModeData_StartModes >(mode_);
}
inline ::sensors::StartModeData_StartModes StartModeData::mode() const {
  // @@protoc_insertion_point(field_get:sensors.StartModeData.mode)
  return _internal_mode();
}
inline void StartModeData::_internal_set_mode(::sensors::StartModeData_StartModes value) {
  
  mode_ = value;
}
inline void StartModeData::set_mode(::sensors::StartModeData_StartModes value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:sensors.StartModeData.mode)
}

// repeated string missing_devices = 2;
inline int StartModeData::_internal_missing_devices_size() const {
  return missing_devices_.size();
}
inline int StartModeData::missing_devices_size() const {
  return _internal_missing_devices_size();
}
inline void StartModeData::clear_missing_devices() {
  missing_devices_.Clear();
}
inline std::string* StartModeData::add_missing_devices() {
  std::string* _s = _internal_add_missing_devices();
  // @@protoc_insertion_point(field_add_mutable:sensors.StartModeData.missing_devices)
  return _s;
}
inline const std::string& StartModeData::_internal_missing_devices(int index) const {
  return missing_devices_.Get(index);
}
inline const std::string& StartModeData::missing_devices(int index) const {
  // @@protoc_insertion_point(field_get:sensors.StartModeData.missing_devices)
  return _internal_missing_devices(index);
}
inline std::string* StartModeData::mutable_missing_devices(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.StartModeData.missing_devices)
  return missing_devices_.Mutable(index);
}
inline void StartModeData::set_missing_devices(int index, const std::string& value) {
  missing_devices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensors.StartModeData.missing_devices)
}
inline void StartModeData::set_missing_devices(int index, std::string&& value) {
  missing_devices_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensors.StartModeData.missing_devices)
}
inline void StartModeData::set_missing_devices(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  missing_devices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensors.StartModeData.missing_devices)
}
inline void StartModeData::set_missing_devices(int index, const char* value, size_t size) {
  missing_devices_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensors.StartModeData.missing_devices)
}
inline std::string* StartModeData::_internal_add_missing_devices() {
  return missing_devices_.Add();
}
inline void StartModeData::add_missing_devices(const std::string& value) {
  missing_devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensors.StartModeData.missing_devices)
}
inline void StartModeData::add_missing_devices(std::string&& value) {
  missing_devices_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensors.StartModeData.missing_devices)
}
inline void StartModeData::add_missing_devices(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  missing_devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensors.StartModeData.missing_devices)
}
inline void StartModeData::add_missing_devices(const char* value, size_t size) {
  missing_devices_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensors.StartModeData.missing_devices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StartModeData::missing_devices() const {
  // @@protoc_insertion_point(field_list:sensors.StartModeData.missing_devices)
  return missing_devices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StartModeData::mutable_missing_devices() {
  // @@protoc_insertion_point(field_mutable_list:sensors.StartModeData.missing_devices)
  return &missing_devices_;
}

// -------------------------------------------------------------------

// Response

// string reply = 1;
inline void Response::clear_reply() {
  reply_.ClearToEmpty();
}
inline const std::string& Response::reply() const {
  // @@protoc_insertion_point(field_get:sensors.Response.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_reply(ArgT0&& arg0, ArgT... args) {
 
 reply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.Response.reply)
}
inline std::string* Response::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:sensors.Response.reply)
  return _s;
}
inline const std::string& Response::_internal_reply() const {
  return reply_.Get();
}
inline void Response::_internal_set_reply(const std::string& value) {
  
  reply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_reply() {
  
  return reply_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_reply() {
  // @@protoc_insertion_point(field_release:sensors.Response.reply)
  return reply_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Response::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  reply_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reply,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.Response.reply)
}

// int32 return_code = 2;
inline void Response::clear_return_code() {
  return_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Response::_internal_return_code() const {
  return return_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Response::return_code() const {
  // @@protoc_insertion_point(field_get:sensors.Response.return_code)
  return _internal_return_code();
}
inline void Response::_internal_set_return_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  return_code_ = value;
}
inline void Response::set_return_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_return_code(value);
  // @@protoc_insertion_point(field_set:sensors.Response.return_code)
}

// -------------------------------------------------------------------

// DFParameters

// uint32 df_timestamp = 1;
inline void DFParameters::clear_df_timestamp() {
  df_timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFParameters::_internal_df_timestamp() const {
  return df_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFParameters::df_timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.df_timestamp)
  return _internal_df_timestamp();
}
inline void DFParameters::_internal_set_df_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  df_timestamp_ = value;
}
inline void DFParameters::set_df_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_df_timestamp(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.df_timestamp)
}

// float target_pressure = 2;
inline void DFParameters::clear_target_pressure() {
  target_pressure_ = 0;
}
inline float DFParameters::_internal_target_pressure() const {
  return target_pressure_;
}
inline float DFParameters::target_pressure() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.target_pressure)
  return _internal_target_pressure();
}
inline void DFParameters::_internal_set_target_pressure(float value) {
  
  target_pressure_ = value;
}
inline void DFParameters::set_target_pressure(float value) {
  _internal_set_target_pressure(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.target_pressure)
}

// float high_pressure = 3;
inline void DFParameters::clear_high_pressure() {
  high_pressure_ = 0;
}
inline float DFParameters::_internal_high_pressure() const {
  return high_pressure_;
}
inline float DFParameters::high_pressure() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.high_pressure)
  return _internal_high_pressure();
}
inline void DFParameters::_internal_set_high_pressure(float value) {
  
  high_pressure_ = value;
}
inline void DFParameters::set_high_pressure(float value) {
  _internal_set_high_pressure(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.high_pressure)
}

// float low_pressure = 4;
inline void DFParameters::clear_low_pressure() {
  low_pressure_ = 0;
}
inline float DFParameters::_internal_low_pressure() const {
  return low_pressure_;
}
inline float DFParameters::low_pressure() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.low_pressure)
  return _internal_low_pressure();
}
inline void DFParameters::_internal_set_low_pressure(float value) {
  
  low_pressure_ = value;
}
inline void DFParameters::set_low_pressure(float value) {
  _internal_set_low_pressure(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.low_pressure)
}

// float in_seat_pressure = 5;
inline void DFParameters::clear_in_seat_pressure() {
  in_seat_pressure_ = 0;
}
inline float DFParameters::_internal_in_seat_pressure() const {
  return in_seat_pressure_;
}
inline float DFParameters::in_seat_pressure() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.in_seat_pressure)
  return _internal_in_seat_pressure();
}
inline void DFParameters::_internal_set_in_seat_pressure(float value) {
  
  in_seat_pressure_ = value;
}
inline void DFParameters::set_in_seat_pressure(float value) {
  _internal_set_in_seat_pressure(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.in_seat_pressure)
}

// float off_load_pressure = 6;
inline void DFParameters::clear_off_load_pressure() {
  off_load_pressure_ = 0;
}
inline float DFParameters::_internal_off_load_pressure() const {
  return off_load_pressure_;
}
inline float DFParameters::off_load_pressure() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.off_load_pressure)
  return _internal_off_load_pressure();
}
inline void DFParameters::_internal_set_off_load_pressure(float value) {
  
  off_load_pressure_ = value;
}
inline void DFParameters::set_off_load_pressure(float value) {
  _internal_set_off_load_pressure(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.off_load_pressure)
}

// int32 usb_update_period = 7;
inline void DFParameters::clear_usb_update_period() {
  usb_update_period_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DFParameters::_internal_usb_update_period() const {
  return usb_update_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DFParameters::usb_update_period() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.usb_update_period)
  return _internal_usb_update_period();
}
inline void DFParameters::_internal_set_usb_update_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usb_update_period_ = value;
}
inline void DFParameters::set_usb_update_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usb_update_period(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.usb_update_period)
}

// int32 cap_update_period = 8;
inline void DFParameters::clear_cap_update_period() {
  cap_update_period_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DFParameters::_internal_cap_update_period() const {
  return cap_update_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DFParameters::cap_update_period() const {
  // @@protoc_insertion_point(field_get:sensors.DFParameters.cap_update_period)
  return _internal_cap_update_period();
}
inline void DFParameters::_internal_set_cap_update_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cap_update_period_ = value;
}
inline void DFParameters::set_cap_update_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cap_update_period(value);
  // @@protoc_insertion_point(field_set:sensors.DFParameters.cap_update_period)
}

// -------------------------------------------------------------------

// DFSeatEvent

// uint32 current_timestamp = 1;
inline void DFSeatEvent::clear_current_timestamp() {
  current_timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFSeatEvent::_internal_current_timestamp() const {
  return current_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFSeatEvent::current_timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.DFSeatEvent.current_timestamp)
  return _internal_current_timestamp();
}
inline void DFSeatEvent::_internal_set_current_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  current_timestamp_ = value;
}
inline void DFSeatEvent::set_current_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_current_timestamp(value);
  // @@protoc_insertion_point(field_set:sensors.DFSeatEvent.current_timestamp)
}

// uint32 event_timestamp = 2;
inline void DFSeatEvent::clear_event_timestamp() {
  event_timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFSeatEvent::_internal_event_timestamp() const {
  return event_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFSeatEvent::event_timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.DFSeatEvent.event_timestamp)
  return _internal_event_timestamp();
}
inline void DFSeatEvent::_internal_set_event_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  event_timestamp_ = value;
}
inline void DFSeatEvent::set_event_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_event_timestamp(value);
  // @@protoc_insertion_point(field_set:sensors.DFSeatEvent.event_timestamp)
}

// .sensors.DFSeatEvent.EventGroup group = 3;
inline void DFSeatEvent::clear_group() {
  group_ = 0;
}
inline ::sensors::DFSeatEvent_EventGroup DFSeatEvent::_internal_group() const {
  return static_cast< ::sensors::DFSeatEvent_EventGroup >(group_);
}
inline ::sensors::DFSeatEvent_EventGroup DFSeatEvent::group() const {
  // @@protoc_insertion_point(field_get:sensors.DFSeatEvent.group)
  return _internal_group();
}
inline void DFSeatEvent::_internal_set_group(::sensors::DFSeatEvent_EventGroup value) {
  
  group_ = value;
}
inline void DFSeatEvent::set_group(::sensors::DFSeatEvent_EventGroup value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:sensors.DFSeatEvent.group)
}

// .sensors.DFSeatEvent.EventType event_type = 4;
inline void DFSeatEvent::clear_event_type() {
  event_type_ = 0;
}
inline ::sensors::DFSeatEvent_EventType DFSeatEvent::_internal_event_type() const {
  return static_cast< ::sensors::DFSeatEvent_EventType >(event_type_);
}
inline ::sensors::DFSeatEvent_EventType DFSeatEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sensors.DFSeatEvent.event_type)
  return _internal_event_type();
}
inline void DFSeatEvent::_internal_set_event_type(::sensors::DFSeatEvent_EventType value) {
  
  event_type_ = value;
}
inline void DFSeatEvent::set_event_type(::sensors::DFSeatEvent_EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:sensors.DFSeatEvent.event_type)
}

// -------------------------------------------------------------------

// DistanceData

// int32 distance = 1;
inline void DistanceData::clear_distance() {
  distance_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DistanceData::_internal_distance() const {
  return distance_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DistanceData::distance() const {
  // @@protoc_insertion_point(field_get:sensors.DistanceData.distance)
  return _internal_distance();
}
inline void DistanceData::_internal_set_distance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  distance_ = value;
}
inline void DistanceData::set_distance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:sensors.DistanceData.distance)
}

// -------------------------------------------------------------------

// SeatPressure

// float pressure = 1;
inline void SeatPressure::clear_pressure() {
  pressure_ = 0;
}
inline float SeatPressure::_internal_pressure() const {
  return pressure_;
}
inline float SeatPressure::pressure() const {
  // @@protoc_insertion_point(field_get:sensors.SeatPressure.pressure)
  return _internal_pressure();
}
inline void SeatPressure::_internal_set_pressure(float value) {
  
  pressure_ = value;
}
inline void SeatPressure::set_pressure(float value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:sensors.SeatPressure.pressure)
}

// -------------------------------------------------------------------

// ObstacleValue_Linear

// float distance = 1;
inline void ObstacleValue_Linear::clear_distance() {
  distance_ = 0;
}
inline float ObstacleValue_Linear::_internal_distance() const {
  return distance_;
}
inline float ObstacleValue_Linear::distance() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.Linear.distance)
  return _internal_distance();
}
inline void ObstacleValue_Linear::_internal_set_distance(float value) {
  
  distance_ = value;
}
inline void ObstacleValue_Linear::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:sensors.ObstacleValue.Linear.distance)
}

// -------------------------------------------------------------------

// ObstacleValue_Angular

// float angle = 1;
inline void ObstacleValue_Angular::clear_angle() {
  angle_ = 0;
}
inline float ObstacleValue_Angular::_internal_angle() const {
  return angle_;
}
inline float ObstacleValue_Angular::angle() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.Angular.angle)
  return _internal_angle();
}
inline void ObstacleValue_Angular::_internal_set_angle(float value) {
  
  angle_ = value;
}
inline void ObstacleValue_Angular::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:sensors.ObstacleValue.Angular.angle)
}

// -------------------------------------------------------------------

// ObstacleValue_Combo

// float distance = 1;
inline void ObstacleValue_Combo::clear_distance() {
  distance_ = 0;
}
inline float ObstacleValue_Combo::_internal_distance() const {
  return distance_;
}
inline float ObstacleValue_Combo::distance() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.Combo.distance)
  return _internal_distance();
}
inline void ObstacleValue_Combo::_internal_set_distance(float value) {
  
  distance_ = value;
}
inline void ObstacleValue_Combo::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:sensors.ObstacleValue.Combo.distance)
}

// float angle = 2;
inline void ObstacleValue_Combo::clear_angle() {
  angle_ = 0;
}
inline float ObstacleValue_Combo::_internal_angle() const {
  return angle_;
}
inline float ObstacleValue_Combo::angle() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.Combo.angle)
  return _internal_angle();
}
inline void ObstacleValue_Combo::_internal_set_angle(float value) {
  
  angle_ = value;
}
inline void ObstacleValue_Combo::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:sensors.ObstacleValue.Combo.angle)
}

// -------------------------------------------------------------------

// ObstacleValue

// .sensors.ObstacleValue.Linear linear = 1;
inline bool ObstacleValue::_internal_has_linear() const {
  return value_case() == kLinear;
}
inline bool ObstacleValue::has_linear() const {
  return _internal_has_linear();
}
inline void ObstacleValue::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void ObstacleValue::clear_linear() {
  if (_internal_has_linear()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.linear_;
    }
    clear_has_value();
  }
}
inline ::sensors::ObstacleValue_Linear* ObstacleValue::release_linear() {
  // @@protoc_insertion_point(field_release:sensors.ObstacleValue.linear)
  if (_internal_has_linear()) {
    clear_has_value();
      ::sensors::ObstacleValue_Linear* temp = value_.linear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensors::ObstacleValue_Linear& ObstacleValue::_internal_linear() const {
  return _internal_has_linear()
      ? *value_.linear_
      : reinterpret_cast< ::sensors::ObstacleValue_Linear&>(::sensors::_ObstacleValue_Linear_default_instance_);
}
inline const ::sensors::ObstacleValue_Linear& ObstacleValue::linear() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.linear)
  return _internal_linear();
}
inline ::sensors::ObstacleValue_Linear* ObstacleValue::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensors.ObstacleValue.linear)
  if (_internal_has_linear()) {
    clear_has_value();
    ::sensors::ObstacleValue_Linear* temp = value_.linear_;
    value_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObstacleValue::unsafe_arena_set_allocated_linear(::sensors::ObstacleValue_Linear* linear) {
  clear_value();
  if (linear) {
    set_has_linear();
    value_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ObstacleValue.linear)
}
inline ::sensors::ObstacleValue_Linear* ObstacleValue::_internal_mutable_linear() {
  if (!_internal_has_linear()) {
    clear_value();
    set_has_linear();
    value_.linear_ = CreateMaybeMessage< ::sensors::ObstacleValue_Linear >(GetArenaForAllocation());
  }
  return value_.linear_;
}
inline ::sensors::ObstacleValue_Linear* ObstacleValue::mutable_linear() {
  ::sensors::ObstacleValue_Linear* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:sensors.ObstacleValue.linear)
  return _msg;
}

// .sensors.ObstacleValue.Angular angular = 2;
inline bool ObstacleValue::_internal_has_angular() const {
  return value_case() == kAngular;
}
inline bool ObstacleValue::has_angular() const {
  return _internal_has_angular();
}
inline void ObstacleValue::set_has_angular() {
  _oneof_case_[0] = kAngular;
}
inline void ObstacleValue::clear_angular() {
  if (_internal_has_angular()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.angular_;
    }
    clear_has_value();
  }
}
inline ::sensors::ObstacleValue_Angular* ObstacleValue::release_angular() {
  // @@protoc_insertion_point(field_release:sensors.ObstacleValue.angular)
  if (_internal_has_angular()) {
    clear_has_value();
      ::sensors::ObstacleValue_Angular* temp = value_.angular_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.angular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensors::ObstacleValue_Angular& ObstacleValue::_internal_angular() const {
  return _internal_has_angular()
      ? *value_.angular_
      : reinterpret_cast< ::sensors::ObstacleValue_Angular&>(::sensors::_ObstacleValue_Angular_default_instance_);
}
inline const ::sensors::ObstacleValue_Angular& ObstacleValue::angular() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.angular)
  return _internal_angular();
}
inline ::sensors::ObstacleValue_Angular* ObstacleValue::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensors.ObstacleValue.angular)
  if (_internal_has_angular()) {
    clear_has_value();
    ::sensors::ObstacleValue_Angular* temp = value_.angular_;
    value_.angular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObstacleValue::unsafe_arena_set_allocated_angular(::sensors::ObstacleValue_Angular* angular) {
  clear_value();
  if (angular) {
    set_has_angular();
    value_.angular_ = angular;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ObstacleValue.angular)
}
inline ::sensors::ObstacleValue_Angular* ObstacleValue::_internal_mutable_angular() {
  if (!_internal_has_angular()) {
    clear_value();
    set_has_angular();
    value_.angular_ = CreateMaybeMessage< ::sensors::ObstacleValue_Angular >(GetArenaForAllocation());
  }
  return value_.angular_;
}
inline ::sensors::ObstacleValue_Angular* ObstacleValue::mutable_angular() {
  ::sensors::ObstacleValue_Angular* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:sensors.ObstacleValue.angular)
  return _msg;
}

// .sensors.ObstacleValue.Combo combo = 3;
inline bool ObstacleValue::_internal_has_combo() const {
  return value_case() == kCombo;
}
inline bool ObstacleValue::has_combo() const {
  return _internal_has_combo();
}
inline void ObstacleValue::set_has_combo() {
  _oneof_case_[0] = kCombo;
}
inline void ObstacleValue::clear_combo() {
  if (_internal_has_combo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.combo_;
    }
    clear_has_value();
  }
}
inline ::sensors::ObstacleValue_Combo* ObstacleValue::release_combo() {
  // @@protoc_insertion_point(field_release:sensors.ObstacleValue.combo)
  if (_internal_has_combo()) {
    clear_has_value();
      ::sensors::ObstacleValue_Combo* temp = value_.combo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.combo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensors::ObstacleValue_Combo& ObstacleValue::_internal_combo() const {
  return _internal_has_combo()
      ? *value_.combo_
      : reinterpret_cast< ::sensors::ObstacleValue_Combo&>(::sensors::_ObstacleValue_Combo_default_instance_);
}
inline const ::sensors::ObstacleValue_Combo& ObstacleValue::combo() const {
  // @@protoc_insertion_point(field_get:sensors.ObstacleValue.combo)
  return _internal_combo();
}
inline ::sensors::ObstacleValue_Combo* ObstacleValue::unsafe_arena_release_combo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensors.ObstacleValue.combo)
  if (_internal_has_combo()) {
    clear_has_value();
    ::sensors::ObstacleValue_Combo* temp = value_.combo_;
    value_.combo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObstacleValue::unsafe_arena_set_allocated_combo(::sensors::ObstacleValue_Combo* combo) {
  clear_value();
  if (combo) {
    set_has_combo();
    value_.combo_ = combo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ObstacleValue.combo)
}
inline ::sensors::ObstacleValue_Combo* ObstacleValue::_internal_mutable_combo() {
  if (!_internal_has_combo()) {
    clear_value();
    set_has_combo();
    value_.combo_ = CreateMaybeMessage< ::sensors::ObstacleValue_Combo >(GetArenaForAllocation());
  }
  return value_.combo_;
}
inline ::sensors::ObstacleValue_Combo* ObstacleValue::mutable_combo() {
  ::sensors::ObstacleValue_Combo* _msg = _internal_mutable_combo();
  // @@protoc_insertion_point(field_mutable:sensors.ObstacleValue.combo)
  return _msg;
}

inline bool ObstacleValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ObstacleValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ObstacleValue::ValueCase ObstacleValue::value_case() const {
  return ObstacleValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClosestObstacles

// .sensors.ObstacleValue front = 1;
inline bool ClosestObstacles::_internal_has_front() const {
  return this != internal_default_instance() && front_ != nullptr;
}
inline bool ClosestObstacles::has_front() const {
  return _internal_has_front();
}
inline void ClosestObstacles::clear_front() {
  if (GetArenaForAllocation() == nullptr && front_ != nullptr) {
    delete front_;
  }
  front_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_front() const {
  const ::sensors::ObstacleValue* p = front_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::front() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.front)
  return _internal_front();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_front(
    ::sensors::ObstacleValue* front) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_);
  }
  front_ = front;
  if (front) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.front)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_front() {
  
  ::sensors::ObstacleValue* temp = front_;
  front_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_front() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.front)
  
  ::sensors::ObstacleValue* temp = front_;
  front_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_front() {
  
  if (front_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    front_ = p;
  }
  return front_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_front() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_front();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.front)
  return _msg;
}
inline void ClosestObstacles::set_allocated_front(::sensors::ObstacleValue* front) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete front_;
  }
  if (front) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(front);
    if (message_arena != submessage_arena) {
      front = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front, submessage_arena);
    }
    
  } else {
    
  }
  front_ = front;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.front)
}

// .sensors.ObstacleValue front_left = 2;
inline bool ClosestObstacles::_internal_has_front_left() const {
  return this != internal_default_instance() && front_left_ != nullptr;
}
inline bool ClosestObstacles::has_front_left() const {
  return _internal_has_front_left();
}
inline void ClosestObstacles::clear_front_left() {
  if (GetArenaForAllocation() == nullptr && front_left_ != nullptr) {
    delete front_left_;
  }
  front_left_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_front_left() const {
  const ::sensors::ObstacleValue* p = front_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::front_left() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.front_left)
  return _internal_front_left();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_front_left(
    ::sensors::ObstacleValue* front_left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_left_);
  }
  front_left_ = front_left;
  if (front_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.front_left)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_front_left() {
  
  ::sensors::ObstacleValue* temp = front_left_;
  front_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_front_left() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.front_left)
  
  ::sensors::ObstacleValue* temp = front_left_;
  front_left_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_front_left() {
  
  if (front_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    front_left_ = p;
  }
  return front_left_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_front_left() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_front_left();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.front_left)
  return _msg;
}
inline void ClosestObstacles::set_allocated_front_left(::sensors::ObstacleValue* front_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete front_left_;
  }
  if (front_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(front_left);
    if (message_arena != submessage_arena) {
      front_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front_left, submessage_arena);
    }
    
  } else {
    
  }
  front_left_ = front_left;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.front_left)
}

// .sensors.ObstacleValue front_right = 3;
inline bool ClosestObstacles::_internal_has_front_right() const {
  return this != internal_default_instance() && front_right_ != nullptr;
}
inline bool ClosestObstacles::has_front_right() const {
  return _internal_has_front_right();
}
inline void ClosestObstacles::clear_front_right() {
  if (GetArenaForAllocation() == nullptr && front_right_ != nullptr) {
    delete front_right_;
  }
  front_right_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_front_right() const {
  const ::sensors::ObstacleValue* p = front_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::front_right() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.front_right)
  return _internal_front_right();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_front_right(
    ::sensors::ObstacleValue* front_right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_right_);
  }
  front_right_ = front_right;
  if (front_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.front_right)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_front_right() {
  
  ::sensors::ObstacleValue* temp = front_right_;
  front_right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_front_right() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.front_right)
  
  ::sensors::ObstacleValue* temp = front_right_;
  front_right_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_front_right() {
  
  if (front_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    front_right_ = p;
  }
  return front_right_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_front_right() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_front_right();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.front_right)
  return _msg;
}
inline void ClosestObstacles::set_allocated_front_right(::sensors::ObstacleValue* front_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete front_right_;
  }
  if (front_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(front_right);
    if (message_arena != submessage_arena) {
      front_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front_right, submessage_arena);
    }
    
  } else {
    
  }
  front_right_ = front_right;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.front_right)
}

// .sensors.ObstacleValue left = 4;
inline bool ClosestObstacles::_internal_has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline bool ClosestObstacles::has_left() const {
  return _internal_has_left();
}
inline void ClosestObstacles::clear_left() {
  if (GetArenaForAllocation() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_left() const {
  const ::sensors::ObstacleValue* p = left_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::left() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.left)
  return _internal_left();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_left(
    ::sensors::ObstacleValue* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_);
  }
  left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.left)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_left() {
  
  ::sensors::ObstacleValue* temp = left_;
  left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.left)
  
  ::sensors::ObstacleValue* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    left_ = p;
  }
  return left_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_left() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.left)
  return _msg;
}
inline void ClosestObstacles::set_allocated_left(::sensors::ObstacleValue* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.left)
}

// .sensors.ObstacleValue right = 5;
inline bool ClosestObstacles::_internal_has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline bool ClosestObstacles::has_right() const {
  return _internal_has_right();
}
inline void ClosestObstacles::clear_right() {
  if (GetArenaForAllocation() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_right() const {
  const ::sensors::ObstacleValue* p = right_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::right() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.right)
  return _internal_right();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_right(
    ::sensors::ObstacleValue* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_);
  }
  right_ = right;
  if (right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.right)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_right() {
  
  ::sensors::ObstacleValue* temp = right_;
  right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.right)
  
  ::sensors::ObstacleValue* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    right_ = p;
  }
  return right_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_right() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.right)
  return _msg;
}
inline void ClosestObstacles::set_allocated_right(::sensors::ObstacleValue* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.right)
}

// .sensors.ObstacleValue back_left = 6;
inline bool ClosestObstacles::_internal_has_back_left() const {
  return this != internal_default_instance() && back_left_ != nullptr;
}
inline bool ClosestObstacles::has_back_left() const {
  return _internal_has_back_left();
}
inline void ClosestObstacles::clear_back_left() {
  if (GetArenaForAllocation() == nullptr && back_left_ != nullptr) {
    delete back_left_;
  }
  back_left_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_back_left() const {
  const ::sensors::ObstacleValue* p = back_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::back_left() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.back_left)
  return _internal_back_left();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_back_left(
    ::sensors::ObstacleValue* back_left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(back_left_);
  }
  back_left_ = back_left;
  if (back_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.back_left)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_back_left() {
  
  ::sensors::ObstacleValue* temp = back_left_;
  back_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_back_left() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.back_left)
  
  ::sensors::ObstacleValue* temp = back_left_;
  back_left_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_back_left() {
  
  if (back_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    back_left_ = p;
  }
  return back_left_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_back_left() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_back_left();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.back_left)
  return _msg;
}
inline void ClosestObstacles::set_allocated_back_left(::sensors::ObstacleValue* back_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete back_left_;
  }
  if (back_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(back_left);
    if (message_arena != submessage_arena) {
      back_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, back_left, submessage_arena);
    }
    
  } else {
    
  }
  back_left_ = back_left;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.back_left)
}

// .sensors.ObstacleValue back_right = 7;
inline bool ClosestObstacles::_internal_has_back_right() const {
  return this != internal_default_instance() && back_right_ != nullptr;
}
inline bool ClosestObstacles::has_back_right() const {
  return _internal_has_back_right();
}
inline void ClosestObstacles::clear_back_right() {
  if (GetArenaForAllocation() == nullptr && back_right_ != nullptr) {
    delete back_right_;
  }
  back_right_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_back_right() const {
  const ::sensors::ObstacleValue* p = back_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::back_right() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.back_right)
  return _internal_back_right();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_back_right(
    ::sensors::ObstacleValue* back_right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(back_right_);
  }
  back_right_ = back_right;
  if (back_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.back_right)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_back_right() {
  
  ::sensors::ObstacleValue* temp = back_right_;
  back_right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_back_right() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.back_right)
  
  ::sensors::ObstacleValue* temp = back_right_;
  back_right_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_back_right() {
  
  if (back_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    back_right_ = p;
  }
  return back_right_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_back_right() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_back_right();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.back_right)
  return _msg;
}
inline void ClosestObstacles::set_allocated_back_right(::sensors::ObstacleValue* back_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete back_right_;
  }
  if (back_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(back_right);
    if (message_arena != submessage_arena) {
      back_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, back_right, submessage_arena);
    }
    
  } else {
    
  }
  back_right_ = back_right;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.back_right)
}

// .sensors.ObstacleValue back = 8;
inline bool ClosestObstacles::_internal_has_back() const {
  return this != internal_default_instance() && back_ != nullptr;
}
inline bool ClosestObstacles::has_back() const {
  return _internal_has_back();
}
inline void ClosestObstacles::clear_back() {
  if (GetArenaForAllocation() == nullptr && back_ != nullptr) {
    delete back_;
  }
  back_ = nullptr;
}
inline const ::sensors::ObstacleValue& ClosestObstacles::_internal_back() const {
  const ::sensors::ObstacleValue* p = back_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::ObstacleValue&>(
      ::sensors::_ObstacleValue_default_instance_);
}
inline const ::sensors::ObstacleValue& ClosestObstacles::back() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.back)
  return _internal_back();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_back(
    ::sensors::ObstacleValue* back) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(back_);
  }
  back_ = back;
  if (back) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.back)
}
inline ::sensors::ObstacleValue* ClosestObstacles::release_back() {
  
  ::sensors::ObstacleValue* temp = back_;
  back_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::unsafe_arena_release_back() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.back)
  
  ::sensors::ObstacleValue* temp = back_;
  back_ = nullptr;
  return temp;
}
inline ::sensors::ObstacleValue* ClosestObstacles::_internal_mutable_back() {
  
  if (back_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::ObstacleValue>(GetArenaForAllocation());
    back_ = p;
  }
  return back_;
}
inline ::sensors::ObstacleValue* ClosestObstacles::mutable_back() {
  ::sensors::ObstacleValue* _msg = _internal_mutable_back();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.back)
  return _msg;
}
inline void ClosestObstacles::set_allocated_back(::sensors::ObstacleValue* back) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete back_;
  }
  if (back) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::ObstacleValue>::GetOwningArena(back);
    if (message_arena != submessage_arena) {
      back = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, back, submessage_arena);
    }
    
  } else {
    
  }
  back_ = back;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.back)
}

// .google.protobuf.Timestamp timestamp = 9;
inline bool ClosestObstacles::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool ClosestObstacles::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ClosestObstacles::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ClosestObstacles::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.ClosestObstacles.timestamp)
  return _internal_timestamp();
}
inline void ClosestObstacles::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ClosestObstacles.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ClosestObstacles::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ClosestObstacles::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.ClosestObstacles.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ClosestObstacles::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ClosestObstacles::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.ClosestObstacles.timestamp)
  return _msg;
}
inline void ClosestObstacles::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.ClosestObstacles.timestamp)
}

// -------------------------------------------------------------------

// CameraPoints

// repeated .sensors.Point3D points = 1;
inline int CameraPoints::_internal_points_size() const {
  return points_.size();
}
inline int CameraPoints::points_size() const {
  return _internal_points_size();
}
inline void CameraPoints::clear_points() {
  points_.Clear();
}
inline ::sensors::Point3D* CameraPoints::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.CameraPoints.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >*
CameraPoints::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:sensors.CameraPoints.points)
  return &points_;
}
inline const ::sensors::Point3D& CameraPoints::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::sensors::Point3D& CameraPoints::points(int index) const {
  // @@protoc_insertion_point(field_get:sensors.CameraPoints.points)
  return _internal_points(index);
}
inline ::sensors::Point3D* CameraPoints::_internal_add_points() {
  return points_.Add();
}
inline ::sensors::Point3D* CameraPoints::add_points() {
  ::sensors::Point3D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:sensors.CameraPoints.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >&
CameraPoints::points() const {
  // @@protoc_insertion_point(field_list:sensors.CameraPoints.points)
  return points_;
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool CameraPoints::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool CameraPoints::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CameraPoints::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CameraPoints::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.CameraPoints.timestamp)
  return _internal_timestamp();
}
inline void CameraPoints::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.CameraPoints.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.CameraPoints.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.CameraPoints.timestamp)
  return _msg;
}
inline void CameraPoints::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.CameraPoints.timestamp)
}

// -------------------------------------------------------------------

// Point3D

// float x = 1;
inline void Point3D::clear_x() {
  x_ = 0;
}
inline float Point3D::_internal_x() const {
  return x_;
}
inline float Point3D::x() const {
  // @@protoc_insertion_point(field_get:sensors.Point3D.x)
  return _internal_x();
}
inline void Point3D::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point3D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sensors.Point3D.x)
}

// float y = 2;
inline void Point3D::clear_y() {
  y_ = 0;
}
inline float Point3D::_internal_y() const {
  return y_;
}
inline float Point3D::y() const {
  // @@protoc_insertion_point(field_get:sensors.Point3D.y)
  return _internal_y();
}
inline void Point3D::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point3D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sensors.Point3D.y)
}

// float z = 3;
inline void Point3D::clear_z() {
  z_ = 0;
}
inline float Point3D::_internal_z() const {
  return z_;
}
inline float Point3D::z() const {
  // @@protoc_insertion_point(field_get:sensors.Point3D.z)
  return _internal_z();
}
inline void Point3D::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Point3D::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sensors.Point3D.z)
}

// -------------------------------------------------------------------

// CameraPoints2D

// repeated .sensors.Point2D points = 1;
inline int CameraPoints2D::_internal_points_size() const {
  return points_.size();
}
inline int CameraPoints2D::points_size() const {
  return _internal_points_size();
}
inline void CameraPoints2D::clear_points() {
  points_.Clear();
}
inline ::sensors::Point2D* CameraPoints2D::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.CameraPoints2D.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >*
CameraPoints2D::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:sensors.CameraPoints2D.points)
  return &points_;
}
inline const ::sensors::Point2D& CameraPoints2D::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::sensors::Point2D& CameraPoints2D::points(int index) const {
  // @@protoc_insertion_point(field_get:sensors.CameraPoints2D.points)
  return _internal_points(index);
}
inline ::sensors::Point2D* CameraPoints2D::_internal_add_points() {
  return points_.Add();
}
inline ::sensors::Point2D* CameraPoints2D::add_points() {
  ::sensors::Point2D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:sensors.CameraPoints2D.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point2D >&
CameraPoints2D::points() const {
  // @@protoc_insertion_point(field_list:sensors.CameraPoints2D.points)
  return points_;
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool CameraPoints2D::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool CameraPoints2D::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CameraPoints2D::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CameraPoints2D::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.CameraPoints2D.timestamp)
  return _internal_timestamp();
}
inline void CameraPoints2D::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.CameraPoints2D.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints2D::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints2D::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.CameraPoints2D.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints2D::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CameraPoints2D::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.CameraPoints2D.timestamp)
  return _msg;
}
inline void CameraPoints2D::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.CameraPoints2D.timestamp)
}

// -------------------------------------------------------------------

// Point2D

// float x = 1;
inline void Point2D::clear_x() {
  x_ = 0;
}
inline float Point2D::_internal_x() const {
  return x_;
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:sensors.Point2D.x)
  return _internal_x();
}
inline void Point2D::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sensors.Point2D.x)
}

// float y = 2;
inline void Point2D::clear_y() {
  y_ = 0;
}
inline float Point2D::_internal_y() const {
  return y_;
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:sensors.Point2D.y)
  return _internal_y();
}
inline void Point2D::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sensors.Point2D.y)
}

// -------------------------------------------------------------------

// LoggingData

// string key = 1;
inline void LoggingData::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& LoggingData::key() const {
  // @@protoc_insertion_point(field_get:sensors.LoggingData.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoggingData::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.LoggingData.key)
}
inline std::string* LoggingData::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sensors.LoggingData.key)
  return _s;
}
inline const std::string& LoggingData::_internal_key() const {
  return key_.Get();
}
inline void LoggingData::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoggingData::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoggingData::release_key() {
  // @@protoc_insertion_point(field_release:sensors.LoggingData.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoggingData::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.LoggingData.key)
}

// double value = 2;
inline void LoggingData::clear_value() {
  value_ = 0;
}
inline double LoggingData::_internal_value() const {
  return value_;
}
inline double LoggingData::value() const {
  // @@protoc_insertion_point(field_get:sensors.LoggingData.value)
  return _internal_value();
}
inline void LoggingData::_internal_set_value(double value) {
  
  value_ = value;
}
inline void LoggingData::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:sensors.LoggingData.value)
}

// int32 timestamp = 3;
inline void LoggingData::clear_timestamp() {
  timestamp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoggingData::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoggingData::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.LoggingData.timestamp)
  return _internal_timestamp();
}
inline void LoggingData::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  timestamp_ = value;
}
inline void LoggingData::set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:sensors.LoggingData.timestamp)
}

// repeated .sensors.Point3D points = 4;
inline int LoggingData::_internal_points_size() const {
  return points_.size();
}
inline int LoggingData::points_size() const {
  return _internal_points_size();
}
inline void LoggingData::clear_points() {
  points_.Clear();
}
inline ::sensors::Point3D* LoggingData::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.LoggingData.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >*
LoggingData::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:sensors.LoggingData.points)
  return &points_;
}
inline const ::sensors::Point3D& LoggingData::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::sensors::Point3D& LoggingData::points(int index) const {
  // @@protoc_insertion_point(field_get:sensors.LoggingData.points)
  return _internal_points(index);
}
inline ::sensors::Point3D* LoggingData::_internal_add_points() {
  return points_.Add();
}
inline ::sensors::Point3D* LoggingData::add_points() {
  ::sensors::Point3D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:sensors.LoggingData.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >&
LoggingData::points() const {
  // @@protoc_insertion_point(field_list:sensors.LoggingData.points)
  return points_;
}

// -------------------------------------------------------------------

// Led

// .sensors.Led.Leds led = 1;
inline void Led::clear_led() {
  led_ = 0;
}
inline ::sensors::Led_Leds Led::_internal_led() const {
  return static_cast< ::sensors::Led_Leds >(led_);
}
inline ::sensors::Led_Leds Led::led() const {
  // @@protoc_insertion_point(field_get:sensors.Led.led)
  return _internal_led();
}
inline void Led::_internal_set_led(::sensors::Led_Leds value) {
  
  led_ = value;
}
inline void Led::set_led(::sensors::Led_Leds value) {
  _internal_set_led(value);
  // @@protoc_insertion_point(field_set:sensors.Led.led)
}

// -------------------------------------------------------------------

// HmiState

// .sensors.HmiState.States state = 1;
inline void HmiState::clear_state() {
  state_ = 0;
}
inline ::sensors::HmiState_States HmiState::_internal_state() const {
  return static_cast< ::sensors::HmiState_States >(state_);
}
inline ::sensors::HmiState_States HmiState::state() const {
  // @@protoc_insertion_point(field_get:sensors.HmiState.state)
  return _internal_state();
}
inline void HmiState::_internal_set_state(::sensors::HmiState_States value) {
  
  state_ = value;
}
inline void HmiState::set_state(::sensors::HmiState_States value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:sensors.HmiState.state)
}

// -------------------------------------------------------------------

// HmiStreamData

// bool is_alt_override = 1;
inline void HmiStreamData::clear_is_alt_override() {
  is_alt_override_ = false;
}
inline bool HmiStreamData::_internal_is_alt_override() const {
  return is_alt_override_;
}
inline bool HmiStreamData::is_alt_override() const {
  // @@protoc_insertion_point(field_get:sensors.HmiStreamData.is_alt_override)
  return _internal_is_alt_override();
}
inline void HmiStreamData::_internal_set_is_alt_override(bool value) {
  
  is_alt_override_ = value;
}
inline void HmiStreamData::set_is_alt_override(bool value) {
  _internal_set_is_alt_override(value);
  // @@protoc_insertion_point(field_set:sensors.HmiStreamData.is_alt_override)
}

// .sensors.HmiStreamData.ButtonState button_state = 2;
inline void HmiStreamData::clear_button_state() {
  button_state_ = 0;
}
inline ::sensors::HmiStreamData_ButtonState HmiStreamData::_internal_button_state() const {
  return static_cast< ::sensors::HmiStreamData_ButtonState >(button_state_);
}
inline ::sensors::HmiStreamData_ButtonState HmiStreamData::button_state() const {
  // @@protoc_insertion_point(field_get:sensors.HmiStreamData.button_state)
  return _internal_button_state();
}
inline void HmiStreamData::_internal_set_button_state(::sensors::HmiStreamData_ButtonState value) {
  
  button_state_ = value;
}
inline void HmiStreamData::set_button_state(::sensors::HmiStreamData_ButtonState value) {
  _internal_set_button_state(value);
  // @@protoc_insertion_point(field_set:sensors.HmiStreamData.button_state)
}

// -------------------------------------------------------------------

// PressCountStreamData

// int32 press_count = 1;
inline void PressCountStreamData::clear_press_count() {
  press_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PressCountStreamData::_internal_press_count() const {
  return press_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PressCountStreamData::press_count() const {
  // @@protoc_insertion_point(field_get:sensors.PressCountStreamData.press_count)
  return _internal_press_count();
}
inline void PressCountStreamData::_internal_set_press_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  press_count_ = value;
}
inline void PressCountStreamData::set_press_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_press_count(value);
  // @@protoc_insertion_point(field_set:sensors.PressCountStreamData.press_count)
}

// -------------------------------------------------------------------

// NavigationScaling

// float front_fb = 1;
inline void NavigationScaling::clear_front_fb() {
  front_fb_ = 0;
}
inline float NavigationScaling::_internal_front_fb() const {
  return front_fb_;
}
inline float NavigationScaling::front_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.front_fb)
  return _internal_front_fb();
}
inline void NavigationScaling::_internal_set_front_fb(float value) {
  
  front_fb_ = value;
}
inline void NavigationScaling::set_front_fb(float value) {
  _internal_set_front_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.front_fb)
}

// float front_rl = 2;
inline void NavigationScaling::clear_front_rl() {
  front_rl_ = 0;
}
inline float NavigationScaling::_internal_front_rl() const {
  return front_rl_;
}
inline float NavigationScaling::front_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.front_rl)
  return _internal_front_rl();
}
inline void NavigationScaling::_internal_set_front_rl(float value) {
  
  front_rl_ = value;
}
inline void NavigationScaling::set_front_rl(float value) {
  _internal_set_front_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.front_rl)
}

// float front_right_fb = 3;
inline void NavigationScaling::clear_front_right_fb() {
  front_right_fb_ = 0;
}
inline float NavigationScaling::_internal_front_right_fb() const {
  return front_right_fb_;
}
inline float NavigationScaling::front_right_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.front_right_fb)
  return _internal_front_right_fb();
}
inline void NavigationScaling::_internal_set_front_right_fb(float value) {
  
  front_right_fb_ = value;
}
inline void NavigationScaling::set_front_right_fb(float value) {
  _internal_set_front_right_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.front_right_fb)
}

// float front_right_rl = 4;
inline void NavigationScaling::clear_front_right_rl() {
  front_right_rl_ = 0;
}
inline float NavigationScaling::_internal_front_right_rl() const {
  return front_right_rl_;
}
inline float NavigationScaling::front_right_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.front_right_rl)
  return _internal_front_right_rl();
}
inline void NavigationScaling::_internal_set_front_right_rl(float value) {
  
  front_right_rl_ = value;
}
inline void NavigationScaling::set_front_right_rl(float value) {
  _internal_set_front_right_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.front_right_rl)
}

// float front_left_fb = 5;
inline void NavigationScaling::clear_front_left_fb() {
  front_left_fb_ = 0;
}
inline float NavigationScaling::_internal_front_left_fb() const {
  return front_left_fb_;
}
inline float NavigationScaling::front_left_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.front_left_fb)
  return _internal_front_left_fb();
}
inline void NavigationScaling::_internal_set_front_left_fb(float value) {
  
  front_left_fb_ = value;
}
inline void NavigationScaling::set_front_left_fb(float value) {
  _internal_set_front_left_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.front_left_fb)
}

// float front_left_rl = 6;
inline void NavigationScaling::clear_front_left_rl() {
  front_left_rl_ = 0;
}
inline float NavigationScaling::_internal_front_left_rl() const {
  return front_left_rl_;
}
inline float NavigationScaling::front_left_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.front_left_rl)
  return _internal_front_left_rl();
}
inline void NavigationScaling::_internal_set_front_left_rl(float value) {
  
  front_left_rl_ = value;
}
inline void NavigationScaling::set_front_left_rl(float value) {
  _internal_set_front_left_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.front_left_rl)
}

// float right_fb = 7;
inline void NavigationScaling::clear_right_fb() {
  right_fb_ = 0;
}
inline float NavigationScaling::_internal_right_fb() const {
  return right_fb_;
}
inline float NavigationScaling::right_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.right_fb)
  return _internal_right_fb();
}
inline void NavigationScaling::_internal_set_right_fb(float value) {
  
  right_fb_ = value;
}
inline void NavigationScaling::set_right_fb(float value) {
  _internal_set_right_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.right_fb)
}

// float right_rl = 8;
inline void NavigationScaling::clear_right_rl() {
  right_rl_ = 0;
}
inline float NavigationScaling::_internal_right_rl() const {
  return right_rl_;
}
inline float NavigationScaling::right_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.right_rl)
  return _internal_right_rl();
}
inline void NavigationScaling::_internal_set_right_rl(float value) {
  
  right_rl_ = value;
}
inline void NavigationScaling::set_right_rl(float value) {
  _internal_set_right_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.right_rl)
}

// float left_fb = 9;
inline void NavigationScaling::clear_left_fb() {
  left_fb_ = 0;
}
inline float NavigationScaling::_internal_left_fb() const {
  return left_fb_;
}
inline float NavigationScaling::left_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.left_fb)
  return _internal_left_fb();
}
inline void NavigationScaling::_internal_set_left_fb(float value) {
  
  left_fb_ = value;
}
inline void NavigationScaling::set_left_fb(float value) {
  _internal_set_left_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.left_fb)
}

// float left_rl = 10;
inline void NavigationScaling::clear_left_rl() {
  left_rl_ = 0;
}
inline float NavigationScaling::_internal_left_rl() const {
  return left_rl_;
}
inline float NavigationScaling::left_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.left_rl)
  return _internal_left_rl();
}
inline void NavigationScaling::_internal_set_left_rl(float value) {
  
  left_rl_ = value;
}
inline void NavigationScaling::set_left_rl(float value) {
  _internal_set_left_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.left_rl)
}

// float back_right_fb = 11;
inline void NavigationScaling::clear_back_right_fb() {
  back_right_fb_ = 0;
}
inline float NavigationScaling::_internal_back_right_fb() const {
  return back_right_fb_;
}
inline float NavigationScaling::back_right_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.back_right_fb)
  return _internal_back_right_fb();
}
inline void NavigationScaling::_internal_set_back_right_fb(float value) {
  
  back_right_fb_ = value;
}
inline void NavigationScaling::set_back_right_fb(float value) {
  _internal_set_back_right_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.back_right_fb)
}

// float back_right_rl = 12;
inline void NavigationScaling::clear_back_right_rl() {
  back_right_rl_ = 0;
}
inline float NavigationScaling::_internal_back_right_rl() const {
  return back_right_rl_;
}
inline float NavigationScaling::back_right_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.back_right_rl)
  return _internal_back_right_rl();
}
inline void NavigationScaling::_internal_set_back_right_rl(float value) {
  
  back_right_rl_ = value;
}
inline void NavigationScaling::set_back_right_rl(float value) {
  _internal_set_back_right_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.back_right_rl)
}

// float back_left_fb = 13;
inline void NavigationScaling::clear_back_left_fb() {
  back_left_fb_ = 0;
}
inline float NavigationScaling::_internal_back_left_fb() const {
  return back_left_fb_;
}
inline float NavigationScaling::back_left_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.back_left_fb)
  return _internal_back_left_fb();
}
inline void NavigationScaling::_internal_set_back_left_fb(float value) {
  
  back_left_fb_ = value;
}
inline void NavigationScaling::set_back_left_fb(float value) {
  _internal_set_back_left_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.back_left_fb)
}

// float back_left_rl = 14;
inline void NavigationScaling::clear_back_left_rl() {
  back_left_rl_ = 0;
}
inline float NavigationScaling::_internal_back_left_rl() const {
  return back_left_rl_;
}
inline float NavigationScaling::back_left_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.back_left_rl)
  return _internal_back_left_rl();
}
inline void NavigationScaling::_internal_set_back_left_rl(float value) {
  
  back_left_rl_ = value;
}
inline void NavigationScaling::set_back_left_rl(float value) {
  _internal_set_back_left_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.back_left_rl)
}

// float back_fb = 15;
inline void NavigationScaling::clear_back_fb() {
  back_fb_ = 0;
}
inline float NavigationScaling::_internal_back_fb() const {
  return back_fb_;
}
inline float NavigationScaling::back_fb() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.back_fb)
  return _internal_back_fb();
}
inline void NavigationScaling::_internal_set_back_fb(float value) {
  
  back_fb_ = value;
}
inline void NavigationScaling::set_back_fb(float value) {
  _internal_set_back_fb(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.back_fb)
}

// float back_rl = 16;
inline void NavigationScaling::clear_back_rl() {
  back_rl_ = 0;
}
inline float NavigationScaling::_internal_back_rl() const {
  return back_rl_;
}
inline float NavigationScaling::back_rl() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.back_rl)
  return _internal_back_rl();
}
inline void NavigationScaling::_internal_set_back_rl(float value) {
  
  back_rl_ = value;
}
inline void NavigationScaling::set_back_rl(float value) {
  _internal_set_back_rl(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.back_rl)
}

// uint32 max_js_scale_increase = 17;
inline void NavigationScaling::clear_max_js_scale_increase() {
  max_js_scale_increase_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationScaling::_internal_max_js_scale_increase() const {
  return max_js_scale_increase_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationScaling::max_js_scale_increase() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.max_js_scale_increase)
  return _internal_max_js_scale_increase();
}
inline void NavigationScaling::_internal_set_max_js_scale_increase(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  max_js_scale_increase_ = value;
}
inline void NavigationScaling::set_max_js_scale_increase(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_js_scale_increase(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.max_js_scale_increase)
}

// uint32 max_js_scale_decrease = 18;
inline void NavigationScaling::clear_max_js_scale_decrease() {
  max_js_scale_decrease_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationScaling::_internal_max_js_scale_decrease() const {
  return max_js_scale_decrease_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationScaling::max_js_scale_decrease() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.max_js_scale_decrease)
  return _internal_max_js_scale_decrease();
}
inline void NavigationScaling::_internal_set_max_js_scale_decrease(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  max_js_scale_decrease_ = value;
}
inline void NavigationScaling::set_max_js_scale_decrease(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_js_scale_decrease(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.max_js_scale_decrease)
}

// bool luci_active = 19;
inline void NavigationScaling::clear_luci_active() {
  luci_active_ = false;
}
inline bool NavigationScaling::_internal_luci_active() const {
  return luci_active_;
}
inline bool NavigationScaling::luci_active() const {
  // @@protoc_insertion_point(field_get:sensors.NavigationScaling.luci_active)
  return _internal_luci_active();
}
inline void NavigationScaling::_internal_set_luci_active(bool value) {
  
  luci_active_ = value;
}
inline void NavigationScaling::set_luci_active(bool value) {
  _internal_set_luci_active(value);
  // @@protoc_insertion_point(field_set:sensors.NavigationScaling.luci_active)
}

// -------------------------------------------------------------------

// UltrasonicCtrl

// .sensors.UltrasonicCtrl.Board board = 1;
inline void UltrasonicCtrl::clear_board() {
  board_ = 0;
}
inline ::sensors::UltrasonicCtrl_Board UltrasonicCtrl::_internal_board() const {
  return static_cast< ::sensors::UltrasonicCtrl_Board >(board_);
}
inline ::sensors::UltrasonicCtrl_Board UltrasonicCtrl::board() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCtrl.board)
  return _internal_board();
}
inline void UltrasonicCtrl::_internal_set_board(::sensors::UltrasonicCtrl_Board value) {
  
  board_ = value;
}
inline void UltrasonicCtrl::set_board(::sensors::UltrasonicCtrl_Board value) {
  _internal_set_board(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCtrl.board)
}

// int32 spi_id = 2;
inline void UltrasonicCtrl::clear_spi_id() {
  spi_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCtrl::_internal_spi_id() const {
  return spi_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCtrl::spi_id() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCtrl.spi_id)
  return _internal_spi_id();
}
inline void UltrasonicCtrl::_internal_set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  spi_id_ = value;
}
inline void UltrasonicCtrl::set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_spi_id(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCtrl.spi_id)
}

// int32 address = 3;
inline void UltrasonicCtrl::clear_address() {
  address_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCtrl::_internal_address() const {
  return address_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCtrl::address() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCtrl.address)
  return _internal_address();
}
inline void UltrasonicCtrl::_internal_set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  address_ = value;
}
inline void UltrasonicCtrl::set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCtrl.address)
}

// -------------------------------------------------------------------

// UltrasonicDistance

// double distance = 1;
inline void UltrasonicDistance::clear_distance() {
  distance_ = 0;
}
inline double UltrasonicDistance::_internal_distance() const {
  return distance_;
}
inline double UltrasonicDistance::distance() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistance.distance)
  return _internal_distance();
}
inline void UltrasonicDistance::_internal_set_distance(double value) {
  
  distance_ = value;
}
inline void UltrasonicDistance::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicDistance.distance)
}

// .sensors.UltrasonicDistance.Board board = 2;
inline void UltrasonicDistance::clear_board() {
  board_ = 0;
}
inline ::sensors::UltrasonicDistance_Board UltrasonicDistance::_internal_board() const {
  return static_cast< ::sensors::UltrasonicDistance_Board >(board_);
}
inline ::sensors::UltrasonicDistance_Board UltrasonicDistance::board() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistance.board)
  return _internal_board();
}
inline void UltrasonicDistance::_internal_set_board(::sensors::UltrasonicDistance_Board value) {
  
  board_ = value;
}
inline void UltrasonicDistance::set_board(::sensors::UltrasonicDistance_Board value) {
  _internal_set_board(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicDistance.board)
}

// int32 spi_id = 3;
inline void UltrasonicDistance::clear_spi_id() {
  spi_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicDistance::_internal_spi_id() const {
  return spi_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicDistance::spi_id() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistance.spi_id)
  return _internal_spi_id();
}
inline void UltrasonicDistance::_internal_set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  spi_id_ = value;
}
inline void UltrasonicDistance::set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_spi_id(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicDistance.spi_id)
}

// int32 address = 4;
inline void UltrasonicDistance::clear_address() {
  address_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicDistance::_internal_address() const {
  return address_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicDistance::address() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistance.address)
  return _internal_address();
}
inline void UltrasonicDistance::_internal_set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  address_ = value;
}
inline void UltrasonicDistance::set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicDistance.address)
}

// .google.protobuf.Timestamp timestamp = 5;
inline bool UltrasonicDistance::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool UltrasonicDistance::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UltrasonicDistance::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UltrasonicDistance::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistance.timestamp)
  return _internal_timestamp();
}
inline void UltrasonicDistance::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.UltrasonicDistance.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UltrasonicDistance::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UltrasonicDistance::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.UltrasonicDistance.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UltrasonicDistance::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UltrasonicDistance::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.UltrasonicDistance.timestamp)
  return _msg;
}
inline void UltrasonicDistance::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.UltrasonicDistance.timestamp)
}

// repeated .sensors.Point3D arc_points = 6;
inline int UltrasonicDistance::_internal_arc_points_size() const {
  return arc_points_.size();
}
inline int UltrasonicDistance::arc_points_size() const {
  return _internal_arc_points_size();
}
inline void UltrasonicDistance::clear_arc_points() {
  arc_points_.Clear();
}
inline ::sensors::Point3D* UltrasonicDistance::mutable_arc_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.UltrasonicDistance.arc_points)
  return arc_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >*
UltrasonicDistance::mutable_arc_points() {
  // @@protoc_insertion_point(field_mutable_list:sensors.UltrasonicDistance.arc_points)
  return &arc_points_;
}
inline const ::sensors::Point3D& UltrasonicDistance::_internal_arc_points(int index) const {
  return arc_points_.Get(index);
}
inline const ::sensors::Point3D& UltrasonicDistance::arc_points(int index) const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistance.arc_points)
  return _internal_arc_points(index);
}
inline ::sensors::Point3D* UltrasonicDistance::_internal_add_arc_points() {
  return arc_points_.Add();
}
inline ::sensors::Point3D* UltrasonicDistance::add_arc_points() {
  ::sensors::Point3D* _add = _internal_add_arc_points();
  // @@protoc_insertion_point(field_add:sensors.UltrasonicDistance.arc_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Point3D >&
UltrasonicDistance::arc_points() const {
  // @@protoc_insertion_point(field_list:sensors.UltrasonicDistance.arc_points)
  return arc_points_;
}

// -------------------------------------------------------------------

// UltrasonicDistances

// repeated .sensors.UltrasonicDistance distances = 1;
inline int UltrasonicDistances::_internal_distances_size() const {
  return distances_.size();
}
inline int UltrasonicDistances::distances_size() const {
  return _internal_distances_size();
}
inline void UltrasonicDistances::clear_distances() {
  distances_.Clear();
}
inline ::sensors::UltrasonicDistance* UltrasonicDistances::mutable_distances(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.UltrasonicDistances.distances)
  return distances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::UltrasonicDistance >*
UltrasonicDistances::mutable_distances() {
  // @@protoc_insertion_point(field_mutable_list:sensors.UltrasonicDistances.distances)
  return &distances_;
}
inline const ::sensors::UltrasonicDistance& UltrasonicDistances::_internal_distances(int index) const {
  return distances_.Get(index);
}
inline const ::sensors::UltrasonicDistance& UltrasonicDistances::distances(int index) const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicDistances.distances)
  return _internal_distances(index);
}
inline ::sensors::UltrasonicDistance* UltrasonicDistances::_internal_add_distances() {
  return distances_.Add();
}
inline ::sensors::UltrasonicDistance* UltrasonicDistances::add_distances() {
  ::sensors::UltrasonicDistance* _add = _internal_add_distances();
  // @@protoc_insertion_point(field_add:sensors.UltrasonicDistances.distances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::UltrasonicDistance >&
UltrasonicDistances::distances() const {
  // @@protoc_insertion_point(field_list:sensors.UltrasonicDistances.distances)
  return distances_;
}

// -------------------------------------------------------------------

// UltrasonicCurve

// repeated int32 curve = 1;
inline int UltrasonicCurve::_internal_curve_size() const {
  return curve_.size();
}
inline int UltrasonicCurve::curve_size() const {
  return _internal_curve_size();
}
inline void UltrasonicCurve::clear_curve() {
  curve_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCurve::_internal_curve(int index) const {
  return curve_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCurve::curve(int index) const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCurve.curve)
  return _internal_curve(index);
}
inline void UltrasonicCurve::set_curve(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  curve_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCurve.curve)
}
inline void UltrasonicCurve::_internal_add_curve(::PROTOBUF_NAMESPACE_ID::int32 value) {
  curve_.Add(value);
}
inline void UltrasonicCurve::add_curve(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_curve(value);
  // @@protoc_insertion_point(field_add:sensors.UltrasonicCurve.curve)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UltrasonicCurve::_internal_curve() const {
  return curve_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UltrasonicCurve::curve() const {
  // @@protoc_insertion_point(field_list:sensors.UltrasonicCurve.curve)
  return _internal_curve();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UltrasonicCurve::_internal_mutable_curve() {
  return &curve_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UltrasonicCurve::mutable_curve() {
  // @@protoc_insertion_point(field_mutable_list:sensors.UltrasonicCurve.curve)
  return _internal_mutable_curve();
}

// .sensors.UltrasonicCurve.Board board = 2;
inline void UltrasonicCurve::clear_board() {
  board_ = 0;
}
inline ::sensors::UltrasonicCurve_Board UltrasonicCurve::_internal_board() const {
  return static_cast< ::sensors::UltrasonicCurve_Board >(board_);
}
inline ::sensors::UltrasonicCurve_Board UltrasonicCurve::board() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCurve.board)
  return _internal_board();
}
inline void UltrasonicCurve::_internal_set_board(::sensors::UltrasonicCurve_Board value) {
  
  board_ = value;
}
inline void UltrasonicCurve::set_board(::sensors::UltrasonicCurve_Board value) {
  _internal_set_board(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCurve.board)
}

// int32 spi_id = 3;
inline void UltrasonicCurve::clear_spi_id() {
  spi_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCurve::_internal_spi_id() const {
  return spi_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCurve::spi_id() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCurve.spi_id)
  return _internal_spi_id();
}
inline void UltrasonicCurve::_internal_set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  spi_id_ = value;
}
inline void UltrasonicCurve::set_spi_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_spi_id(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCurve.spi_id)
}

// int32 address = 4;
inline void UltrasonicCurve::clear_address() {
  address_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCurve::_internal_address() const {
  return address_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UltrasonicCurve::address() const {
  // @@protoc_insertion_point(field_get:sensors.UltrasonicCurve.address)
  return _internal_address();
}
inline void UltrasonicCurve::_internal_set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  address_ = value;
}
inline void UltrasonicCurve::set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:sensors.UltrasonicCurve.address)
}

// -------------------------------------------------------------------

// RadarFilter

// .sensors.RadarFilter.Filter filter = 1;
inline void RadarFilter::clear_filter() {
  filter_ = 0;
}
inline ::sensors::RadarFilter_Filter RadarFilter::_internal_filter() const {
  return static_cast< ::sensors::RadarFilter_Filter >(filter_);
}
inline ::sensors::RadarFilter_Filter RadarFilter::filter() const {
  // @@protoc_insertion_point(field_get:sensors.RadarFilter.filter)
  return _internal_filter();
}
inline void RadarFilter::_internal_set_filter(::sensors::RadarFilter_Filter value) {
  
  filter_ = value;
}
inline void RadarFilter::set_filter(::sensors::RadarFilter_Filter value) {
  _internal_set_filter(value);
  // @@protoc_insertion_point(field_set:sensors.RadarFilter.filter)
}

// -------------------------------------------------------------------

// RadarCtrl

// .sensors.RadarCtrl.Radar radar = 1;
inline void RadarCtrl::clear_radar() {
  radar_ = 0;
}
inline ::sensors::RadarCtrl_Radar RadarCtrl::_internal_radar() const {
  return static_cast< ::sensors::RadarCtrl_Radar >(radar_);
}
inline ::sensors::RadarCtrl_Radar RadarCtrl::radar() const {
  // @@protoc_insertion_point(field_get:sensors.RadarCtrl.radar)
  return _internal_radar();
}
inline void RadarCtrl::_internal_set_radar(::sensors::RadarCtrl_Radar value) {
  
  radar_ = value;
}
inline void RadarCtrl::set_radar(::sensors::RadarCtrl_Radar value) {
  _internal_set_radar(value);
  // @@protoc_insertion_point(field_set:sensors.RadarCtrl.radar)
}

// -------------------------------------------------------------------

// RadarPoint

// double x = 1;
inline void RadarPoint::clear_x() {
  x_ = 0;
}
inline double RadarPoint::_internal_x() const {
  return x_;
}
inline double RadarPoint::x() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoint.x)
  return _internal_x();
}
inline void RadarPoint::_internal_set_x(double value) {
  
  x_ = value;
}
inline void RadarPoint::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sensors.RadarPoint.x)
}

// double y = 2;
inline void RadarPoint::clear_y() {
  y_ = 0;
}
inline double RadarPoint::_internal_y() const {
  return y_;
}
inline double RadarPoint::y() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoint.y)
  return _internal_y();
}
inline void RadarPoint::_internal_set_y(double value) {
  
  y_ = value;
}
inline void RadarPoint::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sensors.RadarPoint.y)
}

// double z = 3;
inline void RadarPoint::clear_z() {
  z_ = 0;
}
inline double RadarPoint::_internal_z() const {
  return z_;
}
inline double RadarPoint::z() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoint.z)
  return _internal_z();
}
inline void RadarPoint::_internal_set_z(double value) {
  
  z_ = value;
}
inline void RadarPoint::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sensors.RadarPoint.z)
}

// double doppler = 4;
inline void RadarPoint::clear_doppler() {
  doppler_ = 0;
}
inline double RadarPoint::_internal_doppler() const {
  return doppler_;
}
inline double RadarPoint::doppler() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoint.doppler)
  return _internal_doppler();
}
inline void RadarPoint::_internal_set_doppler(double value) {
  
  doppler_ = value;
}
inline void RadarPoint::set_doppler(double value) {
  _internal_set_doppler(value);
  // @@protoc_insertion_point(field_set:sensors.RadarPoint.doppler)
}

// double cross_section = 5;
inline void RadarPoint::clear_cross_section() {
  cross_section_ = 0;
}
inline double RadarPoint::_internal_cross_section() const {
  return cross_section_;
}
inline double RadarPoint::cross_section() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoint.cross_section)
  return _internal_cross_section();
}
inline void RadarPoint::_internal_set_cross_section(double value) {
  
  cross_section_ = value;
}
inline void RadarPoint::set_cross_section(double value) {
  _internal_set_cross_section(value);
  // @@protoc_insertion_point(field_set:sensors.RadarPoint.cross_section)
}

// -------------------------------------------------------------------

// RadarPoints

// repeated .sensors.RadarPoint points = 1;
inline int RadarPoints::_internal_points_size() const {
  return points_.size();
}
inline int RadarPoints::points_size() const {
  return _internal_points_size();
}
inline void RadarPoints::clear_points() {
  points_.Clear();
}
inline ::sensors::RadarPoint* RadarPoints::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.RadarPoints.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::RadarPoint >*
RadarPoints::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:sensors.RadarPoints.points)
  return &points_;
}
inline const ::sensors::RadarPoint& RadarPoints::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::sensors::RadarPoint& RadarPoints::points(int index) const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoints.points)
  return _internal_points(index);
}
inline ::sensors::RadarPoint* RadarPoints::_internal_add_points() {
  return points_.Add();
}
inline ::sensors::RadarPoint* RadarPoints::add_points() {
  ::sensors::RadarPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:sensors.RadarPoints.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::RadarPoint >&
RadarPoints::points() const {
  // @@protoc_insertion_point(field_list:sensors.RadarPoints.points)
  return points_;
}

// .sensors.RadarPoints.Radar source = 2;
inline void RadarPoints::clear_source() {
  source_ = 0;
}
inline ::sensors::RadarPoints_Radar RadarPoints::_internal_source() const {
  return static_cast< ::sensors::RadarPoints_Radar >(source_);
}
inline ::sensors::RadarPoints_Radar RadarPoints::source() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoints.source)
  return _internal_source();
}
inline void RadarPoints::_internal_set_source(::sensors::RadarPoints_Radar value) {
  
  source_ = value;
}
inline void RadarPoints::set_source(::sensors::RadarPoints_Radar value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:sensors.RadarPoints.source)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool RadarPoints::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool RadarPoints::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarPoints::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarPoints::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.RadarPoints.timestamp)
  return _internal_timestamp();
}
inline void RadarPoints::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.RadarPoints.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarPoints::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarPoints::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.RadarPoints.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarPoints::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarPoints::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.RadarPoints.timestamp)
  return _msg;
}
inline void RadarPoints::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.RadarPoints.timestamp)
}

// -------------------------------------------------------------------

// ChairSpeed

// double speed_m_p_s = 1;
inline void ChairSpeed::clear_speed_m_p_s() {
  speed_m_p_s_ = 0;
}
inline double ChairSpeed::_internal_speed_m_p_s() const {
  return speed_m_p_s_;
}
inline double ChairSpeed::speed_m_p_s() const {
  // @@protoc_insertion_point(field_get:sensors.ChairSpeed.speed_m_p_s)
  return _internal_speed_m_p_s();
}
inline void ChairSpeed::_internal_set_speed_m_p_s(double value) {
  
  speed_m_p_s_ = value;
}
inline void ChairSpeed::set_speed_m_p_s(double value) {
  _internal_set_speed_m_p_s(value);
  // @@protoc_insertion_point(field_set:sensors.ChairSpeed.speed_m_p_s)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool ChairSpeed::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool ChairSpeed::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChairSpeed::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChairSpeed::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.ChairSpeed.timestamp)
  return _internal_timestamp();
}
inline void ChairSpeed::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ChairSpeed.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChairSpeed::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChairSpeed::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.ChairSpeed.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChairSpeed::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChairSpeed::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.ChairSpeed.timestamp)
  return _msg;
}
inline void ChairSpeed::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.ChairSpeed.timestamp)
}

// -------------------------------------------------------------------

// ImuCtrl

// .sensors.Imu imu = 1;
inline void ImuCtrl::clear_imu() {
  imu_ = 0;
}
inline ::sensors::Imu ImuCtrl::_internal_imu() const {
  return static_cast< ::sensors::Imu >(imu_);
}
inline ::sensors::Imu ImuCtrl::imu() const {
  // @@protoc_insertion_point(field_get:sensors.ImuCtrl.imu)
  return _internal_imu();
}
inline void ImuCtrl::_internal_set_imu(::sensors::Imu value) {
  
  imu_ = value;
}
inline void ImuCtrl::set_imu(::sensors::Imu value) {
  _internal_set_imu(value);
  // @@protoc_insertion_point(field_set:sensors.ImuCtrl.imu)
}

// -------------------------------------------------------------------

// ImuData

// double quaternion_x = 1;
inline void ImuData::clear_quaternion_x() {
  quaternion_x_ = 0;
}
inline double ImuData::_internal_quaternion_x() const {
  return quaternion_x_;
}
inline double ImuData::quaternion_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.quaternion_x)
  return _internal_quaternion_x();
}
inline void ImuData::_internal_set_quaternion_x(double value) {
  
  quaternion_x_ = value;
}
inline void ImuData::set_quaternion_x(double value) {
  _internal_set_quaternion_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.quaternion_x)
}

// double quaternion_y = 2;
inline void ImuData::clear_quaternion_y() {
  quaternion_y_ = 0;
}
inline double ImuData::_internal_quaternion_y() const {
  return quaternion_y_;
}
inline double ImuData::quaternion_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.quaternion_y)
  return _internal_quaternion_y();
}
inline void ImuData::_internal_set_quaternion_y(double value) {
  
  quaternion_y_ = value;
}
inline void ImuData::set_quaternion_y(double value) {
  _internal_set_quaternion_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.quaternion_y)
}

// double quaternion_z = 3;
inline void ImuData::clear_quaternion_z() {
  quaternion_z_ = 0;
}
inline double ImuData::_internal_quaternion_z() const {
  return quaternion_z_;
}
inline double ImuData::quaternion_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.quaternion_z)
  return _internal_quaternion_z();
}
inline void ImuData::_internal_set_quaternion_z(double value) {
  
  quaternion_z_ = value;
}
inline void ImuData::set_quaternion_z(double value) {
  _internal_set_quaternion_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.quaternion_z)
}

// double quaternion_w = 4;
inline void ImuData::clear_quaternion_w() {
  quaternion_w_ = 0;
}
inline double ImuData::_internal_quaternion_w() const {
  return quaternion_w_;
}
inline double ImuData::quaternion_w() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.quaternion_w)
  return _internal_quaternion_w();
}
inline void ImuData::_internal_set_quaternion_w(double value) {
  
  quaternion_w_ = value;
}
inline void ImuData::set_quaternion_w(double value) {
  _internal_set_quaternion_w(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.quaternion_w)
}

// double acceleration_x = 5;
inline void ImuData::clear_acceleration_x() {
  acceleration_x_ = 0;
}
inline double ImuData::_internal_acceleration_x() const {
  return acceleration_x_;
}
inline double ImuData::acceleration_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.acceleration_x)
  return _internal_acceleration_x();
}
inline void ImuData::_internal_set_acceleration_x(double value) {
  
  acceleration_x_ = value;
}
inline void ImuData::set_acceleration_x(double value) {
  _internal_set_acceleration_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.acceleration_x)
}

// double acceleration_y = 6;
inline void ImuData::clear_acceleration_y() {
  acceleration_y_ = 0;
}
inline double ImuData::_internal_acceleration_y() const {
  return acceleration_y_;
}
inline double ImuData::acceleration_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.acceleration_y)
  return _internal_acceleration_y();
}
inline void ImuData::_internal_set_acceleration_y(double value) {
  
  acceleration_y_ = value;
}
inline void ImuData::set_acceleration_y(double value) {
  _internal_set_acceleration_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.acceleration_y)
}

// double acceleration_z = 7;
inline void ImuData::clear_acceleration_z() {
  acceleration_z_ = 0;
}
inline double ImuData::_internal_acceleration_z() const {
  return acceleration_z_;
}
inline double ImuData::acceleration_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.acceleration_z)
  return _internal_acceleration_z();
}
inline void ImuData::_internal_set_acceleration_z(double value) {
  
  acceleration_z_ = value;
}
inline void ImuData::set_acceleration_z(double value) {
  _internal_set_acceleration_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.acceleration_z)
}

// double gyro_x = 8;
inline void ImuData::clear_gyro_x() {
  gyro_x_ = 0;
}
inline double ImuData::_internal_gyro_x() const {
  return gyro_x_;
}
inline double ImuData::gyro_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.gyro_x)
  return _internal_gyro_x();
}
inline void ImuData::_internal_set_gyro_x(double value) {
  
  gyro_x_ = value;
}
inline void ImuData::set_gyro_x(double value) {
  _internal_set_gyro_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.gyro_x)
}

// double gyro_y = 9;
inline void ImuData::clear_gyro_y() {
  gyro_y_ = 0;
}
inline double ImuData::_internal_gyro_y() const {
  return gyro_y_;
}
inline double ImuData::gyro_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.gyro_y)
  return _internal_gyro_y();
}
inline void ImuData::_internal_set_gyro_y(double value) {
  
  gyro_y_ = value;
}
inline void ImuData::set_gyro_y(double value) {
  _internal_set_gyro_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.gyro_y)
}

// double gyro_z = 10;
inline void ImuData::clear_gyro_z() {
  gyro_z_ = 0;
}
inline double ImuData::_internal_gyro_z() const {
  return gyro_z_;
}
inline double ImuData::gyro_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.gyro_z)
  return _internal_gyro_z();
}
inline void ImuData::_internal_set_gyro_z(double value) {
  
  gyro_z_ = value;
}
inline void ImuData::set_gyro_z(double value) {
  _internal_set_gyro_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.gyro_z)
}

// double euler_x = 11;
inline void ImuData::clear_euler_x() {
  euler_x_ = 0;
}
inline double ImuData::_internal_euler_x() const {
  return euler_x_;
}
inline double ImuData::euler_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.euler_x)
  return _internal_euler_x();
}
inline void ImuData::_internal_set_euler_x(double value) {
  
  euler_x_ = value;
}
inline void ImuData::set_euler_x(double value) {
  _internal_set_euler_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.euler_x)
}

// double euler_y = 12;
inline void ImuData::clear_euler_y() {
  euler_y_ = 0;
}
inline double ImuData::_internal_euler_y() const {
  return euler_y_;
}
inline double ImuData::euler_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.euler_y)
  return _internal_euler_y();
}
inline void ImuData::_internal_set_euler_y(double value) {
  
  euler_y_ = value;
}
inline void ImuData::set_euler_y(double value) {
  _internal_set_euler_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.euler_y)
}

// double euler_z = 13;
inline void ImuData::clear_euler_z() {
  euler_z_ = 0;
}
inline double ImuData::_internal_euler_z() const {
  return euler_z_;
}
inline double ImuData::euler_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.euler_z)
  return _internal_euler_z();
}
inline void ImuData::_internal_set_euler_z(double value) {
  
  euler_z_ = value;
}
inline void ImuData::set_euler_z(double value) {
  _internal_set_euler_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.euler_z)
}

// double accelerometer_x = 14;
inline void ImuData::clear_accelerometer_x() {
  accelerometer_x_ = 0;
}
inline double ImuData::_internal_accelerometer_x() const {
  return accelerometer_x_;
}
inline double ImuData::accelerometer_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.accelerometer_x)
  return _internal_accelerometer_x();
}
inline void ImuData::_internal_set_accelerometer_x(double value) {
  
  accelerometer_x_ = value;
}
inline void ImuData::set_accelerometer_x(double value) {
  _internal_set_accelerometer_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.accelerometer_x)
}

// double accelerometer_y = 15;
inline void ImuData::clear_accelerometer_y() {
  accelerometer_y_ = 0;
}
inline double ImuData::_internal_accelerometer_y() const {
  return accelerometer_y_;
}
inline double ImuData::accelerometer_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.accelerometer_y)
  return _internal_accelerometer_y();
}
inline void ImuData::_internal_set_accelerometer_y(double value) {
  
  accelerometer_y_ = value;
}
inline void ImuData::set_accelerometer_y(double value) {
  _internal_set_accelerometer_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.accelerometer_y)
}

// double accelerometer_z = 16;
inline void ImuData::clear_accelerometer_z() {
  accelerometer_z_ = 0;
}
inline double ImuData::_internal_accelerometer_z() const {
  return accelerometer_z_;
}
inline double ImuData::accelerometer_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.accelerometer_z)
  return _internal_accelerometer_z();
}
inline void ImuData::_internal_set_accelerometer_z(double value) {
  
  accelerometer_z_ = value;
}
inline void ImuData::set_accelerometer_z(double value) {
  _internal_set_accelerometer_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.accelerometer_z)
}

// double magnetometer_x = 17;
inline void ImuData::clear_magnetometer_x() {
  magnetometer_x_ = 0;
}
inline double ImuData::_internal_magnetometer_x() const {
  return magnetometer_x_;
}
inline double ImuData::magnetometer_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.magnetometer_x)
  return _internal_magnetometer_x();
}
inline void ImuData::_internal_set_magnetometer_x(double value) {
  
  magnetometer_x_ = value;
}
inline void ImuData::set_magnetometer_x(double value) {
  _internal_set_magnetometer_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.magnetometer_x)
}

// double magnetometer_y = 18;
inline void ImuData::clear_magnetometer_y() {
  magnetometer_y_ = 0;
}
inline double ImuData::_internal_magnetometer_y() const {
  return magnetometer_y_;
}
inline double ImuData::magnetometer_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.magnetometer_y)
  return _internal_magnetometer_y();
}
inline void ImuData::_internal_set_magnetometer_y(double value) {
  
  magnetometer_y_ = value;
}
inline void ImuData::set_magnetometer_y(double value) {
  _internal_set_magnetometer_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.magnetometer_y)
}

// double magnetometer_z = 19;
inline void ImuData::clear_magnetometer_z() {
  magnetometer_z_ = 0;
}
inline double ImuData::_internal_magnetometer_z() const {
  return magnetometer_z_;
}
inline double ImuData::magnetometer_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.magnetometer_z)
  return _internal_magnetometer_z();
}
inline void ImuData::_internal_set_magnetometer_z(double value) {
  
  magnetometer_z_ = value;
}
inline void ImuData::set_magnetometer_z(double value) {
  _internal_set_magnetometer_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.magnetometer_z)
}

// double gravity_x = 20;
inline void ImuData::clear_gravity_x() {
  gravity_x_ = 0;
}
inline double ImuData::_internal_gravity_x() const {
  return gravity_x_;
}
inline double ImuData::gravity_x() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.gravity_x)
  return _internal_gravity_x();
}
inline void ImuData::_internal_set_gravity_x(double value) {
  
  gravity_x_ = value;
}
inline void ImuData::set_gravity_x(double value) {
  _internal_set_gravity_x(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.gravity_x)
}

// double gravity_y = 21;
inline void ImuData::clear_gravity_y() {
  gravity_y_ = 0;
}
inline double ImuData::_internal_gravity_y() const {
  return gravity_y_;
}
inline double ImuData::gravity_y() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.gravity_y)
  return _internal_gravity_y();
}
inline void ImuData::_internal_set_gravity_y(double value) {
  
  gravity_y_ = value;
}
inline void ImuData::set_gravity_y(double value) {
  _internal_set_gravity_y(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.gravity_y)
}

// double gravity_z = 22;
inline void ImuData::clear_gravity_z() {
  gravity_z_ = 0;
}
inline double ImuData::_internal_gravity_z() const {
  return gravity_z_;
}
inline double ImuData::gravity_z() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.gravity_z)
  return _internal_gravity_z();
}
inline void ImuData::_internal_set_gravity_z(double value) {
  
  gravity_z_ = value;
}
inline void ImuData::set_gravity_z(double value) {
  _internal_set_gravity_z(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.gravity_z)
}

// .sensors.ImuData.CalibrationStatus cal_system = 23;
inline void ImuData::clear_cal_system() {
  cal_system_ = 0;
}
inline ::sensors::ImuData_CalibrationStatus ImuData::_internal_cal_system() const {
  return static_cast< ::sensors::ImuData_CalibrationStatus >(cal_system_);
}
inline ::sensors::ImuData_CalibrationStatus ImuData::cal_system() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.cal_system)
  return _internal_cal_system();
}
inline void ImuData::_internal_set_cal_system(::sensors::ImuData_CalibrationStatus value) {
  
  cal_system_ = value;
}
inline void ImuData::set_cal_system(::sensors::ImuData_CalibrationStatus value) {
  _internal_set_cal_system(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.cal_system)
}

// .sensors.ImuData.CalibrationStatus cal_gyroscope = 24;
inline void ImuData::clear_cal_gyroscope() {
  cal_gyroscope_ = 0;
}
inline ::sensors::ImuData_CalibrationStatus ImuData::_internal_cal_gyroscope() const {
  return static_cast< ::sensors::ImuData_CalibrationStatus >(cal_gyroscope_);
}
inline ::sensors::ImuData_CalibrationStatus ImuData::cal_gyroscope() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.cal_gyroscope)
  return _internal_cal_gyroscope();
}
inline void ImuData::_internal_set_cal_gyroscope(::sensors::ImuData_CalibrationStatus value) {
  
  cal_gyroscope_ = value;
}
inline void ImuData::set_cal_gyroscope(::sensors::ImuData_CalibrationStatus value) {
  _internal_set_cal_gyroscope(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.cal_gyroscope)
}

// .sensors.ImuData.CalibrationStatus cal_accelerometer = 25;
inline void ImuData::clear_cal_accelerometer() {
  cal_accelerometer_ = 0;
}
inline ::sensors::ImuData_CalibrationStatus ImuData::_internal_cal_accelerometer() const {
  return static_cast< ::sensors::ImuData_CalibrationStatus >(cal_accelerometer_);
}
inline ::sensors::ImuData_CalibrationStatus ImuData::cal_accelerometer() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.cal_accelerometer)
  return _internal_cal_accelerometer();
}
inline void ImuData::_internal_set_cal_accelerometer(::sensors::ImuData_CalibrationStatus value) {
  
  cal_accelerometer_ = value;
}
inline void ImuData::set_cal_accelerometer(::sensors::ImuData_CalibrationStatus value) {
  _internal_set_cal_accelerometer(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.cal_accelerometer)
}

// .sensors.ImuData.CalibrationStatus cal_magnetometer = 26;
inline void ImuData::clear_cal_magnetometer() {
  cal_magnetometer_ = 0;
}
inline ::sensors::ImuData_CalibrationStatus ImuData::_internal_cal_magnetometer() const {
  return static_cast< ::sensors::ImuData_CalibrationStatus >(cal_magnetometer_);
}
inline ::sensors::ImuData_CalibrationStatus ImuData::cal_magnetometer() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.cal_magnetometer)
  return _internal_cal_magnetometer();
}
inline void ImuData::_internal_set_cal_magnetometer(::sensors::ImuData_CalibrationStatus value) {
  
  cal_magnetometer_ = value;
}
inline void ImuData::set_cal_magnetometer(::sensors::ImuData_CalibrationStatus value) {
  _internal_set_cal_magnetometer(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.cal_magnetometer)
}

// .google.protobuf.Timestamp timestamp = 27;
inline bool ImuData::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool ImuData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ImuData::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ImuData::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.timestamp)
  return _internal_timestamp();
}
inline void ImuData::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.ImuData.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImuData::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImuData::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.ImuData.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImuData::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImuData::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.ImuData.timestamp)
  return _msg;
}
inline void ImuData::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.ImuData.timestamp)
}

// .sensors.Imu source = 28;
inline void ImuData::clear_source() {
  source_ = 0;
}
inline ::sensors::Imu ImuData::_internal_source() const {
  return static_cast< ::sensors::Imu >(source_);
}
inline ::sensors::Imu ImuData::source() const {
  // @@protoc_insertion_point(field_get:sensors.ImuData.source)
  return _internal_source();
}
inline void ImuData::_internal_set_source(::sensors::Imu value) {
  
  source_ = value;
}
inline void ImuData::set_source(::sensors::Imu value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:sensors.ImuData.source)
}

// -------------------------------------------------------------------

// ChairMode

// bool is_drive_mode = 1;
inline void ChairMode::clear_is_drive_mode() {
  is_drive_mode_ = false;
}
inline bool ChairMode::_internal_is_drive_mode() const {
  return is_drive_mode_;
}
inline bool ChairMode::is_drive_mode() const {
  // @@protoc_insertion_point(field_get:sensors.ChairMode.is_drive_mode)
  return _internal_is_drive_mode();
}
inline void ChairMode::_internal_set_is_drive_mode(bool value) {
  
  is_drive_mode_ = value;
}
inline void ChairMode::set_is_drive_mode(bool value) {
  _internal_set_is_drive_mode(value);
  // @@protoc_insertion_point(field_set:sensors.ChairMode.is_drive_mode)
}

// -------------------------------------------------------------------

// ChairProfile

// int32 profile = 1;
inline void ChairProfile::clear_profile() {
  profile_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChairProfile::_internal_profile() const {
  return profile_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChairProfile::profile() const {
  // @@protoc_insertion_point(field_get:sensors.ChairProfile.profile)
  return _internal_profile();
}
inline void ChairProfile::_internal_set_profile(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  profile_ = value;
}
inline void ChairProfile::set_profile(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_profile(value);
  // @@protoc_insertion_point(field_set:sensors.ChairProfile.profile)
}

// -------------------------------------------------------------------

// SpeedSetting

// int32 speed_setting = 1;
inline void SpeedSetting::clear_speed_setting() {
  speed_setting_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeedSetting::_internal_speed_setting() const {
  return speed_setting_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeedSetting::speed_setting() const {
  // @@protoc_insertion_point(field_get:sensors.SpeedSetting.speed_setting)
  return _internal_speed_setting();
}
inline void SpeedSetting::_internal_set_speed_setting(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  speed_setting_ = value;
}
inline void SpeedSetting::set_speed_setting(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_speed_setting(value);
  // @@protoc_insertion_point(field_set:sensors.SpeedSetting.speed_setting)
}

// -------------------------------------------------------------------

// JoystickData

// int32 forward_back = 1;
inline void JoystickData::clear_forward_back() {
  forward_back_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoystickData::_internal_forward_back() const {
  return forward_back_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoystickData::forward_back() const {
  // @@protoc_insertion_point(field_get:sensors.JoystickData.forward_back)
  return _internal_forward_back();
}
inline void JoystickData::_internal_set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  forward_back_ = value;
}
inline void JoystickData::set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_forward_back(value);
  // @@protoc_insertion_point(field_set:sensors.JoystickData.forward_back)
}

// int32 left_right = 2;
inline void JoystickData::clear_left_right() {
  left_right_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoystickData::_internal_left_right() const {
  return left_right_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoystickData::left_right() const {
  // @@protoc_insertion_point(field_get:sensors.JoystickData.left_right)
  return _internal_left_right();
}
inline void JoystickData::_internal_set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  left_right_ = value;
}
inline void JoystickData::set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_left_right(value);
  // @@protoc_insertion_point(field_set:sensors.JoystickData.left_right)
}

// string joystick_zone = 3;
inline void JoystickData::clear_joystick_zone() {
  joystick_zone_.ClearToEmpty();
}
inline const std::string& JoystickData::joystick_zone() const {
  // @@protoc_insertion_point(field_get:sensors.JoystickData.joystick_zone)
  return _internal_joystick_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoystickData::set_joystick_zone(ArgT0&& arg0, ArgT... args) {
 
 joystick_zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.JoystickData.joystick_zone)
}
inline std::string* JoystickData::mutable_joystick_zone() {
  std::string* _s = _internal_mutable_joystick_zone();
  // @@protoc_insertion_point(field_mutable:sensors.JoystickData.joystick_zone)
  return _s;
}
inline const std::string& JoystickData::_internal_joystick_zone() const {
  return joystick_zone_.Get();
}
inline void JoystickData::_internal_set_joystick_zone(const std::string& value) {
  
  joystick_zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoystickData::_internal_mutable_joystick_zone() {
  
  return joystick_zone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoystickData::release_joystick_zone() {
  // @@protoc_insertion_point(field_release:sensors.JoystickData.joystick_zone)
  return joystick_zone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JoystickData::set_allocated_joystick_zone(std::string* joystick_zone) {
  if (joystick_zone != nullptr) {
    
  } else {
    
  }
  joystick_zone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joystick_zone,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.JoystickData.joystick_zone)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool JoystickData::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool JoystickData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& JoystickData::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& JoystickData::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.JoystickData.timestamp)
  return _internal_timestamp();
}
inline void JoystickData::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.JoystickData.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JoystickData::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JoystickData::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.JoystickData.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JoystickData::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JoystickData::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.JoystickData.timestamp)
  return _msg;
}
inline void JoystickData::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.JoystickData.timestamp)
}

// -------------------------------------------------------------------

// Joystick

// int32 forward_back = 1;
inline void Joystick::clear_forward_back() {
  forward_back_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Joystick::_internal_forward_back() const {
  return forward_back_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Joystick::forward_back() const {
  // @@protoc_insertion_point(field_get:sensors.Joystick.forward_back)
  return _internal_forward_back();
}
inline void Joystick::_internal_set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  forward_back_ = value;
}
inline void Joystick::set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_forward_back(value);
  // @@protoc_insertion_point(field_set:sensors.Joystick.forward_back)
}

// int32 left_right = 2;
inline void Joystick::clear_left_right() {
  left_right_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Joystick::_internal_left_right() const {
  return left_right_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Joystick::left_right() const {
  // @@protoc_insertion_point(field_get:sensors.Joystick.left_right)
  return _internal_left_right();
}
inline void Joystick::_internal_set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  left_right_ = value;
}
inline void Joystick::set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_left_right(value);
  // @@protoc_insertion_point(field_set:sensors.Joystick.left_right)
}

// -------------------------------------------------------------------

// BatteryVoltage

// double battery_voltage = 1;
inline void BatteryVoltage::clear_battery_voltage() {
  battery_voltage_ = 0;
}
inline double BatteryVoltage::_internal_battery_voltage() const {
  return battery_voltage_;
}
inline double BatteryVoltage::battery_voltage() const {
  // @@protoc_insertion_point(field_get:sensors.BatteryVoltage.battery_voltage)
  return _internal_battery_voltage();
}
inline void BatteryVoltage::_internal_set_battery_voltage(double value) {
  
  battery_voltage_ = value;
}
inline void BatteryVoltage::set_battery_voltage(double value) {
  _internal_set_battery_voltage(value);
  // @@protoc_insertion_point(field_set:sensors.BatteryVoltage.battery_voltage)
}

// -------------------------------------------------------------------

// BatteryPercent

// int32 battery_percentage = 1;
inline void BatteryPercent::clear_battery_percentage() {
  battery_percentage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatteryPercent::_internal_battery_percentage() const {
  return battery_percentage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatteryPercent::battery_percentage() const {
  // @@protoc_insertion_point(field_get:sensors.BatteryPercent.battery_percentage)
  return _internal_battery_percentage();
}
inline void BatteryPercent::_internal_set_battery_percentage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  battery_percentage_ = value;
}
inline void BatteryPercent::set_battery_percentage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_battery_percentage(value);
  // @@protoc_insertion_point(field_set:sensors.BatteryPercent.battery_percentage)
}

// -------------------------------------------------------------------

// GPSData

// int32 latitude = 1;
inline void GPSData::clear_latitude() {
  latitude_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_latitude() const {
  return latitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::latitude() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.latitude)
  return _internal_latitude();
}
inline void GPSData::_internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  latitude_ = value;
}
inline void GPSData::set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.latitude)
}

// int32 longitude = 2;
inline void GPSData::clear_longitude() {
  longitude_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_longitude() const {
  return longitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::longitude() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.longitude)
  return _internal_longitude();
}
inline void GPSData::_internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  longitude_ = value;
}
inline void GPSData::set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.longitude)
}

// int32 heading_of_motion = 3;
inline void GPSData::clear_heading_of_motion() {
  heading_of_motion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_heading_of_motion() const {
  return heading_of_motion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::heading_of_motion() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.heading_of_motion)
  return _internal_heading_of_motion();
}
inline void GPSData::_internal_set_heading_of_motion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  heading_of_motion_ = value;
}
inline void GPSData::set_heading_of_motion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_heading_of_motion(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.heading_of_motion)
}

// uint32 number_of_sv = 4;
inline void GPSData::clear_number_of_sv() {
  number_of_sv_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GPSData::_internal_number_of_sv() const {
  return number_of_sv_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GPSData::number_of_sv() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.number_of_sv)
  return _internal_number_of_sv();
}
inline void GPSData::_internal_set_number_of_sv(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_sv_ = value;
}
inline void GPSData::set_number_of_sv(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number_of_sv(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.number_of_sv)
}

// uint32 hDOP = 5;
inline void GPSData::clear_hdop() {
  hdop_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GPSData::_internal_hdop() const {
  return hdop_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GPSData::hdop() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.hDOP)
  return _internal_hdop();
}
inline void GPSData::_internal_set_hdop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hdop_ = value;
}
inline void GPSData::set_hdop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hdop(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.hDOP)
}

// int32 height_above_sea = 6;
inline void GPSData::clear_height_above_sea() {
  height_above_sea_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_height_above_sea() const {
  return height_above_sea_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::height_above_sea() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.height_above_sea)
  return _internal_height_above_sea();
}
inline void GPSData::_internal_set_height_above_sea(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_above_sea_ = value;
}
inline void GPSData::set_height_above_sea(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height_above_sea(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.height_above_sea)
}

// int32 ground_speed = 7;
inline void GPSData::clear_ground_speed() {
  ground_speed_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_ground_speed() const {
  return ground_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::ground_speed() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.ground_speed)
  return _internal_ground_speed();
}
inline void GPSData::_internal_set_ground_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ground_speed_ = value;
}
inline void GPSData::set_ground_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ground_speed(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.ground_speed)
}

// .sensors.GPSData.quality_t quality = 8;
inline void GPSData::clear_quality() {
  quality_ = 0;
}
inline ::sensors::GPSData_quality_t GPSData::_internal_quality() const {
  return static_cast< ::sensors::GPSData_quality_t >(quality_);
}
inline ::sensors::GPSData_quality_t GPSData::quality() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.quality)
  return _internal_quality();
}
inline void GPSData::_internal_set_quality(::sensors::GPSData_quality_t value) {
  
  quality_ = value;
}
inline void GPSData::set_quality(::sensors::GPSData_quality_t value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.quality)
}

// int32 year = 9;
inline void GPSData::clear_year() {
  year_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_year() const {
  return year_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::year() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.year)
  return _internal_year();
}
inline void GPSData::_internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  year_ = value;
}
inline void GPSData::set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.year)
}

// int32 month = 10;
inline void GPSData::clear_month() {
  month_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_month() const {
  return month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::month() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.month)
  return _internal_month();
}
inline void GPSData::_internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  month_ = value;
}
inline void GPSData::set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.month)
}

// int32 day = 11;
inline void GPSData::clear_day() {
  day_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_day() const {
  return day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::day() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.day)
  return _internal_day();
}
inline void GPSData::_internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  day_ = value;
}
inline void GPSData::set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.day)
}

// int32 hour = 12;
inline void GPSData::clear_hour() {
  hour_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_hour() const {
  return hour_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::hour() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.hour)
  return _internal_hour();
}
inline void GPSData::_internal_set_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hour_ = value;
}
inline void GPSData::set_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.hour)
}

// int32 minute = 13;
inline void GPSData::clear_minute() {
  minute_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_minute() const {
  return minute_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::minute() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.minute)
  return _internal_minute();
}
inline void GPSData::_internal_set_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  minute_ = value;
}
inline void GPSData::set_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.minute)
}

// int32 second = 14;
inline void GPSData::clear_second() {
  second_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::_internal_second() const {
  return second_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GPSData::second() const {
  // @@protoc_insertion_point(field_get:sensors.GPSData.second)
  return _internal_second();
}
inline void GPSData::_internal_set_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  second_ = value;
}
inline void GPSData::set_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:sensors.GPSData.second)
}

// -------------------------------------------------------------------

// EncoderData

// float left_angle = 1;
inline void EncoderData::clear_left_angle() {
  left_angle_ = 0;
}
inline float EncoderData::_internal_left_angle() const {
  return left_angle_;
}
inline float EncoderData::left_angle() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.left_angle)
  return _internal_left_angle();
}
inline void EncoderData::_internal_set_left_angle(float value) {
  
  left_angle_ = value;
}
inline void EncoderData::set_left_angle(float value) {
  _internal_set_left_angle(value);
  // @@protoc_insertion_point(field_set:sensors.EncoderData.left_angle)
}

// float right_angle = 2;
inline void EncoderData::clear_right_angle() {
  right_angle_ = 0;
}
inline float EncoderData::_internal_right_angle() const {
  return right_angle_;
}
inline float EncoderData::right_angle() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.right_angle)
  return _internal_right_angle();
}
inline void EncoderData::_internal_set_right_angle(float value) {
  
  right_angle_ = value;
}
inline void EncoderData::set_right_angle(float value) {
  _internal_set_right_angle(value);
  // @@protoc_insertion_point(field_set:sensors.EncoderData.right_angle)
}

// float fl_caster_degrees = 3;
inline void EncoderData::clear_fl_caster_degrees() {
  fl_caster_degrees_ = 0;
}
inline float EncoderData::_internal_fl_caster_degrees() const {
  return fl_caster_degrees_;
}
inline float EncoderData::fl_caster_degrees() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.fl_caster_degrees)
  return _internal_fl_caster_degrees();
}
inline void EncoderData::_internal_set_fl_caster_degrees(float value) {
  
  fl_caster_degrees_ = value;
}
inline void EncoderData::set_fl_caster_degrees(float value) {
  _internal_set_fl_caster_degrees(value);
  // @@protoc_insertion_point(field_set:sensors.EncoderData.fl_caster_degrees)
}

// float bl_caster_degrees = 4;
inline void EncoderData::clear_bl_caster_degrees() {
  bl_caster_degrees_ = 0;
}
inline float EncoderData::_internal_bl_caster_degrees() const {
  return bl_caster_degrees_;
}
inline float EncoderData::bl_caster_degrees() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.bl_caster_degrees)
  return _internal_bl_caster_degrees();
}
inline void EncoderData::_internal_set_bl_caster_degrees(float value) {
  
  bl_caster_degrees_ = value;
}
inline void EncoderData::set_bl_caster_degrees(float value) {
  _internal_set_bl_caster_degrees(value);
  // @@protoc_insertion_point(field_set:sensors.EncoderData.bl_caster_degrees)
}

// float fr_caster_degrees = 5;
inline void EncoderData::clear_fr_caster_degrees() {
  fr_caster_degrees_ = 0;
}
inline float EncoderData::_internal_fr_caster_degrees() const {
  return fr_caster_degrees_;
}
inline float EncoderData::fr_caster_degrees() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.fr_caster_degrees)
  return _internal_fr_caster_degrees();
}
inline void EncoderData::_internal_set_fr_caster_degrees(float value) {
  
  fr_caster_degrees_ = value;
}
inline void EncoderData::set_fr_caster_degrees(float value) {
  _internal_set_fr_caster_degrees(value);
  // @@protoc_insertion_point(field_set:sensors.EncoderData.fr_caster_degrees)
}

// float br_caster_degrees = 6;
inline void EncoderData::clear_br_caster_degrees() {
  br_caster_degrees_ = 0;
}
inline float EncoderData::_internal_br_caster_degrees() const {
  return br_caster_degrees_;
}
inline float EncoderData::br_caster_degrees() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.br_caster_degrees)
  return _internal_br_caster_degrees();
}
inline void EncoderData::_internal_set_br_caster_degrees(float value) {
  
  br_caster_degrees_ = value;
}
inline void EncoderData::set_br_caster_degrees(float value) {
  _internal_set_br_caster_degrees(value);
  // @@protoc_insertion_point(field_set:sensors.EncoderData.br_caster_degrees)
}

// .google.protobuf.Timestamp timestamp = 7;
inline bool EncoderData::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool EncoderData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EncoderData::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EncoderData::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.EncoderData.timestamp)
  return _internal_timestamp();
}
inline void EncoderData::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.EncoderData.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EncoderData::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EncoderData::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.EncoderData.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EncoderData::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EncoderData::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.EncoderData.timestamp)
  return _msg;
}
inline void EncoderData::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.EncoderData.timestamp)
}

// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  x_ = 0;
}
inline float Vec3::_internal_x() const {
  return x_;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:sensors.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sensors.Vec3.x)
}

// float y = 2;
inline void Vec3::clear_y() {
  y_ = 0;
}
inline float Vec3::_internal_y() const {
  return y_;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:sensors.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sensors.Vec3.y)
}

// float z = 3;
inline void Vec3::clear_z() {
  z_ = 0;
}
inline float Vec3::_internal_z() const {
  return z_;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:sensors.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sensors.Vec3.z)
}

// -------------------------------------------------------------------

// Vec4

// float w = 1;
inline void Vec4::clear_w() {
  w_ = 0;
}
inline float Vec4::_internal_w() const {
  return w_;
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:sensors.Vec4.w)
  return _internal_w();
}
inline void Vec4::_internal_set_w(float value) {
  
  w_ = value;
}
inline void Vec4::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:sensors.Vec4.w)
}

// float x = 2;
inline void Vec4::clear_x() {
  x_ = 0;
}
inline float Vec4::_internal_x() const {
  return x_;
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:sensors.Vec4.x)
  return _internal_x();
}
inline void Vec4::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec4::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sensors.Vec4.x)
}

// float y = 3;
inline void Vec4::clear_y() {
  y_ = 0;
}
inline float Vec4::_internal_y() const {
  return y_;
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:sensors.Vec4.y)
  return _internal_y();
}
inline void Vec4::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec4::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sensors.Vec4.y)
}

// float z = 4;
inline void Vec4::clear_z() {
  z_ = 0;
}
inline float Vec4::_internal_z() const {
  return z_;
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:sensors.Vec4.z)
  return _internal_z();
}
inline void Vec4::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec4::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sensors.Vec4.z)
}

// -------------------------------------------------------------------

// IrFrame

// bytes frame = 1;
inline void IrFrame::clear_frame() {
  frame_.ClearToEmpty();
}
inline const std::string& IrFrame::frame() const {
  // @@protoc_insertion_point(field_get:sensors.IrFrame.frame)
  return _internal_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IrFrame::set_frame(ArgT0&& arg0, ArgT... args) {
 
 frame_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.IrFrame.frame)
}
inline std::string* IrFrame::mutable_frame() {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:sensors.IrFrame.frame)
  return _s;
}
inline const std::string& IrFrame::_internal_frame() const {
  return frame_.Get();
}
inline void IrFrame::_internal_set_frame(const std::string& value) {
  
  frame_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IrFrame::_internal_mutable_frame() {
  
  return frame_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IrFrame::release_frame() {
  // @@protoc_insertion_point(field_release:sensors.IrFrame.frame)
  return frame_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IrFrame::set_allocated_frame(std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  frame_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.IrFrame.frame)
}

// int32 width = 2;
inline void IrFrame::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IrFrame::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IrFrame::width() const {
  // @@protoc_insertion_point(field_get:sensors.IrFrame.width)
  return _internal_width();
}
inline void IrFrame::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void IrFrame::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:sensors.IrFrame.width)
}

// int32 height = 3;
inline void IrFrame::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IrFrame::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IrFrame::height() const {
  // @@protoc_insertion_point(field_get:sensors.IrFrame.height)
  return _internal_height();
}
inline void IrFrame::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void IrFrame::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:sensors.IrFrame.height)
}

// string camera = 4;
inline void IrFrame::clear_camera() {
  camera_.ClearToEmpty();
}
inline const std::string& IrFrame::camera() const {
  // @@protoc_insertion_point(field_get:sensors.IrFrame.camera)
  return _internal_camera();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IrFrame::set_camera(ArgT0&& arg0, ArgT... args) {
 
 camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensors.IrFrame.camera)
}
inline std::string* IrFrame::mutable_camera() {
  std::string* _s = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:sensors.IrFrame.camera)
  return _s;
}
inline const std::string& IrFrame::_internal_camera() const {
  return camera_.Get();
}
inline void IrFrame::_internal_set_camera(const std::string& value) {
  
  camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IrFrame::_internal_mutable_camera() {
  
  return camera_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IrFrame::release_camera() {
  // @@protoc_insertion_point(field_release:sensors.IrFrame.camera)
  return camera_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IrFrame::set_allocated_camera(std::string* camera) {
  if (camera != nullptr) {
    
  } else {
    
  }
  camera_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camera,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensors.IrFrame.camera)
}

// int32 size = 5;
inline void IrFrame::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IrFrame::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IrFrame::size() const {
  // @@protoc_insertion_point(field_get:sensors.IrFrame.size)
  return _internal_size();
}
inline void IrFrame::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void IrFrame::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sensors.IrFrame.size)
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool IrFrame::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool IrFrame::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IrFrame::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IrFrame::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.IrFrame.timestamp)
  return _internal_timestamp();
}
inline void IrFrame::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.IrFrame.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IrFrame::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IrFrame::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.IrFrame.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IrFrame::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IrFrame::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.IrFrame.timestamp)
  return _msg;
}
inline void IrFrame::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.IrFrame.timestamp)
}

// -------------------------------------------------------------------

// AhrsData

// .sensors.Vec3 linear_velocity = 1;
inline bool AhrsData::_internal_has_linear_velocity() const {
  return this != internal_default_instance() && linear_velocity_ != nullptr;
}
inline bool AhrsData::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline void AhrsData::clear_linear_velocity() {
  if (GetArenaForAllocation() == nullptr && linear_velocity_ != nullptr) {
    delete linear_velocity_;
  }
  linear_velocity_ = nullptr;
}
inline const ::sensors::Vec3& AhrsData::_internal_linear_velocity() const {
  const ::sensors::Vec3* p = linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::Vec3&>(
      ::sensors::_Vec3_default_instance_);
}
inline const ::sensors::Vec3& AhrsData::linear_velocity() const {
  // @@protoc_insertion_point(field_get:sensors.AhrsData.linear_velocity)
  return _internal_linear_velocity();
}
inline void AhrsData::unsafe_arena_set_allocated_linear_velocity(
    ::sensors::Vec3* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_velocity_);
  }
  linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.AhrsData.linear_velocity)
}
inline ::sensors::Vec3* AhrsData::release_linear_velocity() {
  
  ::sensors::Vec3* temp = linear_velocity_;
  linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::Vec3* AhrsData::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:sensors.AhrsData.linear_velocity)
  
  ::sensors::Vec3* temp = linear_velocity_;
  linear_velocity_ = nullptr;
  return temp;
}
inline ::sensors::Vec3* AhrsData::_internal_mutable_linear_velocity() {
  
  if (linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::Vec3>(GetArenaForAllocation());
    linear_velocity_ = p;
  }
  return linear_velocity_;
}
inline ::sensors::Vec3* AhrsData::mutable_linear_velocity() {
  ::sensors::Vec3* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:sensors.AhrsData.linear_velocity)
  return _msg;
}
inline void AhrsData::set_allocated_linear_velocity(::sensors::Vec3* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete linear_velocity_;
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::Vec3>::GetOwningArena(linear_velocity);
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:sensors.AhrsData.linear_velocity)
}

// .sensors.Vec3 linear_acceleration = 2;
inline bool AhrsData::_internal_has_linear_acceleration() const {
  return this != internal_default_instance() && linear_acceleration_ != nullptr;
}
inline bool AhrsData::has_linear_acceleration() const {
  return _internal_has_linear_acceleration();
}
inline void AhrsData::clear_linear_acceleration() {
  if (GetArenaForAllocation() == nullptr && linear_acceleration_ != nullptr) {
    delete linear_acceleration_;
  }
  linear_acceleration_ = nullptr;
}
inline const ::sensors::Vec3& AhrsData::_internal_linear_acceleration() const {
  const ::sensors::Vec3* p = linear_acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::Vec3&>(
      ::sensors::_Vec3_default_instance_);
}
inline const ::sensors::Vec3& AhrsData::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:sensors.AhrsData.linear_acceleration)
  return _internal_linear_acceleration();
}
inline void AhrsData::unsafe_arena_set_allocated_linear_acceleration(
    ::sensors::Vec3* linear_acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_acceleration_);
  }
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.AhrsData.linear_acceleration)
}
inline ::sensors::Vec3* AhrsData::release_linear_acceleration() {
  
  ::sensors::Vec3* temp = linear_acceleration_;
  linear_acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::Vec3* AhrsData::unsafe_arena_release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:sensors.AhrsData.linear_acceleration)
  
  ::sensors::Vec3* temp = linear_acceleration_;
  linear_acceleration_ = nullptr;
  return temp;
}
inline ::sensors::Vec3* AhrsData::_internal_mutable_linear_acceleration() {
  
  if (linear_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::Vec3>(GetArenaForAllocation());
    linear_acceleration_ = p;
  }
  return linear_acceleration_;
}
inline ::sensors::Vec3* AhrsData::mutable_linear_acceleration() {
  ::sensors::Vec3* _msg = _internal_mutable_linear_acceleration();
  // @@protoc_insertion_point(field_mutable:sensors.AhrsData.linear_acceleration)
  return _msg;
}
inline void AhrsData::set_allocated_linear_acceleration(::sensors::Vec3* linear_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete linear_acceleration_;
  }
  if (linear_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::Vec3>::GetOwningArena(linear_acceleration);
    if (message_arena != submessage_arena) {
      linear_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  linear_acceleration_ = linear_acceleration;
  // @@protoc_insertion_point(field_set_allocated:sensors.AhrsData.linear_acceleration)
}

// .sensors.Vec3 angular_velocity = 3;
inline bool AhrsData::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != nullptr;
}
inline bool AhrsData::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void AhrsData::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && angular_velocity_ != nullptr) {
    delete angular_velocity_;
  }
  angular_velocity_ = nullptr;
}
inline const ::sensors::Vec3& AhrsData::_internal_angular_velocity() const {
  const ::sensors::Vec3* p = angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::Vec3&>(
      ::sensors::_Vec3_default_instance_);
}
inline const ::sensors::Vec3& AhrsData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:sensors.AhrsData.angular_velocity)
  return _internal_angular_velocity();
}
inline void AhrsData::unsafe_arena_set_allocated_angular_velocity(
    ::sensors::Vec3* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_velocity_);
  }
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.AhrsData.angular_velocity)
}
inline ::sensors::Vec3* AhrsData::release_angular_velocity() {
  
  ::sensors::Vec3* temp = angular_velocity_;
  angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::Vec3* AhrsData::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:sensors.AhrsData.angular_velocity)
  
  ::sensors::Vec3* temp = angular_velocity_;
  angular_velocity_ = nullptr;
  return temp;
}
inline ::sensors::Vec3* AhrsData::_internal_mutable_angular_velocity() {
  
  if (angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::Vec3>(GetArenaForAllocation());
    angular_velocity_ = p;
  }
  return angular_velocity_;
}
inline ::sensors::Vec3* AhrsData::mutable_angular_velocity() {
  ::sensors::Vec3* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:sensors.AhrsData.angular_velocity)
  return _msg;
}
inline void AhrsData::set_allocated_angular_velocity(::sensors::Vec3* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::Vec3>::GetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:sensors.AhrsData.angular_velocity)
}

// .sensors.Vec3 angular_acceleration = 4;
inline bool AhrsData::_internal_has_angular_acceleration() const {
  return this != internal_default_instance() && angular_acceleration_ != nullptr;
}
inline bool AhrsData::has_angular_acceleration() const {
  return _internal_has_angular_acceleration();
}
inline void AhrsData::clear_angular_acceleration() {
  if (GetArenaForAllocation() == nullptr && angular_acceleration_ != nullptr) {
    delete angular_acceleration_;
  }
  angular_acceleration_ = nullptr;
}
inline const ::sensors::Vec3& AhrsData::_internal_angular_acceleration() const {
  const ::sensors::Vec3* p = angular_acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::Vec3&>(
      ::sensors::_Vec3_default_instance_);
}
inline const ::sensors::Vec3& AhrsData::angular_acceleration() const {
  // @@protoc_insertion_point(field_get:sensors.AhrsData.angular_acceleration)
  return _internal_angular_acceleration();
}
inline void AhrsData::unsafe_arena_set_allocated_angular_acceleration(
    ::sensors::Vec3* angular_acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_acceleration_);
  }
  angular_acceleration_ = angular_acceleration;
  if (angular_acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.AhrsData.angular_acceleration)
}
inline ::sensors::Vec3* AhrsData::release_angular_acceleration() {
  
  ::sensors::Vec3* temp = angular_acceleration_;
  angular_acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::Vec3* AhrsData::unsafe_arena_release_angular_acceleration() {
  // @@protoc_insertion_point(field_release:sensors.AhrsData.angular_acceleration)
  
  ::sensors::Vec3* temp = angular_acceleration_;
  angular_acceleration_ = nullptr;
  return temp;
}
inline ::sensors::Vec3* AhrsData::_internal_mutable_angular_acceleration() {
  
  if (angular_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::Vec3>(GetArenaForAllocation());
    angular_acceleration_ = p;
  }
  return angular_acceleration_;
}
inline ::sensors::Vec3* AhrsData::mutable_angular_acceleration() {
  ::sensors::Vec3* _msg = _internal_mutable_angular_acceleration();
  // @@protoc_insertion_point(field_mutable:sensors.AhrsData.angular_acceleration)
  return _msg;
}
inline void AhrsData::set_allocated_angular_acceleration(::sensors::Vec3* angular_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete angular_acceleration_;
  }
  if (angular_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::Vec3>::GetOwningArena(angular_acceleration);
    if (message_arena != submessage_arena) {
      angular_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  angular_acceleration_ = angular_acceleration;
  // @@protoc_insertion_point(field_set_allocated:sensors.AhrsData.angular_acceleration)
}

// .sensors.Vec4 orientation = 5;
inline bool AhrsData::_internal_has_orientation() const {
  return this != internal_default_instance() && orientation_ != nullptr;
}
inline bool AhrsData::has_orientation() const {
  return _internal_has_orientation();
}
inline void AhrsData::clear_orientation() {
  if (GetArenaForAllocation() == nullptr && orientation_ != nullptr) {
    delete orientation_;
  }
  orientation_ = nullptr;
}
inline const ::sensors::Vec4& AhrsData::_internal_orientation() const {
  const ::sensors::Vec4* p = orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensors::Vec4&>(
      ::sensors::_Vec4_default_instance_);
}
inline const ::sensors::Vec4& AhrsData::orientation() const {
  // @@protoc_insertion_point(field_get:sensors.AhrsData.orientation)
  return _internal_orientation();
}
inline void AhrsData::unsafe_arena_set_allocated_orientation(
    ::sensors::Vec4* orientation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.AhrsData.orientation)
}
inline ::sensors::Vec4* AhrsData::release_orientation() {
  
  ::sensors::Vec4* temp = orientation_;
  orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensors::Vec4* AhrsData::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:sensors.AhrsData.orientation)
  
  ::sensors::Vec4* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::sensors::Vec4* AhrsData::_internal_mutable_orientation() {
  
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensors::Vec4>(GetArenaForAllocation());
    orientation_ = p;
  }
  return orientation_;
}
inline ::sensors::Vec4* AhrsData::mutable_orientation() {
  ::sensors::Vec4* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:sensors.AhrsData.orientation)
  return _msg;
}
inline void AhrsData::set_allocated_orientation(::sensors::Vec4* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensors::Vec4>::GetOwningArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:sensors.AhrsData.orientation)
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool AhrsData::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool AhrsData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AhrsData::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AhrsData::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.AhrsData.timestamp)
  return _internal_timestamp();
}
inline void AhrsData::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.AhrsData.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AhrsData::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AhrsData::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.AhrsData.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AhrsData::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AhrsData::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.AhrsData.timestamp)
  return _msg;
}
inline void AhrsData::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.AhrsData.timestamp)
}

// -------------------------------------------------------------------

// RemoteJsValues

// int32 forward_back = 1;
inline void RemoteJsValues::clear_forward_back() {
  forward_back_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteJsValues::_internal_forward_back() const {
  return forward_back_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteJsValues::forward_back() const {
  // @@protoc_insertion_point(field_get:sensors.RemoteJsValues.forward_back)
  return _internal_forward_back();
}
inline void RemoteJsValues::_internal_set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  forward_back_ = value;
}
inline void RemoteJsValues::set_forward_back(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_forward_back(value);
  // @@protoc_insertion_point(field_set:sensors.RemoteJsValues.forward_back)
}

// int32 left_right = 2;
inline void RemoteJsValues::clear_left_right() {
  left_right_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteJsValues::_internal_left_right() const {
  return left_right_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteJsValues::left_right() const {
  // @@protoc_insertion_point(field_get:sensors.RemoteJsValues.left_right)
  return _internal_left_right();
}
inline void RemoteJsValues::_internal_set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  left_right_ = value;
}
inline void RemoteJsValues::set_left_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_left_right(value);
  // @@protoc_insertion_point(field_set:sensors.RemoteJsValues.left_right)
}

// -------------------------------------------------------------------

// ModeCtrl

// .sensors.DriveMode mode = 1;
inline void ModeCtrl::clear_mode() {
  mode_ = 0;
}
inline ::sensors::DriveMode ModeCtrl::_internal_mode() const {
  return static_cast< ::sensors::DriveMode >(mode_);
}
inline ::sensors::DriveMode ModeCtrl::mode() const {
  // @@protoc_insertion_point(field_get:sensors.ModeCtrl.mode)
  return _internal_mode();
}
inline void ModeCtrl::_internal_set_mode(::sensors::DriveMode value) {
  
  mode_ = value;
}
inline void ModeCtrl::set_mode(::sensors::DriveMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:sensors.ModeCtrl.mode)
}

// -------------------------------------------------------------------

// RampMode

// bool ramp_mode = 1;
inline void RampMode::clear_ramp_mode() {
  ramp_mode_ = false;
}
inline bool RampMode::_internal_ramp_mode() const {
  return ramp_mode_;
}
inline bool RampMode::ramp_mode() const {
  // @@protoc_insertion_point(field_get:sensors.RampMode.ramp_mode)
  return _internal_ramp_mode();
}
inline void RampMode::_internal_set_ramp_mode(bool value) {
  
  ramp_mode_ = value;
}
inline void RampMode::set_ramp_mode(bool value) {
  _internal_set_ramp_mode(value);
  // @@protoc_insertion_point(field_set:sensors.RampMode.ramp_mode)
}

// bool ramp_approach = 2;
inline void RampMode::clear_ramp_approach() {
  ramp_approach_ = false;
}
inline bool RampMode::_internal_ramp_approach() const {
  return ramp_approach_;
}
inline bool RampMode::ramp_approach() const {
  // @@protoc_insertion_point(field_get:sensors.RampMode.ramp_approach)
  return _internal_ramp_approach();
}
inline void RampMode::_internal_set_ramp_approach(bool value) {
  
  ramp_approach_ = value;
}
inline void RampMode::set_ramp_approach(bool value) {
  _internal_set_ramp_approach(value);
  // @@protoc_insertion_point(field_set:sensors.RampMode.ramp_approach)
}

// -------------------------------------------------------------------

// RampAssistStates

// bool state = 1;
inline void RampAssistStates::clear_state() {
  state_ = false;
}
inline bool RampAssistStates::_internal_state() const {
  return state_;
}
inline bool RampAssistStates::state() const {
  // @@protoc_insertion_point(field_get:sensors.RampAssistStates.state)
  return _internal_state();
}
inline void RampAssistStates::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void RampAssistStates::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:sensors.RampAssistStates.state)
}

// bool approach = 2;
inline void RampAssistStates::clear_approach() {
  approach_ = false;
}
inline bool RampAssistStates::_internal_approach() const {
  return approach_;
}
inline bool RampAssistStates::approach() const {
  // @@protoc_insertion_point(field_get:sensors.RampAssistStates.approach)
  return _internal_approach();
}
inline void RampAssistStates::_internal_set_approach(bool value) {
  
  approach_ = value;
}
inline void RampAssistStates::set_approach(bool value) {
  _internal_set_approach(value);
  // @@protoc_insertion_point(field_set:sensors.RampAssistStates.approach)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool RampAssistStates::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool RampAssistStates::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RampAssistStates::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RampAssistStates::timestamp() const {
  // @@protoc_insertion_point(field_get:sensors.RampAssistStates.timestamp)
  return _internal_timestamp();
}
inline void RampAssistStates::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensors.RampAssistStates.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RampAssistStates::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RampAssistStates::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sensors.RampAssistStates.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RampAssistStates::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RampAssistStates::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sensors.RampAssistStates.timestamp)
  return _msg;
}
inline void RampAssistStates::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensors.RampAssistStates.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sensors

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensors::AudioPlaybackRequest_RequestedPlayback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::AudioPlaybackRequest_RequestedPlayback>() {
  return ::sensors::AudioPlaybackRequest_RequestedPlayback_descriptor();
}
template <> struct is_proto_enum< ::sensors::StartModeData_StartModes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::StartModeData_StartModes>() {
  return ::sensors::StartModeData_StartModes_descriptor();
}
template <> struct is_proto_enum< ::sensors::DFSeatEvent_EventGroup> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::DFSeatEvent_EventGroup>() {
  return ::sensors::DFSeatEvent_EventGroup_descriptor();
}
template <> struct is_proto_enum< ::sensors::DFSeatEvent_EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::DFSeatEvent_EventType>() {
  return ::sensors::DFSeatEvent_EventType_descriptor();
}
template <> struct is_proto_enum< ::sensors::Led_Leds> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::Led_Leds>() {
  return ::sensors::Led_Leds_descriptor();
}
template <> struct is_proto_enum< ::sensors::HmiState_States> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::HmiState_States>() {
  return ::sensors::HmiState_States_descriptor();
}
template <> struct is_proto_enum< ::sensors::HmiStreamData_ButtonState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::HmiStreamData_ButtonState>() {
  return ::sensors::HmiStreamData_ButtonState_descriptor();
}
template <> struct is_proto_enum< ::sensors::UltrasonicCtrl_Board> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::UltrasonicCtrl_Board>() {
  return ::sensors::UltrasonicCtrl_Board_descriptor();
}
template <> struct is_proto_enum< ::sensors::UltrasonicDistance_Board> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::UltrasonicDistance_Board>() {
  return ::sensors::UltrasonicDistance_Board_descriptor();
}
template <> struct is_proto_enum< ::sensors::UltrasonicCurve_Board> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::UltrasonicCurve_Board>() {
  return ::sensors::UltrasonicCurve_Board_descriptor();
}
template <> struct is_proto_enum< ::sensors::RadarFilter_Filter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::RadarFilter_Filter>() {
  return ::sensors::RadarFilter_Filter_descriptor();
}
template <> struct is_proto_enum< ::sensors::RadarCtrl_Radar> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::RadarCtrl_Radar>() {
  return ::sensors::RadarCtrl_Radar_descriptor();
}
template <> struct is_proto_enum< ::sensors::RadarPoints_Radar> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::RadarPoints_Radar>() {
  return ::sensors::RadarPoints_Radar_descriptor();
}
template <> struct is_proto_enum< ::sensors::ImuData_CalibrationStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::ImuData_CalibrationStatus>() {
  return ::sensors::ImuData_CalibrationStatus_descriptor();
}
template <> struct is_proto_enum< ::sensors::GPSData_quality_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::GPSData_quality_t>() {
  return ::sensors::GPSData_quality_t_descriptor();
}
template <> struct is_proto_enum< ::sensors::Imu> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::Imu>() {
  return ::sensors::Imu_descriptor();
}
template <> struct is_proto_enum< ::sensors::DriveMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::DriveMode>() {
  return ::sensors::DriveMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ptolemy_2eproto
